[{"content":"Toàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống kiến của các tác giả của những kênh nói trên.❤️❤️❤️  Giới thiệu về Image Busybox Busybox là một image rất nhỏ gọn nhưng chứa rất nhiều công cụ dựa trên nền tảng linux.\nTải image busybox:\n1 2 3 4 5 6  ❯ docker pull busybox Using default tag: latest latest: Pulling from library/busybox b71f96345d44: Pull complete Digest: sha256:930490f97e5b921535c153e0e7110d251134cc4b72bbb8133c6a5065cc68580d Status: Downloaded newer image for busybox:latest   Tạo một container chạy image busybox\n1 2  ❯ docker run -it --rm busybox / #    Option --rm dùng cho những container muốn chạy một lần, sau khi chạy xong docker sẽ tự động xóa container đó đi.\nContainer của image busybox có rất nhiều lệnh, để liệt kê các lệnh, ta dùng:\n1 2 3 4 5 6 7  / # ls /bin/ -la  total 449700 drwxr-xr-x 2 root root 12288 Jun 7 17:34 . drwxr-xr-x 1 root root 4096 Jun 9 16:00 .. -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 [ -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 [[ -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 acpid   Giới thiệu mạng, network trong docker, mạng bridge Liệt kê các mạng có trong docker. Kiểm tra trong docker có những mạng nào, ta dùng lệnh:\n1 2 3 4 5  ❯ docker network ls NETWORK ID NAME DRIVER SCOPE e0b165102300 bridge bridge local 0f2ab02aa9f4 host host local 271997adaaa9 none null local   Ở đây chúng ta có 3 network được tạo mặc định khi docker tạo, bao gồm: bridge dùng DRIVER bridge, host dùng DRIVE host và none dùng DRIVE null.\nKiểm tra thông tin network Để kiểm tra thông tin về một network cũng như những container nào kết nối vào, ta dùng lệnh:\ndocker network inspect \u0026lt;NAME\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;e0b1651023003b4e6235e7b45319daa20d80a247d66e0b303eaf5e53fb90f0f8\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-09T20:59:15.89942017+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: {}, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ]   Ở đây chúng ta chú ý, trường Container rỗng, có nghĩa là không có container nào kết nối vào.\nMạng bridge. Ta tiến hành tạo một container B1 và kiêm tra lại mạng bridge.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  ❯ docker run -it --name B1 busybox / # % ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f6dd1dda04d busybox \u0026#34;sh\u0026#34; 9 seconds ago Up 8 seconds B1 ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;e0b1651023003b4e6235e7b45319daa20d80a247d66e0b303eaf5e53fb90f0f8\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-09T20:59:15.89942017+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;2f6dd1dda04d0ab42434a6cff6f9c7eb42474f81acdf32809486f8fa82be8951\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B1\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;0af6a3739786e89d5161f25edf7bb2a5d900ab580ab53e8f852a197134e010b7\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ]   Xem lại trường container thì đã thấy có thêm một container có tên là B1 đang chạy. Ngoài ra chúng ta còn có thể kiếm tra container đang dùng mạng nào và được cấp địa chỉ IP bằng bao nhiêu thông qua lệnh docker inspect \u0026lt;container_name\u0026gt;\nTạo ra thêm 1 container tên B2, khi đó container B1, B2 có thể nhìn thấy nhau, chúng ta có thể kiểm tra thông qua lệnh ping.\nTrong image busybox, có sẵn một công cụ để tạo máy chủ web http. Giả sử ta muốn cho container B2 chạy máy chủ web http, chúng ta vào /var/www và chạy lệnh httpd\n1 2 3 4 5 6 7  ❯ docker attach B2 / # cd var/ /var # ls spool www /var # cd www/ /var/www # httpd /var/www #    Tạo một file index.html với nội dung là:\n1  web server is running...   Từ container B1, ta tiến hành wget tới B2\n1 2 3 4 5 6 7 8  ❯ docker attach B1 / # wget -O - 172.17.0.3 Connecting to 172.17.0.3 (172.17.0.3:80) writing to stdout web server is running... - 100% |********************************| 25 0:00:00 ETA written to stdout / #    Với 172.17.0.3 là địa chỉ của container B2, có thể xem bằng lệnh docker network inspect bridge. Rõ ràng, container B1 đã đọc được file index mà B2 trả về với dòng chữ web server is running...\nÁnh xạ cổng mạng trong docker Ánh xạ cổng mạng B2 đang mở cổng 80, máy host của chúng ta đang có địa chỉ là 127.0.0.1, chúng ta muốn từ ngoài mạng truy cập được tới container B2 thì phải ánh xạ cổng 80 của B2 tới một cổng nào đó của host. Trong ví dụ này, chúng ta sẽ thiết lập truy cập đến cổng 80 của B2 thông qua cổng 8888 ip máy host 127.0.0.1.\nĐiều này được làm ở bước tạo container B2, lúc tạo chúng ta sẽ ánh xạ cổng 80 tới cổng 8888 của máy host. Cú pháp như sau:\ndocker run -it --name \u0026lt;name\u0026gt; -p \u0026lt;host_port\u0026gt;:\u0026lt;container_port\u0026gt; image\n1 2  ❯ docker run -it --name B2 -p 8888:80 busybox / #    Khi kiểm tra bằng lệnh docker ps ta sẽ thấy container B2 đã ánh xạ cổng 80 lệnh 8888 của máy host ở PORT.\n1 2 3  ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bdd19faad9cf busybox \u0026#34;sh\u0026#34; 8 minutes ago Up 8 minutes 0.0.0.0:8888-\u0026gt;80/tcp B2   Chúng ta sẽ thao tác lại một lần ở docker B2 để chạy httpd và tạo file index.html với nội dung web server is running... trong thư mục /var/www. Sau đó, chúng ta truy cập ở trình duyện chrome từ máy host đến địa chỉ 127.0.0.1:8888\nNhư vậy, ta đã có thể truy cập đến file index.html trong container B2 từ mạng bên ngoài host.\nTạo thêm mạng Trường hợp chúng ta không muốn tất cả các container cùng kết nối vào một mạng bridge, ta có thể tạo thêm nhiều bridge riêng để có thể tách các riêng các container thành các cụm riêng. Để tạo ra một mạng bridge, ta dùng lệnh:\ndocker network create --driver \u0026lt;loai_mang\u0026gt; \u0026lt;ten_mang\u0026gt;\nỞ đây chúng ta muốn tạo thêm mạng bridge nên sau --driver sẽ là bridge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 271997adaaa9 none null local ❯ docker network create --driver bridge mynetwork 6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0 ❯ docker network create --driver bridge network1 8f94d7a2e8ff372c3072294dd5260bbea0d0fb2692c2bedc3acad080b07b229c ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 6c224f5d1a98 mynetwork bridge local 8f94d7a2e8ff network1 bridge local 271997adaaa9 none null local   Chúng ta tiến hành tạo một số container không kết nối mặc định vào network bridge mà sẽ kết nối vào mynetwork của chúng ta.\n1 2  ❯ docker run -it --name B3 --network mynetwork busybox / #    Để chỉ định network khi tạo, ta thêm tùy chọn --network và theo sau là tên của network mình muốn kết nối tới. Chúng ta kiểm tra xem B3 có thật sự đã kết nối tới mynetwork chưa.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  ❯ docker network inspect mynetwork [ { \u0026#34;Name\u0026#34;: \u0026#34;mynetwork\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T07:59:52.392658153+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.20.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.20.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;d8f6cf60953a1ebd7c1a84a95e5503bc726a5e77df2c939e8072fe6ca7406d65\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: {}, \u0026#34;Labels\u0026#34;: {} } ]   Rõ ràng ở trường container đã thêm một container là B3 với địa chỉ là 172.20.0.2. Chúng ta tiếp tục tạo thêm một container B4 kết nối với mynetwork và chỉ định cổng 80 của nó ánh xạ tới cổng 9999 trên máy host.\n1 2 3 4 5 6 7 8  ❯ docker run -it --name B4 --network mynetwork -p 9999:80 busybox / # %  ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b39318c8d5b busybox \u0026#34;sh\u0026#34; About a minute ago Up About a minute 0.0.0.0:9999-\u0026gt;80/tcp B4 a7231f2ebe67 busybox \u0026#34;sh\u0026#34; 5 minutes ago Up 5 minutes B3 bdd19faad9cf busybox \u0026#34;sh\u0026#34; 37 minutes ago Up 37 minutes 0.0.0.0:8888-\u0026gt;80/tcp B2 2f6dd1dda04d busybox \u0026#34;sh\u0026#34; 9 hours ago Up 3 seconds B1   Như vậy, trên máy của chúng ta đang 2 mạng là bridge và mynetwork:\n Mạng bridge có 2 container đang kết nối tới là B1 và B2, trong đó B2 đang ánh xạ cổng 80 đến cổng 8888 trên máy host. Mạng mynetwork có 2 container đang kết nối tới là B3 và B4, trong đó B4 đang ánh xạ cổng 80 đến cổng 9999 trên host.\nTa tiến hành chạy web server http trên container B4 và kết nối từ mạng bên ngoài host.\nKhi tạo ra 2 network thì những máy cùng 1 network (B1 với B2 hoặc B3 với B4) có thể thấy được nhau, tuy nhiên ở khác network (B1 với B3,B4 hoặc B2 với B3,B4) thì không thể thấy nhau. Chúng ta có thể kiểm tra điều này thông qua lênh ping, từ B1 đến B2 và B1 đến B3. Dùng lệnh docker network inspect \u0026lt;ten_network\u0026gt; ta biết được ip của B1, B2, B3 lần lượt là 172.17.0.3, 172.17.0.2, 172.20.0.2. Vào B1 và tiến hành ping qua B2, B3:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  ❯ docker attach B1 / # ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2): 56 data bytes 64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.268 ms 64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.101 ms 64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.198 ms 64 bytes from 172.17.0.2: seq=3 ttl=64 time=0.162 ms 64 bytes from 172.17.0.2: seq=4 ttl=64 time=0.165 ms 64 bytes from 172.17.0.2: seq=5 ttl=64 time=0.164 ms 64 bytes from 172.17.0.2: seq=6 ttl=64 time=0.139 ms 64 bytes from 172.17.0.2: seq=7 ttl=64 time=0.160 ms 64 bytes from 172.17.0.2: seq=8 ttl=64 time=0.181 ms ^C --- 172.17.0.2 ping statistics --- 9 packets transmitted, 9 packets received, 0% packet loss round-trip min/avg/max = 0.101/0.170/0.268 ms / # ping 172.20.0.2 PING 172.20.0.2 (172.20.0.2): 56 data bytes ^C --- 172.20.0.2 ping statistics --- 25 packets transmitted, 0 packets received, 100% packet loss / #    Ánh xạ cổng cho một container đang chạy. Trong ví dụ trên, B3 đang kết nối tới mynetwork, ta muốn cho B3 kết nối thẳng tới network bridge, ta làm như sau:\ndocker network connect \u0026lt;ten_mang_muon_ket_noi\u0026gt; \u0026lt;ten_container\u0026gt;\n1  ❯ docker network connect bridge B3   Kiểm tra mạng bridge để xem B3 đã thực sự kết nối chưa:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;286d5161c9f65235af68d99040f31b167b4bf23f9803fa3a2b3bd7de61b7c81c\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T06:58:33.069522692+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;2f6dd1dda04d0ab42434a6cff6f9c7eb42474f81acdf32809486f8fa82be8951\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B1\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;5ddc6f87b486401bd0e2cfea3e1c8324300f9045712778f1c321e35349c56cff\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:03\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.3/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;f1c96c1089fbe206c52832089be7b18321aeea7abff840f5169d3d171fa5ca1d\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:04\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.4/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;bdd19faad9cfe6ba9f49a532cf245b3a1bec95d8d20688f4c6b52018d45538b2\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B2\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;32f69c565c649791c9f70db3a7a224e6a8d882b41fb9dc7c6477d4f33b9ec32b\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ]   Trong trường container đã có thêm container B3, và kiểm tra network mynetwork thì thấy B3 vẫn đang kết nối tới mynetwork.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  ❯ docker network inspect mynetwork [ { \u0026#34;Name\u0026#34;: \u0026#34;mynetwork\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T07:59:52.392658153+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.20.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.20.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;1b39318c8d5b92261c22321f765945b85231160b53a9a3933b5fe120db80e7c2\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B4\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;5f26179cc819ffe9f6089c8de41cc236a36ce90c5ac646041d99de7d4a54d3e5\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:03\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.3/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;d8f6cf60953a1ebd7c1a84a95e5503bc726a5e77df2c939e8072fe6ca7406d65\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: {}, \u0026#34;Labels\u0026#34;: {} } ]   Lúc này, B3 có thể kết nối tới B2 và B1 và ngược lại.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  ❯ docker attach B1 / # ping 173.20.0.2 PING 173.20.0.2 (173.20.0.2): 56 data bytes 64 bytes from 173.20.0.2: seq=0 ttl=49 time=325.730 ms 64 bytes from 173.20.0.2: seq=1 ttl=49 time=297.840 ms 64 bytes from 173.20.0.2: seq=2 ttl=49 time=280.704 ms 64 bytes from 173.20.0.2: seq=3 ttl=49 time=328.708 ms 64 bytes from 173.20.0.2: seq=4 ttl=49 time=274.586 ms 64 bytes from 173.20.0.2: seq=5 ttl=49 time=295.232 ms 64 bytes from 173.20.0.2: seq=6 ttl=49 time=274.058 ms ^C --- 173.20.0.2 ping statistics --- 8 packets transmitted, 7 packets received, 12% packet loss round-trip min/avg/max = 274.058/296.694/328.708 ms   Một lưu ý là khi B3 và B4 cùng kết nối với nhau qua một mạng, bên cạnh kết nối với nhau qua địa chỉ thì chúng có thể kết nối với nhau qua tên.\n1 2 3 4 5 6 7 8 9 10 11  ❯ docker attach B3 / # ping B4 PING B4 (172.20.0.3): 56 data bytes 64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.283 ms 64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.194 ms 64 bytes from 172.20.0.3: seq=2 ttl=64 time=0.164 ms 64 bytes from 172.20.0.3: seq=3 ttl=64 time=0.191 ms ^C --- B4 ping statistics --- 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 0.164/0.208/0.283 ms   Tuy nhiên B1, B2 cũng kết nối với nhau chung 1 mạng mà chúng không thể giao tiếp với nhau qua tên. Có thể do mạng của chúng cùng kết nối là mạng mặc định (bridge).\n1 2 3  ❯ docker attach B1 / # ping B2 ping: bad address \u0026#39;B2\u0026#39;   Xóa mạng Khi không có nhu cầu sử dụng network nữa, chúng ta có thể xóa chúng đi với cú pháp:\ndocker network rm \u0026lt;ten_network\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 2f8c72e77060 mynetwork bridge local 258acbefb858 network1 bridge local 271997adaaa9 none null local ❯ docker network rm network1 network1 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 2f8c72e77060 mynetwork bridge local 271997adaaa9 none null local   Kết luận Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau:\n Biết về busybox Các lệnh thao tác với docker network: liệt kê, kiểm tra thông tin mạng Mạng bridge, tạo thêm, xóa mạng, ánh xạ cổng mạng trong docker.  Kết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này.\n","description":"Phần này chúng ta sẽ học về : Mạng | Networking trong Docker, tạo và quản lý network trong container Docker ","id":0,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P3)","uri":"https://minhlongmt183.github.io/posts/docker_p3/"},{"content":"Toàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống kiến của các tác giả của những kênh nói trên.❤️❤️❤️  Lệnh Docker exec, lưu container thành image với commit, xuất image ra file Docker exec Thông thường, để thực thi một lệnh trong container, ta sẽ vào container bằng lệnh docker attach \u0026lt;container name or id\u0026gt;. Tuy nhiên, nếu ta đang ở host và vẫn muốn thực thi một lệnh bên trong container đang chạy, ta sẽ dùng lệnh docker exec \u0026lt;container id / name\u0026gt; [COMMAND].\nVí dụ, từ host, ta chạy lệnh ls để liệt kê tất cả các file trong container.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6d1aa3dda644 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 3 minutes ago Up 3 minutes test ❯ docker exec test ls bin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var   Ngoài ra cũng vẫn có thể thêm các option, ví dụ:\n1 2  ❯ docker exec -it test bash root@ubuntu1:/#   Lệnh trên yêu cầu thực thi lệnh bash và thêm option -it để có thể tương tác trực tiếp với terminal, dễ dàng thấy, nó khá giống với lệnh docker attach, tuy nhiên, khi mở các process trong container bằng htop, chúng ta sẽ thấy như sau:\nRõ ràng, ở đây có ngoài process /bin/bash có khi tạo, container còn chạy thêm một process bash, process này chính là lệnh mà chúng ta yêu cầu thực thi từ máy host. Sau khi thực hiện lệnh docker exec -it test bash, ta gõ lệnh exit để thoát khỏi container, tuy nhiên, vì container vẫn còn process /bin/bash nên nó vẫn còn hoạt động chứ không bị tắt đi.\nDocker commit Sau khi cài docker và sử dụng, chúng ta có thể phải cài thêm nhiều phần mềm, môi trường khác nhau. Khi đó, để chia sẻ container này đi, ta cần lưu container này thành image. Để làm việc đó, ta sử dụng lệnh container commit.\nTrước khi lưu container trở thành image, ta kiểm tra xem trong hệ thống có những image nào:\n1 2 3 4  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB   Một điều lưu ý, muốn lưu container thành image, thì container đó phải ở trạng thái dừng (Exited).\n1 2 3 4  ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6d1aa3dda644 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 23 minutes ago Exited (0) 4 minutes ago test ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 16 hours ago Exited (0) 16 hours ago centos_docker   Tiến hành lưu container thành images, ta dùng cú pháp: docker commit CONTAINER image:tag. CONTAINER ở đây là tên hoặc id của container.\nVí dụ, container ubuntu vừa rồi tôi đã cài thêm ping với vim, bây giờ lưu lại thành image, ta thực hiện:\n1 2 3 4 5 6 7  ❯ docker commit test ubuntu-pv:version1 sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 5 seconds ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB   Rõ ràng, sau khi thực hiện lệnh trên, chúng ta sẽ thấy trong danh sách các images có thểm một image có thên là ubuntu-py với TAG là version1 cùng ID và các thông tin khác.\nDocker save Sau khi ta lưu container thành một image, để có thể chia sẻ image này với người khác, ta lưu image thành một file trên máy host. Việc này sẽ được thực hiện thông qua lệnh docker save --output filename.tar \u0026lt;image_id/name\u0026gt;.\n1 2 3 4 5 6 7 8 9 10  ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 6 minutes ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker save --output ubuntu-pv.tar a8 ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ubuntu-pv.tar   Ví dụ trên tôi đã lưu ubuntu-pv image thành ra file ubuntu-pv.tar.\nDocker load Sau khi nhận được file image.tar, để phục hồi hoặc sử dụng lại, ta sử dụng lệnh docker load -i image.tar\nVí dụ, tôi tiến hành xóa đi ubuntu-pv image hiện có trên hệ thống. Lệnh thao tác với image bạn có thể xem ở P1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 11 minutes ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker image rm -f ubuntu-pv:version1 Untagged: ubuntu-pv:version1 Deleted: sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker image rm ubuntu:latest Untagged: ubuntu:latest Untagged: ubuntu@sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Deleted: sha256:7e0aa2d69a153215c790488ed1fcec162015e973e49962d438e18249d16fa9bd ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 300e315adb2f 6 months ago 209MB   Bây giờ, ta tiến hành phục hồi ubuntu-pv image từ file ubuntu-pv.tar đã có ở trước đó.\n1 2 3 4 5 6 7 8  ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ubuntu-pv.tar ❯ docker load -i ubuntu-pv.tar Loaded image ID: sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; a8e04dcf8737 14 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB   Khi phục hồi, tên của image và tag của nó sẽ là \u0026lt;none\u0026gt;. Để đặt tên và tag, ta dùng lệnh:\ndocker tag image_id name:tag.\n❯ docker tag a8 newimage:version2 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 16 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB Chia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume Chia sẻ dữ liệu giữa máy host và container Trên máy host, tôi tổ chức cây thực mục như sau:\n1 2 3 4 5  . ├── docker │ └── data │ └── d.txt   Mục tiêu của chúng ta là để container có thể truy cập và thao tác với dữ liệu ở trong data, và khi container bị xóa đi, dữ liệu không bị mất.\nChúng ta tạo mới một container và trong lúc tạo sẽ chỉ rõ thực mục ánh xạ trên host và thực mục được ánh xạ ở đâu trên container.\ndocker run -it -v \u0026lt;thu/muc/tren/host\u0026gt;:\u0026lt;thu/muc/anh/xa/tren/container\u0026gt; \u0026lt;image id\u0026gt;\n1 2 3 4 5 6  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 28 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v /home/edisc/Desktop/docker/data:/home/shared_data a8 root@d4d24f24bbe6:/#   Chúng ta tiến hành kiểm tra:\n1 2 3 4  root@d4d24f24bbe6:/# cd /home/shared_data/ root@d4d24f24bbe6:/home/shared_data# ls d.txt root@d4d24f24bbe6:/home/shared_data#   Như vậy, dữ liệu đã được ánh xạ và mọi thao tác trên dữ liệu ở thư mục này sẽ được lưu vào host.\nChia sẻ dữ liệu giữa các container với nhau Chúng ta tạo lại một container có tên là container1 ánh xạ tới dữ liệu Desktop/docker/data, và tạo một container2 muốn ánh xạ tới dự liệu này, thay vì dùng lệnh tạo như container1, ta có thể dùng --volumes-from \u0026lt;container_name/id\u0026gt;\n1 2 3 4 5 6 7 8  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 36 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v /home/edisc/Desktop/docker/data:/home/shared_data --name \u0026#34;container1\u0026#34; a8 root@b62e5d395369:/# % ❯ docker run -it --name container2 --volumes-from container1 centos [root@e1103acb0525 /]#   Chia sẻ qua volume Bên cạnh việc chia sẻ dữ liệu bằng cách tạo các file dữ liệu, docker còn cho phép chúng ta tạo ra những ổ đĩa, gán vào container và để chia sẻ dữ liệu giữa chúng. Cũng như file, khi container xóa thì những ổ đĩa này vẫn còn tồn tại cho đến khi chúng ta cố tình xóa nó.\nKiểm tra các ổ đĩa hiện có Để kiểm tra các ổ đĩa hiện có, ta dùng lệnh:\n1 2  ❯ docker volume ls DRIVER VOLUME NAME   Hiện tại trên hệ thống không có ổ đĩa nào.\nTạo ổ đĩa Để tạo một ổ đĩa mới, ta dùng lệnh: docker volume create NAMEDISK.\n1 2 3 4 5  ❯ docker volume create D1 D1 ❯ docker volume ls DRIVER VOLUME NAME local D1   Kiểm tra thông tin ổ đĩa Để kiểm tra thông tin ổ đĩa ta dùng lệnh docker volume inspect NAMEDISK.\n1 2 3 4 5 6 7 8 9 10 11 12  ❯ docker volume inspect D1 [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2021-06-08T10:06:13+07:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: {}, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/D1/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;D1\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ]   Xóa ổ đĩa Khi không có nhu cầu sử dụng, ta sử dụng lệnh docker volume rm NAMEDISK.\n1 2 3 4 5 6 7 8 9  ❯ docker volume ls DRIVER VOLUME NAME local D1 local D2 ❯ docker volume rm D1 D1 ❯ docker volume ls DRIVER VOLUME NAME local D2   Gán ổ đĩa volume vào container Ta sử dụng cú pháp:\ndocker run -it --mount source=DISK,target=pathContainer imageID\n1 2 3 4 5 6 7 8  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it --mount source=D2,target=/home/disk2 ubuntu:latest root@524a1182f690:/# cd /home/disk2/ root@524a1182f690:/home/disk2#   Ta tiến hành thêm dữ liệu trong thư mục trên, sau đó xóa container đi, và thấy, ổ đĩa vẫn còn.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it --mount source=D2,target=/home/disk2 ubuntu:latest root@524a1182f690:/# cd /home/disk2/ root@524a1182f690:/home/disk2# ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 524a1182f690 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About a minute ago Exited (0) 23 seconds ago cocky_mclaren e1103acb0525 centos \u0026#34;/bin/bash\u0026#34; 19 minutes ago Exited (127) 11 minutes ago container2 b62e5d395369 a8 \u0026#34;/bin/bash\u0026#34; 21 minutes ago Exited (0) 11 minutes ago container1 ❯ docker rm 52 52 ❯ docker volume ls DRIVER VOLUME NAME local D2   Vậy làm sao để truy xuất dữ liệu hiện có trên D2 hoặc kiểm tra xem có dữ liệu trên đó hay không? Để làm được điều đó, chúng ta tạo một container khác, mount tới D2 và kiểm tra.\n1 2 3 4 5  ❯ docker run -it --mount source=D2,target=/home/disk3 ubuntu:latest root@ca47e1855144:/# cd /home/disk3/ root@ca47e1855144:/home/disk3# ls data.txt root@ca47e1855144:/home/disk3#   Dữ liệu do container trước đã tạo và lưu vào, dữ liệu này vẫn còn mặc dù container đã xóa đi.\nTạo ổ đĩa ánh xạ tới thư mục trên máy host. Cú pháp:\ndocker create --opt device =pathHOST --opt type=noe --opt o=bind DISKNAME\n1 2 3 4 5 6  ❯ docker volume create --opt device=/home/edisc/Desktop/docker/data --opt type=none --opt o=bind DISK1 DISK1 ❯ docker volume ls DRIVER VOLUME NAME local D2 local DISK1   Thông tin ổ đĩa có được như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  ❯ docker volume inspect DISK1 [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2021-06-08T10:27:56+07:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: {}, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/DISK1/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;DISK1\u0026#34;, \u0026#34;Options\u0026#34;: { \u0026#34;device\u0026#34;: \u0026#34;/home/edisc/Desktop/docker/data\u0026#34;, \u0026#34;o\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ]   Để chạy container với tham số này ta không sử dụng tùy chọn --mount mà ta sẽ sủ dụng tùy chọn -v.\n1 2 3 4 5 6 7 8 9 10  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v DISK1:/home/disk4 ubuntu:latest root@e94027a36d5b:/# cd /home/disk4/ root@e94027a36d5b:/home/disk4# ls c1.txt d.txt data_container2.txt root@e94027a36d5b:/home/disk4#   Vào thư mục và kiểm tra, ta vẫn thấy nó có các dữ liệu ở trên máy host. Và khi thao tác dữ liệu trên này, dữ liệu trên máy host cũng sẽ được cập nhât.\nKết luận Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau: Các lệnh Docker exec, lưu container thành image với commit, xuất image ra file:\n docker exec: thực thi một lệnh bên trong container đang chạy từ host. docker commit: lưu container thành image docker save: lưu image thành file. docker load: chuyển file thành image.\nChia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume: Chia sẻ dữ liệu qua tệp:  Container với host Giữa container với nhau.   Chia sẻ dữ liệu qua ổ đĩa disk: các thao tác với volume thông qua lệnh docker volume kèm các option tương ứng.\nKết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này.  ","description":"Phần này chúng ta sẽ tìm hiểu lệnh Docker exec, lưu container thành image với commit, xuất image ra file; Chia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume ","id":1,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P2)","uri":"https://minhlongmt183.github.io/posts/docker_p2/"},{"content":"Toàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống kiến của các tác giả của những kênh nói trên.❤️❤️❤️  Làm quen với docker command line Khi làm việc với docker, lệnh chúng ta hay dùng đó chính là docker. Sau lệnh docker sẽ có nhiều lệnh nhỏ, để xem danh sách các lệnh nhỏ này, ta gõ\n1  $ docker   1  $ docker run -d -p 80:80 docker/getting-started   Trong đó:\n -d: chạy container ở chế độ detached mode (ở background) -p 80:80: ánh xạ cổng 80 của host vào cổng 80 của container. docker/getting-started: image sử dụng  Docker images Liệt kê các images 1 2 3 4 5 6  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB   Ở đây,\n REPOSITORY là tên của image, TAG là phiên bản của image, IMAGE ID là một mã hash của image, CREATED là thời gian được tạo của image, SIZE là kích thước của image.\nCác images này lấy từ hub.docker.com. Chúng ta vào hub.docker.com để tìm kiếm image thích hợp mà mình muốn tải. Lưu ý nếu lần đầu bạn vào trang này, bạn cần đăng kí một tài khoản. Ngoài ra, ta có thể tìm kiếm trực tiếp trên terminal với lệnh:  1  docker search \u0026lt;keyword\u0026gt;   Ví dụ, ta muốn tìm kiếm các images của ubuntu\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  ❯ docker search ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating sys… 12337 [OK] dorowu/ubuntu-desktop-lxde-vnc Docker image to provide HTML5 VNC interface … 539 [OK] websphere-liberty WebSphere Liberty multi-architecture images … 273 [OK] rastasheep/ubuntu-sshd Dockerized SSH service, built on top of offi… 253 [OK] consol/ubuntu-xfce-vnc Ubuntu container with \u0026#34;headless\u0026#34; VNC session… 241 [OK] ubuntu-upstart Upstart is an event-based replacement for th… 110 [OK] 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 50 [OK] open-liberty Open Liberty multi-architecture images based… 46 [OK] ubuntu-debootstrap debootstrap --variant=minbase --components=m… 44 [OK] i386/ubuntu Ubuntu is a Debian-based Linux operating sys… 25 nuagebec/ubuntu Simple always updated Ubuntu docker images w… 24 [OK] solita/ubuntu-systemd Ubuntu + systemd 24 [OK] 1and1internet/ubuntu-16-apache-php-5.6 ubuntu-16-apache-php-5.6 14 [OK] 1and1internet/ubuntu-16-apache-php-7.0 ubuntu-16-apache-php-7.0 13 [OK] 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10 ubuntu-16-nginx-php-phpmyadmin-mariadb-10 11 [OK] 1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4 ubuntu-16-nginx-php-5.6-wordpress-4 9 [OK] 1and1internet/ubuntu-16-nginx-php-5.6 ubuntu-16-nginx-php-5.6 8 [OK] 1and1internet/ubuntu-16-apache-php-7.1 ubuntu-16-apache-php-7.1 7 [OK] 1and1internet/ubuntu-16-nginx-php-7.0 ubuntu-16-nginx-php-7.0 4 [OK] pivotaldata/ubuntu A quick freshening-up of the base Ubuntu doc… 4 pivotaldata/ubuntu16.04-build Ubuntu 16.04 image for GPDB compilation 2 pivotaldata/ubuntu-gpdb-dev Ubuntu images for GPDB development 1 smartentry/ubuntu ubuntu with smartentry 1 [OK] 1and1internet/ubuntu-16-sshd ubuntu-16-sshd 1 [OK] 1and1internet/ubuntu-16-php-7.1 ubuntu-16-php-7.1 1 [OK]   Mục OFFICIAL cho biết phiên bản này là chính chủ. Để sử dụng một image nào đó, chúng ta cần đọc thông tin của image trên hub.docker và các phiển bản của image nằm ở phần tag.\nTải image Để tải image, ta sử dụng:\n1  docker pull image:tag   Ở đây, tag là phiên bản mà chúng ta muốn sử dụng. Nếu chúng ta muốn tải bản ubuntu 20.04 thì câu lệnh sẽ là:\n1 2 3 4  ❯ docker pull ubuntu:20.04 20.04: Pulling from library/ubuntu Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Status: Downloaded newer image for ubuntu:20.04   Chúng ta kiểm tra lại để xác nhận docker đã được tải bằng lệnh docker images\n1 2 3 4 5 6 7  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu 20.04 7e0aa2d69a15 6 weeks ago 72.7MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB   Khi chúng ta không để tag, mặc định nó xem như tag này là latest và sẽ tải bản mới nhất về, và khi chúng ta in ra các images, những images này sẽ có tag là latest.\n1 2 3 4 5 6  ❯ docker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest   Xóa Image Để xóa một image không sử dụng, chúng ta dùng câu lệnh:\n1  docker image rm \u0026lt;ten_image_muon_xoa:tag\u0026gt;   Ví dụ, tôi muốn xóa image ubuntu:20.04, ta làm như sau:\n1 2  ❯ docker image rm ubuntu:20.04 Untagged: ubuntu:20.04   Kết quả sau khi xóa:\n1 2 3 4 5 6  ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB   Ngoài ra, chúng ta còn có thể xóa bằng cách dùng IMAGE ID, ví dụ, ta muốn xóa image hello-world,\n1 2 3 4 5 6 7 8 9 10  ❯ docker image rm d1165f221234 Untagged: hello-world:latest Untagged: hello-world@sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726 Deleted: sha256:f22b99068db93900abe17f7f5e09ec775c2826ecfe9db961fea68293744144bd ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB   Docker version Usage 1  $ docker version [OPTIONS]   Get the server version 1  $ docker version --format \u0026#39;{{.Server.Version}}\u0026#39;   Dump raw JSON data 1  $ docker version --format \u0026#39;{{json .}}\u0026#39;   Print the current context 1  $ docker version --format=\u0026#39;{{.Client.Context}}\u0026#39;   Docker run Image sẽ đươc chạy trong các container, để chạy ta thực hiện câu lệnh:\n Usage:  1  $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]    Có rất nhiều tham số, các bạn có thể đọc ở đây  Ví dụ: Chạy một image 1  docker run -it \u0026lt;ten_image/image_id\u0026gt;   Ở đây, -it là viết gọn của 2 options: -i (interactive) và -t (terminal) chỉ định tạo ra container và có thể tương tác với nó trực tiếp trên terminal. Giả sử ta chạy image ubuntu:latest.\n1 2  ❯ docker run -it ubuntu:latest root@b2d8e983bcef:/#   Vậy là chúng ta đã chạy image ubuntu:latest và đang ở container ubuntu, tài khoản root với hostname là b2d8e983bcef. Chúng ta kiểm tra thông tin của ubuntu này.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  root@ff7140c65b73:/# cat /etc/*release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION=\u0026#34;Ubuntu 20.04.2 LTS\u0026#34; NAME=\u0026#34;Ubuntu\u0026#34; VERSION=\u0026#34;20.04.2 LTS (Focal Fossa)\u0026#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=\u0026#34;Ubuntu 20.04.2 LTS\u0026#34; VERSION_ID=\u0026#34;20.04\u0026#34; HOME_URL=\u0026#34;https://www.ubuntu.com/\u0026#34; SUPPORT_URL=\u0026#34;https://help.ubuntu.com/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.launchpad.net/ubuntu/\u0026#34; PRIVACY_POLICY_URL=\u0026#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\u0026#34; VERSION_CODENAME=focal UBUNTU_CODENAME=focal root@ff7140c65b73:/#   Để kiểm tra có những container nào đang chạy trên máy, chúng ta dùng lệnh:\n1 2 3  ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 2 minutes ago Up 2 minutes unruffled_goldberg   Kết quả trên cho thấy, hệ thống đang chạy một container có id là ff7140c65b73 và chạy từ image ubuntu:latest, với command /bin/bash.\nKhi chúng ta gõ lệnh exit để thoát khỏi container, lệnh docker ps sẽ không hiển thị container nào, tuy nhiên, lệnh docker ps -a sẽ liệt kê tất cả các container đang hiện có trên máy kèm theo trạng thái của nó.\n1 2 3 4  ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 9 minutes ago Exited (0) 5 seconds ago unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; 11 minutes ago Exited (0) 11 minutes ago gallant_snyder   Trạng thái Exited thể hiện container đã bị dừng, và để khởi động lại docker đã dừng, ta dùng lệnh docker start\n1 2 3 4 5 6 7 8 9  ❯ docker start ff7140c65b73 ff7140c65b73 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 12 minutes ago Up 6 seconds unruffled_goldberg ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 12 minutes ago Up 11 seconds unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; 14 minutes ago Exited (0) 14 minutes ago gallant_snyder   Để vào lại hệ điều hành trong container, ta dùng lệnh docker attach container_id, lưu ý, id chúng ta không cần ghi hết, chỉ cần ghi 2-3 chữ cái đầu là được.\n1 2  ❯ docker attach ff root@ff7140c65b73:/#   Để thoát khỏi container mà không dừng nó, ta dùng tổ hợp phím ctrl + P, ctrl + Q. Khi chúng ta dùng tổ hợp này, ta sẽ có kết quả sau:\n1 2  ❯ docker attach ff root@ff7140c65b73:/# read escape sequence   Từ máy host, để dừng container, ta dùng lệnh docker stop \u0026lt;container_name/container_id\u0026gt;\n1 2 3 4 5 6 7  ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 26 minutes ago Up 14 minutes unruffled_goldberg ❯ docker stop unruffled_goldberg unruffled_goldberg ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES   Đặt tên cho container 1 2  ❯ docker run -it --name \u0026#34;centos_docker\u0026#34; -h centos1 centos:latest [root@centos1 /]#    Ví dụ trên chạy container có tên là centos_docker sử dụng image centos:latest.\n -it tạo một tương tác bash shell trong container. --name: đặt tên cho container. -h: đặt hostname cho container.\nChúng ta có thể kiểm tra  1 2 3  ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 2 minutes ago Up 3 seconds centos_docker   Capture container ID (\u0026ndash;cidfile) 1 2 3 4 5 6 7 8 9  ❯ docker run --cidfile /tmp/docker_test.cid ubuntu echo \u0026#34;test\u0026#34; Unable to find image \u0026#39;ubuntu:latest\u0026#39; locally latest: Pulling from library/ubuntu 345e3491a907: Pull complete 57671312ef6f: Pull complete 5e9250ddb7d0: Pull complete Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Status: Downloaded newer image for ubuntu:latest test    Lệnh này tạo container và in test ra màn hình console. Flag cidfile yêu cầu Docker tạo một file mới và\nviết container ID vào nó. Nếu file đã tồn tại, Docker sẽ trả về error. Docker sẽ đóng file khi docker run kết thúc.  Full container capabilities (\u0026ndash;privileged) 1 2 3 4  ❯ docker run -t -i --rm ubuntu bash root@bd1340e91d1e:/# mount -t tmpfs none /mnt mount: /mnt: permission denied. root@bd1340e91d1e:/#    --rm tự động xóa container nếu như nó đã tồn tại. Lệnh này không hoạt động, vì theo mặc định, những câu lệnh đem lại khả năng nguy hiểm tới kernel sẽ bị loại bỏ, bao gồm cap_sys_admin (lệnh yêu cầu mount filesystems). Tuy nhiên, flag --privileged sẽ cho phép chúng ta run:  1 2 3 4 5 6 7 8 9 10 11  ❯ docker run -t -i --privileged ubuntu bash root@a3c5921afbbc:/# mount -t tmpfs none /mnt root@a3c5921afbbc:/# df -h Filesystem Size Used Avail Use% Mounted on overlay 110G 58G 46G 56% / tmpfs 64M 0 64M 0% /dev tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup /dev/sda2 110G 58G 46G 56% /etc/hosts shm 64M 0 64M 0% /dev/shm none 3.9G 0 3.9G 0% /mnt root@a3c5921afbbc:/#    flag --privileged sẽ cấp hết tất cả capabilities cho container, và loại bỏ mọi giới hạn được đặt ra bởi cgroup controller. Nói cách khác, container có thể chạy hầu hết mọi thứ mà máy host có thể làm.  Set working directory (-w) 1  $ docker run -w /path/to/dir/ -i -t ubuntu pwd    -w cho phép câu lệnh thực thi bên trong thư mục đã chỉ định. Nếu đường dẫn tới thư mục không tồn tại,\nnó sẽ tạo một thư mục mới trong container tương ứng đường dẫn đó.  Set storage driver options per container 1  $ docker run -it --storage-opt size=120G fedora /bin/bash     size cho phép chúng ta thiết lập container rootfs size tới 120G tại thời điểm tạo.\nOption này chỉ hiệu quả cho devicemapper, btrfs, overlay2, windowsfilter và zfs graph drives\n  Với devicemapper, btrfs, windowsfilter and zfs graph drivers user không thể gán kích thước\nnhỏ hơn Default BasFS Size\n  Với overlay2 storage drive, size option chỉ hoạt động nếu trình fs được gán là xfs\nvà mounted với option pquota. trường hợp này, người dùng có thể cấp size.\n  Mount tmpfs (\u0026ndash;tmpfs) 1  $ docker run -d --tmpfs /run:rw,noexec,nosuid,size=65536k my_image   flag --tmpfs mount một empty tmpfs vào container với rw, noexec, nosuid, size=65536k\nMount volume (-v, \u0026ndash;read-only) 1  $ docker run -v `pwd`:`pwd` -w `pwd` -i -t ubuntu pwd    -v mount thư mục hiện tại vào container -w cho phép command được thực thi bên trong thư mục hiện tại bằng cách thay đổi trong thư mục\nthành giá trị được trả về bởi pwd. Nó sẽ thực thi kết hợp câu lệnh sử dụng container,\nnhưng bên trong thư mục hiện tại:  1  $ docker run -v /doesnt/exist:/foo -w /foo -i -t ubuntu bash   Khi host directory của bind-mounted volume không tồn tại, Docker sẽ tự động tạo thư mục này trên host cho bạn.\nTrong ví dụ trên, Docker sẽ tạo thư mục /doesnt/exist trước khi chạy container.\n1  $ docker run --read-only -v /icanwrite busybox touch /icanwrite/here    --read-only để kiểm soát nơi container viết file, --read-only flag mount container\u0026rsquo;s root filesystem chỉ để đọc.  1  $ docker run -t -i -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/static-docker-binary:/usr/bin/docker busybox sh   Bằng cách liên kết docker unix socket với docker binary liên kết tĩnh, chúng ta cấp container toàn quyền truy cập\nvà chỉnh sửa host\u0026rsquo;s Docker daemon.\nAdd bind mounts or volumes using the \u0026ndash;mount flag  Ví dụ:  1  $ docker run --read-only --mount type=volume,target=/icanwrite busybox touch /icanwrite/here   1  $ docker run -t -i --mount type=bind,src=/data,dst=/data busybox sh   Publish or expose port (-p, \u0026ndash;expose) 1  $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash     Câu lệnh kết nối cổng 8080 của container tới cồng 80 TCP trên 127.0.0.1 của host machine.\nChúng ta có thể chỉ định udp và sctp ports.\n  Có một lưu ý, những port không ràng buộc bởi host sẽ có thể được truy cập từ bên ngoài.\nĐiều này cũng áp dụng nếu chúng ta muốn cấu hình UFW để chặn công cụ này, vì Docker quản lý các quy tác iptables\ncủa riêng mình.\n  1  $ docker run --expose 80 ubuntu bash   Hiển thị cổng 80 của container mà không có xuất hiện port trên host system.\nSet environment variables (-e, \u0026ndash;env, \u0026ndash;env-file) 1  docker run -e MYVAR1 --env MYVAR2=foo --env-file ./env.list ubuntu bash    Sử dụng những flag -e, --env, --env-file để thiết lập những biến môi trường (không phải dạng array)\ncho container bạn đang chạy, hoặc ghi đè những file đó có sẵn.  ví dụ:\n1 2 3  ❯ docker run --env VAR1=value1 --env VAR2=value2 ubuntu env | grep VAR VAR2=value2 VAR1=value1   Connect a container to a network (\u0026ndash;network) 1  $ docker run -itd --network=my-net busybox   Chúng ta có thể chọn địa chỉ IP cho container với flag --ip hoặc --ip6 khi bạn chạy container\ntrên user-defined network\n1  $ docker run -itd --network=my-net --ip=10.10.9.75 busybox   Docker rm Để xóa container khi nó đang dừng, ta dùng lệnh docker rm container_id\n1 2 3 4 5 6 7 8 9 10 11  ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 9 minutes ago Exited (0) 7 minutes ago centos_docker ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) 45 minutes ago unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) About an hour ago gallant_snyder ❯ docker rm b2 b2 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 10 minutes ago Exited (0) 7 minutes ago centos_docker ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) 45 minutes ago unruffled_goldberg   Trường hợp container đang chạy mà ta muốn xóa thì ta thêm options -f\n1  docker rm -f container_id/container_name   Tổng kết Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau:\n docker images:  Liệt kê danh sách tất cả các images trên docker docker pull image:tag tải image về máy docker image rm image_name/image_id xóa image docker version: xem version của docker docker run -it --name \u0026quot;ten_container\u0026quot; -h \u0026quot;host_name\u0026quot; image: tạo container. ctrl + P, ctrl + Q: thoát khỏi container nhưng vẫn để container chạy. docker ps: in ra container chạy docker stop container_id/name: buộc container đang chạy dừng khi ta đang ở host. docker attach container_id/name: trở lại container đang chạy. docker rm containerid/name: xóa container đã dừng. docker rm -f containerid/name: xóa container đang chạy.\nKết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này.  ","description":"Bài này chúng ta sẽ học làm quen với docker command line, một số câu lệnh thông dụng như docker images, docker version, docker run, docker rm","id":2,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P1)","uri":"https://minhlongmt183.github.io/posts/docker_p1/"},{"content":"Nguồn tham khảo\nWhat is Packing? Packing có nghĩa là nén (compressed), hoặc xáo trộn (obfuscated) file thực thi để làm cho file thực thi khó phát hiện, khó phân tích tĩnh, khó dịch ngược. Trong ngữ cảnh của malware, vì mã độc chủ yếu được compressed, obfuscated trong các mẫu đóng gói, các công cụ dùng để phân tích tĩnh sẽ gặp vấn đề khi xác định liệu tệp nhị phân này có phải là mã độc hay không. Bên cạnh nó, một thuật toán packing tốt sẽ làm khó khăn qúa trình phân tích của các nhà phân tích mã độc, từ đó giúp cho vòng đời của mã độc được kéo dài lâu hơn.\nMột cách nôm na, chúng ta có thể hiểu packer gồm: compressing packers và encrypting packers. Trong đó compressing packers mục đích là đưa file thực thi về dạng nén, làm giảm kích thước của file, còn encrypting packers có mục đích mã hóa hoặc xáo trộn file đã được nén, nhằm ngăn chặn người dùng dịch ngược. Như đã nói, cách hiểu trên chỉ là hiểu một cách nôm na, bởi vì có nhiều packer kết hợp cả hai tính chất trên, còn có nhưng packer (như UPX), nó chỉ compressing mà không có encrypting.\nHow does packing work? Chúng ta sẽ nói về kiến trúc \u0026ldquo;stub-payload\u0026rdquo;, một trong những cơ chế được sử dụng nhiều bởi packer, kể cả UPX.\nTrong kiến trúc \u0026ldquo;stub-payload\u0026rdquo;, một file thực thi sẽ gồn hai thành phần chính: nội dung đã được nén / mã hóa từ file gốc và một đoạn mã dùng để giải nén / giải mã file này về file gốc và thực thi nó. Đoạn mã này được gọi là stub. Về bản chất, file ban đầu được nến / mã hóa, sau đó được bọc trong tệp thực thi mới có chứa mã để đưa nó về trạng thái ban đầu\nIndication of Packing Lacking of Import in Import Address Table (IAT) Để một file thực thi có thể tương tác với hệ điều hành thì file thực thi cần phải có các hàm được tích hợp vào thư viện hệ thống như kernel32.dll và user32.dll. Khi phân tích một tệp tin đã được giải nén hoàn toàn, ta sẽ thấy một số lượng lớn các import vì mã độc rõ ràng muốn tương tác khá nhiều với hệ điều hành. Tuy nhiên, một stub của một chương trình bị packed không có nhiều chức năng ngoài việc giải nén và thực thi file gốc, do đó, nó sẽ có số lượng import ít hơn rất nhiều so với file chuẩn.\nNon-standard Section Names: Trong những file thực thi bình thường, chúng thường có các sections giống nhau mọi lúc (.text, .data, .rsrc,..). Tuy nhiên, những paker sẽ tự định nghĩa section cho riêng nó, điều này cũng cho thấy những file có section như vậy sẽ không phải là tiêu chuẩn và có thể được đóng gói. Ví dụ như UPX packer sẽ thực thi với các file có tên section là UPX0 và UPX1.\nSections with a small raw size but a large virtual size Khi chúng ta gặp một file mà có raw size rất nhỏ (đôi khi bằng 0), điều này muốn nói file thực thi không có bất kì dữ liệu nào trong section. Tuy nhiên, khi file thực thi được load vào bộ nhớ, raw size không còn liên quan, và nó được thay bởi virtual size của từng phần cụ thể được cấp phát trong memory. Nếu một file có section được cấp phát với virtual space lớn và raw data rất nhỏ, nó có khả năng cao là những đoạn code dùng để unpacked.\nSections with very high entropy: Từ entroy đề cập đến phương sai và tính ngẫu nhiên của một phần dữ liệu. Những thứ như ngôn ngữ Tiếng Anh, assembly code, các cấu trúc giao tiếp được xác định rõ ràng khác thường có entropy thấp vì ngôn ngữ có xu hướng tuần theo các mẫu có thể đoán trước được. Tuy nhiên, encrypted data và compressed data không có khả năng dự đoán trước, do đó có entropy cao hơn nhiều. Do đó, khi kiểm tra nếu thấy có entropy cao thì khả năng dữ liệu này đã được nén hoặc mã hóa.\nLow number of discernible strings: Trong file không bị nén, chúng ta sẽ nhận thấy có một lượng nhất định các chuỗi có thể đọc được vì hầu hết các ứng dụng (kể cả malware) sử dụng những protocol được hiện thực bởi ngôn ngữ con người. Do đó, trong một file bình thường, những chuỗi này nên xuất hiện, và khi thấy những chuỗi có thể đọc được ở một file quá ít hoặc không có, khả năng cao file này đã bị nén hoặc bị mã hóa.\nSections with RWX privileges: Trong các file bình thường, một section sẽ rất ít khi được cho phép cả đọc và ghi, vì chúng ta hiếm khi muốn viết đè file thực thi trong ứng dụng của mình. Ngoài ra, hiếm khi viết trực tiếp vào file thực thi trong lúc nó đang chạy. Do đó, không có lý do nào để section được cấp quyền vừa ghi và vừa đọc ngoại trừ packer. Với packer, dữ liệu sau khi giải nén sẽ được ghi vào section rồi thực thi.\njmp or call Instructions to registers/strange memory addresses: Trên nhiều packers, địa chỉ tới nơi dữ liệu đã được giải nén thường được lưu trên các thanh ghi và địa chỉ đó thường nằm trong một section khác, do dó chúng ta sẽ thấy bước này nhảy rất xa. Các bước nhảy xa như thế thường không phổ biến, vì tất cả các mã thực thi trong hệ nhị phân thường được chứa trong một section duy nhất. Nếu chúng ta thấy một lệnh jump / call đến một địa chỉ mà:\n1. Không có trong section hiện tại\n2. Không có trong không gian địa chỉ của một thư viện đã tải.\nthì khả năng cao bước nhảy này là bước giải nén.\nNhận diện với file được mã hóa bằng UPX Các bước giúp chúng ta nhận diện và giải nén file bị mã hóa bằng UPX:\n Kiểm tra PE header và xác định xem chúng có thực sự bị đóng gói không. Tuy nhiên bước xác định này chúng ta có thể dùng peid. Tìm nơi giải nén sẽ được ghi. Tìm kiếm lệnh jmp hoặc call tham chiếu đến một thanh ghi hoặc không gian bộ nhớ nơi lưu dữ liệu giải nén có thể được ghi vào trong mã gốc. Đặt breakpoint ở những lệnh này. Dump data chứa trong không gian bộ nhớ đó, sửa import resolutions và xuất nó dưới dạng tệp thực thi mới.  Áp dụng. Ta áp dụng với bài garbage của flareon-2020.\n","description":"Packer là một chương trình dùng để nén và che dấu file thực thi của mình. Nó được sử dụng nhằm giúp các developer giấu đi file thực thi của mình, để làm khó các reverser khiến họ khó khăn trong quá trình bẻ khóa chương trình của mình. Tuy nhiên ứng dụng cũng như kĩ thuật này cũng được sử dụng để tạo ra mã độc, và nó cũng gây ra nhiều khó khăn cho các nhà phân tích mã độc trong quá trình nghiên cứu.","id":3,"section":"posts","tags":["Malware, flareon"],"title":"Manually Unpacking UPX Executables (vẫn đang update...)","uri":"https://minhlongmt183.github.io/posts/packet/"},{"content":"Container Basics Chúng ta sẽ đi qua một số khái niệm cơ bản và cần thiết trong docker:\nCredentials Credentials describe the user identity of a task, which determine its permission for shared resources such as files, semaphores, and shared memory.\nCapabilities Since kernel 2.2, Linux divides the privileges associated with superuser into distinct unit known as capabilities\n/proc/$PID/status | man capabilities Filesystem The container\u0026rsquo;s root mount is often planted in a container-specialized filesystem, such as OverlayFS\n/var/lib/docker/overlay2/..hash../diff Namespaces  Mục đích: làm cho hệ thống container có thể sử dụng và an toàn. PID: have their own view of tasks - cung cấp cây không gian tên của process id. Nó cho phép mỗi container có một cây đầy đủ các process id riêng biệt, trong đó init process có pid = 1. Process chạy trên host sẽ có pid khác với khi chạy trên container. User: wrap mapping of UID to user - cung cấp phiên bản namespace của User IDs (UIDs) and Group IDs (GIDs). Đây là một trong những tính năng quan trọng nhất của hệ thống container hiện đại vì nó được sử dụng để cung cấp \u0026ldquo;unprivileged containers\u0026rdquo;. User namespaces cung cấp một trong những nền tản cho hệ thống container trên Linux hiện nay, và là vùng cấu hình duy nhất được LXC coi là an toàn. Mount: isolate mount points - cung cấp chế độ xem không gian tên của các điểm kết nối (mount points). Kết hợp với pivot_root syscall, tính năng này sẽ cô lập container\u0026rsquo;s filesystem với host\u0026rsquo;s filesystem. Network: cung cấp không gian tên và ngăn xếp mạng riêng biệt. Hầu hết các trường hợp sử dụng của container liên quan tới dịch vụ mạng, vì vậy nó được coi là tính năng lõi của container. UTS: have their own hostname - cung cấp namespaced version của định danh hệ thống (system identifies) IPC: restrict SysV IPC objects Cgroup: isolate the view of cgroups  /proc/$PID/ns/ Cgroups CGroups: cung cấp giao diện phân cấp để quản lí cũng như đo lường tài nguyên và quyền truy cập của thiết bị. Cgroups có thể được sử dụng bởi các process có quyền hạn cao (higher privileged) để đặt giới hạn về sử dụng bộ nhớ, CPU, chặn các thiết bị IO khác. Chúng còn có thể được sử dụng chung với iptables để cung cấp định hình lưu lượng. Quan trong nhất, chúng được sử dụng trong hệ thống container đẻ kiểm soát quyền truy cập của các thiết bị.\nLinux Security Modules - LSMs  AppArmor and SELinux are Linux security modules providing Mandatory Access Control (MAC), where access rules for a program are described by a profile. AppArmor là LSM phổ biến nhất trong hệ thống container, nó có thể giới hạn các hành động mà một chương trình nhất định có thể thực hiện, cũng như thực hiện các hành động phức tạp khi bắt đầu process. Cả LXC và Docker đều thiết lập ở chế độ mặc định để xây dựng những rào cản an ninh, chống lại những mối đe dọa theo chiều sâu. Cho đến nay, AppArmor được ghi nhận là hỗ trợ và ghi nhận tốt nhất.\nDo sự đơn giản của cú pháp AppArmor, nó cũng dễ sử dụng hơn rất nhiều để cấu hình tùy chỉnh cho mỗi vùng chứa. Docker and LXC enable a default LSM profile in enforcement mode, wh mostly serves to restrict a container\u0026rsquo;s\naccess to sensitive /proc and /sys entries. The profile also denies mount syscall.  Tầm quan trọng của Apparmor Mount Options  Chính sách của AppArmor chặn việc truy cập để mounting devpts filesystems. Như comment ở dưới, nếu không có chính sách này, container có thể remount /dev/pts và chiếm quyền truy cập vào các thiết bị đầu cuối của máy chủ.  1 2 3 4  # the container may never be allowed to mount devpts. If it does, it # will remount the host\u0026#39;s devpts. We could allow it to do it with # the newinstance option (but, right now, we don\u0026#39;t). deny mount fstype=devpts    Các chính sách dùng để chặn container cố gắng remount root filesystem. Chính sách này được thực hiện như một biện pháp phòng thủ theo chiều sâu.  1 2 3  # ignore DENIED message on / remount deny mount options=(ro, remount) -\u0026gt; /, deny mount options=(ro, remount, silent) -\u0026gt; /,   Utility Changes   Có rất nhiều \u0026ldquo;nơi nguy hiểm\u0026rdquo; trong /proc và /sys cho phép các container thoát ra ngoài (container escapes).\nTất cả những điều này liên quan tới việc thay đổi vị trí của một tiện ích (chẳng hạn như modprobe) mà máy chủ sẽ gọi khi một sự kiện nhất định xảy ra (ví dụ như yêu cầu load yêu cầu của kernel module).\nBằng cách thay đổi điều này để trỏ đến một chương trình bên trong container của chúng ta, attacker sau đó có thể khiến máy chủ chạy một đoạn mã tùy ý bên ngoài container\n  LXC sử dụng bộ quy tắc sau để chặn các cuộc tấn công này. Lưu ý, nó không phải là một cấu hình cảu AppArmor, nó là đầu vào cho một đoạn lệnh python nhỏ tạo ra một phần dài (long portion) của các quy tắc AppArmor.\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  # Run lxc-generate-aa-rules.py on this file after any modification, to generate # the container-rules file which is appended to container-base.in to create the # final abstractions/container-base. block /sys allow /sys/fs/cgroup/** allow /sys/devices/virtual/net/** allow /sys/class/net/** block /proc/sys allow /proc/sys/kernel/shm* allow /proc/sys/kernel/sem* allow /proc/sys/kernel/msg* allow /proc/sys/kernel/hostname allow /proc/sys/kernel/domainname allow /proc/sys/net/**   Những vector quan trọng nào đang bị chặn?\n  uevent_helper: uevents là những sự kiện được kernel kích hoạt khi một thiết bị thêm vào hoặc xóa đi. Điều đáng chú ý là đường dẫn của \u0026ldquo;uevent_helper\u0026rdquo; có thể được chỉnh sửa bằng cách ghi vào \u0026quot;/sys/kernel/uevent_helper\u0026quot;.\nDo đó, khi một uevent được kích hoạt (cũng có thể được thực hiện từ userland bằng cách ghi vào các tệp như \u0026quot;/sys/class/mem/null/event\u0026quot;), \u0026ldquo;uevent_helper độc hại\u0026rdquo; sẽ được thực thi.\n  modprobe: modprobe là một tiện ích thuộc userland, được kernel gọi khi kernel cần load một kernel module. Vị trí của nó có thể được thay đổi bằng cách sửa đổi \u0026quot;/proc/sys/kernel/modprobe\u0026quot;,\nvà sau đó chúng ta chỉ cần thực hiện một hành động nào đó để kernel tải một kernel module, code chúng ta sẽ được thực thi. (Chẳng hạn như sử dụng crypto-API để tải crypto-module hoặc sử dụng ifconfig để tải networking module cho thiết bị hiện không sử dụng.)\n  core_pattern: core_patterns thường sử dụng để cho kernel biết cách đặt tên và định dạng các core dumps được tạo khi chương trình bị crash.\nTuy nhiên, nó lại có 1 tính năng rất tệ: \u0026ldquo;từ Linux kernel 2.6.19. Linux hỗ trợ cú pháp thay thế cho tệp /proc/sys/kernel/core_patterm. Nếu ký tự đầu tiên của tệp này là kí tự pipe (|),\nthì phần còn lại của dòng này được hiểu là một chương trình sẽ được thực thi. Thay vì được ghi vào đĩa, core dump lúc bây giờ sẽ được xem là một chuẩn input của chương trình trên.\u0026rdquo;.\nSử dụng tính năng trên, core_pattern có thể được chỉ định để gọi chương trình của chúng ta, rồi để kích hoạt nó, ta chỉ cần làm cho chương trình bị crash.\n  /proc/sys/vm/panic_on_oom: đây là global flag, xác định kernel có \u0026ldquo;hoảng sợ\u0026rdquo; (panic) khi gặp phải tình trạng hết bộ nhớ hay không (Out Of Memory - OOM). Điều này cho phép chúng ta tiến hành một cuộc tấn công DOS đơn giản.\n  Dangerous Paths 1 2 3 4 5  # block some other dangerous paths deny @{PROC}/kcore rwklx, deny @{PROC}/kmem rwklx, deny @{PROC}/mem rwklx, deny @{PROC}/sysrq-trigger rwklx,     kcore cung cấp kết xuất đầy đủ của bộ nhớ vậy lí hệ thống (full dump of the physical memory) ở dạng core file. Nó không cho phép ghi vào bộ nhớ đã nói.\nQuyền truy vào điều này cho phép container có thể đọc tất cả host memory.\n  kmem: \u0026ldquo;/proc/kmem\u0026rdquo; là một giao diện thay thế cho \u0026ldquo;/dev/kmem\u0026rdquo; (quyền truy cập trực tiếp bị chặn bới cgroup device whitelist), là một kí tự đại diện cho kernel virtual memory.\nNó cho phép cả đọc và viết, cho phép trực tieps sửa đổi kernel memory. (Nó đòi hỏi sự khéo léo hơn một chút so với kmem, vì các địa chỉ ảo cần được phân giải thành các địa chỉ vật lí trước).\n  sysrq-trigger: ghi vào tệp đặc biệt này cho phép gửi các lệnh khóa yêu cầu (Request Key commands), cho phép môt số hành động đặc quyền,\nchẳng hạn như hủy các quy trình, liệt kê tất cả các quy trình trên hệ thông hoặc kích hoạt khởi động lại máy chủ.\n  Các khối quan trọng cuối cùng ghi đến một số nơi khác nhau có thể nguy hiểm:\n1 2 3 4 5 6  # deny writes in /sys except for /sys/fs/cgroup, also allow # fusectl, securityfs and debugfs to be mounted there (read-only) deny mount fstype=debugfs -\u0026gt; /var/lib/ureadahead/debugfs/, deny /sys/firmware/efi/efivars/** rwklx, deny /sys/kernel/security/** rwklx, deny @{PROC}/sys/fs/** wklx,     debugfs: cung cấp một giao diện \u0026ldquo;no rules\u0026rdquo; mà kernel (hoặc kernel module) có thể tạo ra các giao diện debug có thể truy cập vào vùng người dùng (userland).\nNó đã có một số vấn đề về bảo mật trong quá khứ và các nguyên tắc \u0026ldquo;no rules\u0026rdquo; đằng sau hệ thống tệp thường xung đột với các ràng buộc bảo mật.\nBên trong một LXC container, nó được gán ở chế độ chỉ đọc.\n  /sys/firmware/efi/efivars: efivars cung cấp một giao diện để viết vào NVRAM sử dụng cho các đối số khởi động UEFI (UEFI boot arguments).\nViệc sửa đổi chúng có thể khiến máy chủ không thể khởi động được (unbootable).\n  /sys/kernel/security: được gán ở đây là một giao diện securityfs, cho phép cấu hình Linux Security Modules. Nó cho phép cấu hình chính sách của AppArmor,\nvì vậy, quyền truy cập vào điều này có thể cho phép một vùng chứa vô hiệu hóa hệ thống MAC của nó.\n  /proc/sys/fs: Thư mục này chứa một mảng các options và thông tin liên quan đến các khía cạnh khác nhau của hệ thống tệp, bao gồm: quota, file handle, inode,\nand dentry information. Ghi vào thư mục này cho phép các cuộc tấn công từ chối dịch vụ khác nhau chống lại máy chủ.\n  seccomp  Là cơ chế cho system call filtering. Chính sách của policies đến từ 2 version.  Trong version 1, một filter là một tập hợp nhỏ các lệnh gọi hệ thống không thể tùy chỉnh. Trong version 2, \u0026ldquo;Filter mode\u0026rdquo;, system call filter được viết như chương trình lọc gói Berkeley (Berkeley Packet Filter - BPF). Điêu\nĐây được gọi là \u0026ldquo;Strict\u0026rdquo; mode. LXC hiện tại sử dụng một chính sách khá đơn giản, trong khi bản release 1.10 của docker được giới thiệu hỗ trợ cho seccomp-bpf.\nMột điều lưu ý là trong Docker 1.10, seccomp không được sử dụng theo mặc định trên trusty (hơi khó hiểu vì docker 1.10 trên ubuntu 15.10, seccomp vẫn được sử dụng mặc định).\nTuy nhiên, kể từ Docker 1.11.1 seccomp hiện cũng được sử dụng theo mặc định trên trusty.    Tầm quan trọng của Seccomp Seccomp-BPF cho phép cấu hình lọc những \u0026ldquo;lời gọi hệ thống nguy hiểm\u0026rdquo;. Đối với một số phiên bản hiện nay, LXC đã xuất xưởng với chính sách seccomp rất nhỏ, đơn giản,\nvới minh họa ở dưới. Với bản Docker 1.10, Docker đã thêm nhiều chính sách phức tạp hơn.\n1 2 3 4 5 6 7 8 9  2 blacklist reject_force_umount # comment this to allow umount -f; not recommended [all] kexec_load errno 1 open_by_handle_at errno 1 init_module errno 1 finit_module errno 1 delete_module errno 1   Phần đầu của chính sách LXC được sử dụng như một biện pháp bảo vệ chuyên sâu để ngăn chạn các vùng chứa buộc phải ummounting các phần của filesystem.\nKernel Manipulation Một số lệnh cho phép thao tác với kernel module bị cấm (init_module, finit_module, delete_module), cũng như kexec_load cho phép thay thế kernel hiện tại bằng\nmột kernel images mới. Lưu ý, có một số biện pháp bảo vệ chuyên sâu chống lại việc khai thác chúng trong các container đặc quyền:\n init_module, finit_module, delete_module: tất cả yêu cầu SYS_MODULE capability - đã bị loại bỏ bởi Docker và LXC trong privileged containers. kexec_load không yêu cầu SYS_MODULE, thay vào đó nó yêu cầu SYS_BOOT - privileged LXC container giữ. Trong hầu hết các trường hợp, điều này không thể khai thác (mà không bypass seccomp),\ntuy nhiên, điều đáng chú ý là Linux 3.17 đã gới hiệu 1 biến thể mới của kexec: kexec_file_load. Lệnh gọi này (tải signed kernels) không nằm trong danh sách đen của privileged LXC container, và chỉ yêu cầu SYS_BOOT. Tuy nhiên, vùng chứa LXC đặc quyền có một số vấn đề khác cho phép thoát khỏi container mà không cần boot vào kernel mới (vì trên thực tế, chúng ta có thể bypass seccomp).  The Issue With open_by_handle_at() open_by_handle_at là một lợi gọi hệ thống khá thú vị, ban đầu nó được đưa vào kernel để hỗ trợ userspace file servers để các process dễ dàng chuyển các mã định danh tệp duy nhất (unique file identifiers) cho nhau.\nTuy nhiên, nó lại là một cơn ác mộng của bảo mật. Bất kì process nào có khả năng DAC_READ_SEARCH đều có thể sử dụng open_by_handle_at để có quyền truy cập vào bất cứ tệp nào,\nngay cả các tệp bên ngoại không gian tên gắn kết của chúng. Xử lí được chuyển vào open_by_handle_at nhằm mục đích giúp một số nhận dạng không rõ được truy xuất bằng cách sử dụng name_to_handle_at.\nTuy nhiên, quá trình xử lí này lại chứa thông tin nhạy cảm và có thể bị giả mạo. Lỗi này được chỉ ra trong docker container bởi Sebastian krahmer, điều này đã ảnh hướng đến cả LXC và Docker.\nNó cũng là một vấn đề trong OpenVZ (một hệ thống container khác, nhưng nay đã không còn phổ biến nhiều nữa). Docker đã giải quyết bằng cách bỏ DAC_READ_SEARCH (cũng như chặn nhưng truy cập vào open_by_handle_at bằng seccomp).\nLXC giải quyết bằng cách sử dụng user namespaces, và mặc định chặn những lời gọi hệ thống thông qua seccomp. Chính sách của seccomp đã bị vô hiệu hóa trong cả\nprivileged và unprivileged của LXC containers. Vì vậy, những người dùng thận trọng được khuyên nên cấu hình unprivileged LXC container và bỏ DAC_READ_SEARCH (và có thể cả SYS_PTRACE).\nAbusing Privileged Containers SYS_RAWIO Abuse  SYS_RAWIO được cho là dễ lạm dụng vì nó được sử dụng trên toàn bộ kernel và trong một số ngữ cảnh nhạy cảm, điều này dẫn đến việc tìm thấy lỗi container escape trên\nLXC privileged container. Những phiên bản mới của LXC đã bỏ SYS_RAWIO và có thêm những luật AppArmor để chặn truy cập vào \u0026ldquo;/proc/bus\u0026rdquo;. Từ bên trong containter, ta có thể truy cập vào \u0026ldquo;control regions\u0026rdquo; của thiết bị được gắn vào host PCI bus bằng \u0026ldquo;/proc/bus/pci/interface\u0026rdquo;. Để truy cập vào \u0026ldquo;/proc/interface\u0026rdquo; cần phải có quyền SYS_RAWIO.\nThậm chí, đường dẫn \u0026ldquo;/proc\u0026rdquo; bị chặn bởi AppArmor, container với SYS_RAWIO vẫn có thể tiếp tục truy cập vào interface này thông qua \u0026ldquo;iopl/ioperm\u0026rdquo;\n(sau đó sử dụng inb, outb, friends để truy cập vào IO ports). Một điều lưu ý là Docker không bị lỗi này, vì \u0026quot;/proc\u0026quot; thường được gắn cho chế độ chỉ đọc và SYS_RAWIO bị loại bỏ.\nTrong phản hồi về lỗi này, nhóm LXC nhận xét rằng họ coi các vùng privileged container vốn không an toàn, vì có một lỗ hổng đã biết và \u0026ldquo;không thể sửa\u0026rdquo; trong các vùng privileged containers.  The ptrace Hole \u0026ldquo;Kiểm tra seccomp sẽ không được chạy lại sau khi tracer được thông báo. (Điêu này có nghĩa là hộp cát dựa trên seccomp KHÔNG cho phép sử dụng ptrace, ngay cả sandboxed processes,\nmaf không thận trọng, ptracer có thể được bị sử dụng để escappe).\u0026rdquo;\n  Bản thân \u0026ldquo;lỗ hổng bảo mật\u0026rdquo; là một vấn đề đơn giản về Time-of-Check-to-Time-of-Use (TOCTTOU): seccomp filtering được áp dụng trước khi tracer được thông báo (và trước khi cuộc gọi hệ thống thực sự dược kích hoạt),\nvì vậy pacer có thể sửa đổi các thanh ghi được sử dụng trong lệnh gọi hệ thống (sau khi chúng đã được kiểm tra bởi seccomp) để biến một lệnh gọi hệ thống từ bình thường trở thành \u0026ldquo;độc hại\u0026rdquo;.\nCách mafg docker giải quyết vấn đề này đơn giản là không cho phép sử dụng ptrace trong containers (bằng cách loại bỏ SYS_PTRACE ở chế độ mặc định). Mặc dù seccomp có thể bị vô hiệu hóa bằng cách sử dụng ptrace trong unprivileged contaner,\nviệc làm dụng open_by_handle_at sẽ không thành công, vì quá pocess vẫn thiếu DAC_READ_SEARCH trong root namespace. Với việc bổ sung user namespace vào docker, khả năng docker sẽ cho phép sử dụng ptrace bên trong container (mặc dù không chắc\ndo sự tập trung gần đây của họ vào seccomp).\n  Mặc dù LXC privileged containers vốn đã không an toàn, việc tìm ra các điểm đột phá (breakout) là một bài tập thú vị (và thường chúng có thể làm cho các privileged container an toàn hơn một chút)\n  Abusing Unprivileged Containers Tiếp theo, chúng ta sẽ tìm hiểu những điểm yếu của unprivileged containers.\nPID Namespacing Info-Leak Chúng ta sẽ nói đến tệp /proc/sched_debug. pseudo-file này cho phép unprivileged user có thể xem thông tin debug cho Linux scheduler và không biết PID-namespace. Dễ thấy, nó tiết lộ tên và PID của tất cả các tiến trình đang chạy trên hệ thống (và thậm chí biết cả nhóm tác vụ của chúng (cgroup) là gì, giúp xác định được các vùng chứa khác trên hệ thống và hệ thống container nào đang được thực thi). Lỗi này đã được reported cho cả Docker và LXC và nó đã được vá ở Docker.\nNET_RAW abuse Cấu hình phổ biến nhất cho các công ty cung cấp giải pháp PaaS được xây dựng trên container là có nhiều container của khách hàng chạy trên cũng một máy chủ vật lý. Theo mặc định, cả LXC và Docker đều thiết lập container network để tất cả các vùng chứa chia sẻ cùng một Linux virtual bridge. Do đó, những container này sẽ có thể giao tiếp với nhau. Ngay cả khi quyền truy cập mạng trực tiếp này bị vô hiệu hóa (set flag -icc = false cho Docker hoặc sử dụng iptables rules cho LXC), các container vẫn không bị hạn chế đối với việc truy cập link-layer traffic. Đặc biệt, có thể tiến hành một cuộc tấn công giả mạo ARP vào một container khác trong cùng một hệ thống máy chủ, cho phép tấn công full middle-person đối với lưu lượng của container mục tiêu. Chúng ta sẽ có một bài viết nói rõ hơn về cách tần công này.\nSau khi nhận được báo cáo này, LXC team đã đề xuất một số giải pháp, chúng bao gồm:\n Sử dụng LXD với OpenStack để quản lí container networking Sử dụng libvirt để quản lí MAC tables của bridges/containers. Sử dụng một virtual bridge riêng trên mỗi trust zone hoặc trên mỗi container.  Denial of Service Attacks User namespaces hoạt động bằng cách \u0026ldquo;sliding\u0026rdquo; UIDs giữa user namspace (container) và root namespace (host). Ví dụ, mặc định cài đặt của LXC thì UID 0 bên trong contaner sẽ trở thành UID 100000 trên host. Tuy nhiên, mặc định trên cả LXC và Docker là sử dụng cùng một trang trình bày UID cho tất cả các unprivileged container.\nNói cách khác, các UID giống hệt nhau của các process trong container khác nhau sẽ có giá trị giống nhau trên máy chủ, chỉ được chuyên lên bằng một slide không đổi (tức là tất cả các process đang chạy dưới root bên trong bất kì container nào sẽ đang chạy với UID 100000 trên host). Điều nay làm tăng khả năng ulimit của người dùng khi bị tấn công, vì các khu vực này của kernel không xác định được user namespace. Lưu ý rằng các điều kiện của từ chối dịch vụ (Dos) xảy ra mà không cần user namespace (cũng như điều kiện tương tự của UID máy chủ được chia sẻ đẻ áp dụng). Chúng ta sẽ có một bài viết riêng để thảo luận về cách tấn công này, tuy nhiên chúng ta có một số khái niệm cần lưu ý:\n pending Signals: Đây là giới hạn cho mỗi người dùng về số lượng tín hiệu đang chờ xử lý tối đa có thể được xếp hàng đợi trong tất cả các process của người dùng. process chạy trong một container có thể xếp hàng đợi số lượng tin hiệu đang chờ xử lý tối đa, ngăn các quá trình trong các process khác nhận được tín hiệu đang chờ xử lý. Thực nghiệm cho thấy, điều này làm ảnh hưởng đến cả LXC và Docker. Posix Message Queues: giới hạn số lượng tài nuyên tối đa có thể được sử dụng trên hàng đợi thông điệp POSIX. Quá trình chạy trên một container có thể làm cạn kiệt tất cả bộ nhớ hàng đợi thông điệp POSIX có sẵn, ngăn các process trong container khác tạo hoặc gửi thông điệp đến hàng đợi thông điệp POSIX, Thử nghiệm cho thấy việc này vẫn đang hoạt động trên LXC và Docker. Max User Processes: giới hạn cho mỗi người dùng về số lượng process tối đa. Điều này có thể dễ dàng được khai thác để tạo ra một Dos đơn giản chống lại các container khác, cũng như máy chủ. Thử nghiệm cho thấy cuộc tấn công này rất thành công trên LXC (và có thể làm hỏng toàn bộ máy chủ) trong khi trên Docker chỉ có thể hạ tất cả vùng chứa Docker (máy chủ vẫn ổn định). Lưu ý, Linux 4.3 đã thêm khả năng giới hạn tài nguyên PID, điều này giúp các hệ thống container giảm thiếu vấn đề này. Max Files: Đây là giới hạn cho mỗi người dùng về số lượng bộ mô tả tệp tối đa có thể mở. Tren cả LXC và Docker, đây là một cách dễ dàng để Dos tất cả các container khác đang chạy trên cùng 1 máy chủ.\nBỏ qua ulimit, hai điều kiện Dos khác có thể được khai thác trong container như sau: Disk Space: có lẽ, Dos đơn giản nhất để tấn công hệ thống container là làm cho ổ đĩa bị full. Thử nghiệm, cho thấy điều này đã hoạt động trên LXC và Docker. Không giống như một sô cuộc tấn công Dos ở trên, thường có thể làm hỏng máy chú hoạc gây ra bất ổn đủ để chúng khó dọn dẹp, cách này cung cấp khả năng đơn giản nhất để tạo ra một Dos và sau đó dọn dẹp nó một cách nhanh chóng. Kết hợp với PID Namespacing Info-Leak, điều này có thể cho phép container của kẻ tấn công nhằm mục tiêu đến những người thuê khác trên cùng một máy chủ được chia sẻ, chỉ tạo điều kiện Dos có chọn lọc khi một số container hoặc process khác đang chạy. Global File Descriptor Limits: Hệ thống duy trì giới hạn về số lượng bộ mô tả tệp tối đa có sẵn tổn thể (có sẵn tại /proc/sys.fs.filemax, như thảo luận trước đó, container không thể ghi vào). Nếu container không chia sẻ UID và có bộ ulimit về số bộ mô tả tệp mà chúng ta có thể mở, container vẫn có thể cố gắng DoS máy chủ và các contaienr khác bằng cách mở sô lương FD tối đa cho phép khi mỗi người dùng trong user namespace của họ, cung cấp khả năng tiêu thụ FD được khuếch đại rất nhiều. Đây thường là Dos \u0026ldquo;last line\u0026rdquo; và chỉ được được thiện nếu các biên pháp giảm nhẹ cho các vector khác (đơn gian hơn) được đưa ra.  Container Engine Vulnerabilities Một số lỗ hổng và cách khai thác.\nDocker Vulnerabilities    Weak/proc permissions Host FD leakage Symlinks     CVE-2015-3630 CVE-2015-3627 CVE-2015-3627   CVE-2015-3631 CVE-2019-15664 CVE-2015-3629     CVE-2019-15664    Escape via Insecure Configuration  Bad idea #1: Exposed Docker Socket Bad idea #2: \u0026ndash;privileged container Bad idea #3: Excessive Capabilities Bad idea #4: Sensitive mounts  Kernel Exploitation The security model of containers is predicated on kernel integrity\nDirty CoW (CVE-2016-5195) ","description":"Tìm hiểu về Container Escapes","id":4,"section":"posts","tags":["Docker"],"title":"Tìm hiểu về Container Escapes","uri":"https://minhlongmt183.github.io/posts/container-escapes/"},{"content":"Toàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống kiến của các tác giả của những kênh nói trên.❤️❤️❤️  Tổng quan về Docker Docker là gì?  Docker là một container platform để phát triển, triển khai và quản lí ứng dụng nhanh chóng. Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng. Docker cho phép ứng dụng của chúng ta độc lập với cơ sở hạ tầng (infrastructure) của máy, do đó, chúng ta có thể dễ dàng chia sẻ ứng dụng một cách dễ dàng giữa các thiết bị. Chúng ta có thể quản lí cở sở hạ tầng (infrastructure) giống như cách quản lí những ứng dụng trên máy. Sử dụng LibContainer để quản lý những function của Linux kernel và sử dụng những nhóm công nghệ độc lập như: Namespaces, Control Groups, AppArmor, security profiles, network interface, rule for the firewall necessary for the operation of containers.  The Docker platform  Docker cung cấp một khả năng đóng gói và chạy ứng dụng trên một môi trường cô lập, khả năng này gọi là container. Container nhẹ và chứa tất cả những thức cần thiết để chạy ứng dụng, do đó, chúng ta chỉ cần tải về và chạy trên máy cá nhân (host). Ngoài ra, môi trường được chạy là môi trường độc lập và bảo mật (security) cho phép chúng ta chạy nhiều container đồng thời và dễ dàng chia sẻ container trong khi chúng ta làm việc, và đảm bảo tất cả mọi người đều được chúng ta chia sẻ một container sẽ có chung 1 môi trường thực thi ứng dụng, và cho kết quả thực thi giống nhau. Docker cung cấp công cụ và nền tảng để quản lí vòng đời (lifecycle) containers của chúng ta:  Phát triển ứng dụng của chúng ta và hỗ trợ những thành phần để ứng dụng có thể sử dụng container. Container trở thành một đơn vị (unit) để phân phối và kiểm tra ứng dụng của chúng ta.    Dùng docker để làm gì? Nhanh, phân phối nhất quán ứng dụng của chúng ta Docker sắp xếp hợp lí vòng đời phát triển bằng cách cho phép các developers làm việc trong môi trường chuẩn, sử dụng local container - nơi cung cấp những ứng dụng và dịch vụ (services). Conatiner là một giải pháp cho quy trình làm việc CI/CD (continuous integration and continuous delivery).\nKhả năng triển khai và mở rộng  Nền tảng dựa của container docker đáp ứng cho khối công việc có khả năng linh động cao. Docker container có thể chạy trên laptop của lập trình viên, có thể chạy trên máy thật hoặc máy ảo trong các data center, trên clouder provider, hoặc trong hỗn hợp các môi trường (mixture of environments) Tính linh động và nhẹ của docker làm cho nó dễ dàng trong việc quản lý động các công việc, mở rộng hoặc chia nhỏ các ứng dụng, dịch vụ theo nhu cầu kinh doanh, trong thời gian thực.  Chạy được nhiêu công việc hơn trong cùng một phần cứng (hardware). Vì docker nhẹ và nhanh, nó có khả năng thay thế những máy ảo được xây dựng dựa trên hypervisor, chúng ta có thể sử dụng nhiều khả năng tính toán hơn để thực hiện mục tiêu của mình. Docker hoạt động hiệu quả cho cả môi trường triển khai có mật độ cao, vừa hoặc nhỏ, nơi mà chúng ta cần làm việc với ít tài nguyên hơn.\nKiến trúc của Docker.  Docker sử dụng kiến trúc client-server. Docker client sẽ nói chuyện với docker daemon - trình thực hiện xây dựng, chạy, phân phối docker container của chúng ta.  Docker client và daemon có thể chạy trên cùng 1 hệ thống, hoặc có thể kết nối docker client tới một trình điều khiển docker daemon (remote docker daemon) Chúng giao tiếp với nhau thông qua sử dụng REST API, qua UNIX sockets hoặc network interface.    The Docker Daemon( dockerd) Lắng nghe những yêu cầu từ Docker API và quản lí đối tượng của docker như: images, container, networks, volumes. Một daemon can thể giao tiếp với những daemons khác để quản lí docker services.\nThe Docker client (docker) Là cách mà người dùng tương tác với docker. khi chúng ta thực hiện những câu lệnh như docker run, client sẽ gửi câu lệnh này với dockered để đem chúng ra ngoài. Lệnh docker sử dụng Docker API. Docker client có thể giao tiếp với một hoặc nhiều daemon.\nDocker registries Môt docker registry lưu trữ Docker images. Docker Hub là một public registry mà mọi người đều có thể sử dụng, và docker được cấu hình mặc định để tìm kiếm những images trên Docker Hub. chúng ta còn có thể chạy những registry của riêng chúng ta.\nKhi chúng ta thực hiện lệnh docker pull hoặc docker run, những images yêu cầu sẽ được kéo từ registry của chúng ta về máy, và khi thực hiện lệnh docker push, images của chúng ta sẽ được đẩy lên trên registry.\nDocker Object Images Một image là một mẫu chỉ đọc với tập lệnh để tạo ra một docker container. Thông thường, một image dựa trên những image khác với một số tùy chỉnh bổ sung. Ví dụ, chúng ta muốn xây dựng một image dựa trên ubuntu image, nhưng có cài thêm Apache web server, ứng dụng riêng của chúng ta cũng như những cấu hình cần thiết để có ứng dụng chạy.\nchúng ta có thể tạo images riêng hoặc sử dụng những images đã có sẵn trên các registry.\nĐể xây dựng riêng images, chúng ta tạo Dockfile với những cú pháp đơn giản định nghĩa các bước cần thiết để tạo image và chạy nó. Mỗi câu lệnh trong Dockerfile tạo một layer trong image. Khi bạn thay đổi Dockerfile và rebuild image, chỉ những layer bị thay đổi mới buil lại. Đây chính là lí do làm cho image trở nên nhẹ, nhỏ, nhanh khi đem so sánh với những công nghệ ảo hóa khác.\nContainers  Docker đóng gói phần mềm thành một đơn vị chuẩn, gọi là container, nơi lưu tất cả những thứ cần thiết để chạy phần mềm, bao gồm: libraries, systemtools, and code Một container có thể chạy một images. Chúng ta có thể create, start, stop, move, delete một container bằng sử dụng Docker API hoặc CLI. Chúng ta có thể kết nối từ một container tới một hoặc nhiều networks, đính kèm bộ nhớ vào trong nó, hoặc thâm chí có thể tạo ra một image mới dựa trên trạng thái hiện tại của nó. Theo mặc định, một container độc lập với những container khác và với host machine. Chúng ta có thể kiểm soát mức độ độc lập của network, bộ nhớ hoặc những hệ thống con cơ bản từ môt container tới những container khác hoặc từ host machine tới những container. Một container được định nghĩa bởi images của nó, cũng như bất kỳ tùy chọn cấu hình nào bạn cung cấp cho nó khi tạo hoặc khởi động nó. Khi một container bị xóa, những thay đổi về trạng thái của nó không được lưu mà sẽ bị xóa.  Ví dụ về docker run command Những câu lệnh sau run một ubuntu container:\n1  $ docker run -i -t ubuntu /bin/bash   Khi chúng ta chạy lệnh này, quá trình thực hiện sẽ nhưu sau (xét trường hợp cấu hình là default):\n1. Nếu chúng ta không có ubuntu image ở local, Docker pulls nó từ configured registry của chúng ta, chúng ta có thể kéo nó xuống bằng câu lệnh: docker pull ubuntu\n2. Docker tạo ra một container mới, chúng ta có thể tự thực hiện bằng lệnh: docker container create.\n3. Docker phân bổ read-write filesystem vào container, như là lớp cuối cùng của nó (final layer). Nó cho phép chạy để tạo hoặc chỉnh sửa file hoặc thư mục ở local filesystem.\n4. Docker tạo ra network interface để để nối contain tới default network, vì chúng ta không chỉ định bất kì tùy chọn mạng nào - gán IP adress vào container. Theo định nghĩa, container có thể kết nối với mạng bên ngoài thông qua sử dụng kết nối mạng của máy host.\n5. Docker chạy container rồi thực thì /bin/bash. Vì container đang chạy ở chế độ tương tác và gán vào terminal (-i, -t flags), chúng ta có thể input từ keyboard và output được ghi vào terminal của bạn.\n6. Khi chúng ta gõ exit để dừng /bin/bash, container sẽ dừng nhưng không bị xóa, do đó, ta có thể chạy lại hoặc xóa nó.\nThe underlying technology Docker được viết bằng ngôn ngữ GO và tận dụng một số tính năng từ Linux kernel để trở thành chức năng của nó.\nDocker sử dụng một công nghệ được gọi là namespaces để cung cấp không gian độc lập được gọi là container. Khi bạn chạy một container, Docker tạo ra một tập namespaces cho container đó.\nNhững namespaces cung cấp một lớp độc lập, mỗi khía cạnh của một vùng chứa chạy trong một không gian tên riêng biệt và quyền truy cập của nó bị giới hạn trong không gian tên đó.\nCài docker Post-installation steps for Linux Quản lý docker với tư cách là non-root user  Docker daemon kết nối với Unix socket thay vì cổng TCP. Mặc định, Unix socket được sở hữu bởi root\nvà những user khác chỉ có thể truy cập thông qua lệnh sudo. Do đó, Docker daemon luôn luôn chạy\nvới tư cách là root user. Chúng ta có thể thiết lập lại để chạy mà không cần lệnh sudo bằng cách tạo ra một Unix group là docker\nvà thêm user vào nó. Khi docker daemon chạy, nó tạo một Unix socket mà tất cả các thành phần của docker group\ncó thể truy cập vào.   Tạo docker group:  $ sudo groupadd docker Thêm user vào docker group  $ sudo usermod -aG docker $USER Kích hoạt sự thay đổi  $ newgrp docker Configure Docker to start on boot  Trên Debian và Ubuntu, Docker service mặc định được cấu hình để khởi động khí boot.\nVới những distros khác, ta có thể sử dụng lệnh sau đây để tự động chạy:  $ sudo systemctl enable docker.service $ sudo systemctl enable containerd.service  Và để tắt chế độ trên:  $ sudo systemctl disable docker.service $ sudo systemctl disable containerd.service Cấu hình nơi Docker daemon lắng nghe để kết nối  Mặc định, Docker daemon sẽ nghe kết nối ở UNIX socket để chấp nhận các yêu cầu từ local client.\nNgoài ra, chúng ta có thể cho phép Docker chấp nhận những yêu cầu từ remote host bằng việc cấu hình để nó lắng nghe\ntrên một địa chỉ IP và một cổng, giống như UNIX socket.  Configuring remote access with systemd unit file  sudo systemctl edit docker.service để ghi đè file docker.service. Thêm / sửa những lệnh sau:  [Service] ExecStart= ExecStart=/usr/bin/dockerd -H fd:// -H tcp://127.0.0.1:2375 Lưu file Reload lại cấu hình systemctl  $ sudo systemctl daemon-reload Chạy lại Docker  $ sudo systemctl restart docker.service Kiểm tra đảm bảo sự thay đổi  $ sudo netstat -lntp | grep dockerd Configuring remote access with daemon.json  Thêm dòng lệnh vào /etc/docker/daemon.json để kết nối với UNIX socket và địa chỉ IP:  { \u0026quot;hosts\u0026quot;: [\u0026quot;unix:///var/run/docker.sock\u0026quot;, \u0026quot;tcp://127.0.0.1:2375\u0026quot;] } Khởi động lại Docker Kiểm tra đảm bảo sự thay đổi  $ sudo netstat -lntp | grep dockerd Thêm nhiều cấu hình khác\n","description":"Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng.","id":5,"section":"posts","tags":["Docker"],"title":"Tìm hiểu về docker","uri":"https://minhlongmt183.github.io/posts/docker_overview/"},{"content":"About me\n","description":"Edisc","id":7,"section":"","tags":null,"title":"Edisc","uri":"https://minhlongmt183.github.io/about/"}]