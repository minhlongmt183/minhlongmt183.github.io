[{"content":"Container Basics Chúng ta sẽ đi qua một số khái niệm cơ bản và cần thiết trong docker:\nCredentials Credentials describe the user identity of a task, which determine its permission for shared resources such as files, semaphores, and shared memory.\nCapabilities Since kernel 2.2, Linux divides the privileges associated with superuser into distinct unit known as capabilities\n/proc/$PID/status | man capabilities Filesystem The container\u0026rsquo;s root mount is often planted in a container-specialized filesystem, such as OverlayFS\n/var/lib/docker/overlay2/..hash../diff Namespaces  Mục đích: làm cho hệ thống container có thể sử dụng và an toàn. PID: have their own view of tasks - cung cấp cây không gian tên của process id. Nó cho phép mỗi container có một cây đầy đủ các process id riêng biệt, trong đó init process có pid = 1. Process chạy trên host sẽ có pid khác với khi chạy trên container. User: wrap mapping of UID to user - cung cấp phiên bản namespace của User IDs (UIDs) and Group IDs (GIDs). Đây là một trong những tính năng quan trọng nhất của hệ thống container hiện đại vì nó được sử dụng để cung cấp \u0026ldquo;unprivileged containers\u0026rdquo;. User namespaces cung cấp một trong những nền tản cho hệ thống container trên Linux hiện nay, và là vùng cấu hình duy nhất được LXC coi là an toàn. Mount: isolate mount points - cung cấp chế độ xem không gian tên của các điểm kết nối (mount points). Kết hợp với pivot_root syscall, tính năng này sẽ cô lập container\u0026rsquo;s filesystem với host\u0026rsquo;s filesystem. Network: cung cấp không gian tên và ngăn xếp mạng riêng biệt. Hầu hết các trường hợp sử dụng của container liên quan tới dịch vụ mạng, vì vậy nó được coi là tính năng lõi của container. UTS: have their own hostname - cung cấp namespaced version của định danh hệ thống (system identifies) IPC: restrict SysV IPC objects Cgroup: isolate the view of cgroups  /proc/$PID/ns/ Cgroups CGroups: cung cấp giao diện phân cấp để quản lí cũng như đo lường tài nguyên và quyền truy cập của thiết bị. Cgroups có thể được sử dụng bởi các process có quyền hạn cao (higher privileged) để đặt giới hạn về sử dụng bộ nhớ, CPU, chặn các thiết bị IO khác. Chúng còn có thể được sử dụng chung với iptables để cung cấp định hình lưu lượng. Quan trong nhất, chúng được sử dụng trong hệ thống container đẻ kiểm soát quyền truy cập của các thiết bị.\nLinux Security Modules - LSMs  AppArmor and SELinux are Linux security modules providing Mandatory Access Control (MAC), where access rules for a program are described by a profile. AppArmor là LSM phổ biến nhất trong hệ thống container, nó có thể giới hạn các hành động mà một chương trình nhất định có thể thực hiện, cũng như thực hiện các hành động phức tạp khi bắt đầu process. Cả LXC và Docker đều thiết lập ở chế độ mặc định để xây dựng những rào cản an ninh, chống lại những mối đe dọa theo chiều sâu. Cho đến nay, AppArmor được ghi nhận là hỗ trợ và ghi nhận tốt nhất.\nDo sự đơn giản của cú pháp AppArmor, nó cũng dễ sử dụng hơn rất nhiều để cấu hình tùy chỉnh cho mỗi vùng chứa. Docker and LXC enable a default LSM profile in enforcement mode, wh mostly serves to restrict a container\u0026rsquo;s\naccess to sensitive /proc and /sys entries. The profile also denies mount syscall.  Tầm quan trọng của Apparmor Mount Options  Chính sách của AppArmor chặn việc truy cập để mounting devpts filesystems. Như comment ở dưới, nếu không có chính sách này, container có thể remount /dev/pts và chiếm quyền truy cập vào các thiết bị đầu cuối của máy chủ.  1 2 3 4  # the container may never be allowed to mount devpts. If it does, it # will remount the host\u0026#39;s devpts. We could allow it to do it with # the newinstance option (but, right now, we don\u0026#39;t). deny mount fstype=devpts    Các chính sách dùng để chặn container cố gắng remount root filesystem. Chính sách này được thực hiện như một biện pháp phòng thủ theo chiều sâu.  1 2 3  # ignore DENIED message on / remount deny mount options=(ro, remount) -\u0026gt; /, deny mount options=(ro, remount, silent) -\u0026gt; /,   Utility Changes   Có rất nhiều \u0026ldquo;nơi nguy hiểm\u0026rdquo; trong /proc và /sys cho phép các container thoát ra ngoài (container escapes).\nTất cả những điều này liên quan tới việc thay đổi vị trí của một tiện ích (chẳng hạn như modprobe) mà máy chủ sẽ gọi khi một sự kiện nhất định xảy ra (ví dụ như yêu cầu load yêu cầu của kernel module).\nBằng cách thay đổi điều này để trỏ đến một chương trình bên trong container của chúng ta, attacker sau đó có thể khiến máy chủ chạy một đoạn mã tùy ý bên ngoài container\n  LXC sử dụng bộ quy tắc sau để chặn các cuộc tấn công này. Lưu ý, nó không phải là một cấu hình cảu AppArmor, nó là đầu vào cho một đoạn lệnh python nhỏ tạo ra một phần dài (long portion) của các quy tắc AppArmor.\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  # Run lxc-generate-aa-rules.py on this file after any modification, to generate # the container-rules file which is appended to container-base.in to create the # final abstractions/container-base. block /sys allow /sys/fs/cgroup/** allow /sys/devices/virtual/net/** allow /sys/class/net/** block /proc/sys allow /proc/sys/kernel/shm* allow /proc/sys/kernel/sem* allow /proc/sys/kernel/msg* allow /proc/sys/kernel/hostname allow /proc/sys/kernel/domainname allow /proc/sys/net/**   Những vector quan trọng nào đang bị chặn?\n  uevent_helper: uevents là những sự kiện được kernel kích hoạt khi một thiết bị thêm vào hoặc xóa đi. Điều đáng chú ý là đường dẫn của \u0026ldquo;uevent_helper\u0026rdquo; có thể được chỉnh sửa bằng cách ghi vào \u0026quot;/sys/kernel/uevent_helper\u0026quot;.\nDo đó, khi một uevent được kích hoạt (cũng có thể được thực hiện từ userland bằng cách ghi vào các tệp như \u0026quot;/sys/class/mem/null/event\u0026quot;), \u0026ldquo;uevent_helper độc hại\u0026rdquo; sẽ được thực thi.\n  modprobe: modprobe là một tiện ích thuộc userland, được kernel gọi khi kernel cần load một kernel module. Vị trí của nó có thể được thay đổi bằng cách sửa đổi \u0026quot;/proc/sys/kernel/modprobe\u0026quot;,\nvà sau đó chúng ta chỉ cần thực hiện một hành động nào đó để kernel tải một kernel module, code chúng ta sẽ được thực thi. (Chẳng hạn như sử dụng crypto-API để tải crypto-module hoặc sử dụng ifconfig để tải networking module cho thiết bị hiện không sử dụng.)\n  core_pattern: core_patterns thường sử dụng để cho kernel biết cách đặt tên và định dạng các core dumps được tạo khi chương trình bị crash.\nTuy nhiên, nó lại có 1 tính năng rất tệ: \u0026ldquo;từ Linux kernel 2.6.19. Linux hỗ trợ cú pháp thay thế cho tệp /proc/sys/kernel/core_patterm. Nếu ký tự đầu tiên của tệp này là kí tự pipe (|),\nthì phần còn lại của dòng này được hiểu là một chương trình sẽ được thực thi. Thay vì được ghi vào đĩa, core dump lúc bây giờ sẽ được xem là một chuẩn input của chương trình trên.\u0026rdquo;.\nSử dụng tính năng trên, core_pattern có thể được chỉ định để gọi chương trình của chúng ta, rồi để kích hoạt nó, ta chỉ cần làm cho chương trình bị crash.\n  /proc/sys/vm/panic_on_oom: đây là global flag, xác định kernel có \u0026ldquo;hoảng sợ\u0026rdquo; (panic) khi gặp phải tình trạng hết bộ nhớ hay không (Out Of Memory - OOM). Điều này cho phép chúng ta tiến hành một cuộc tấn công DOS đơn giản.\n  Dangerous Paths 1 2 3 4 5  # block some other dangerous paths deny @{PROC}/kcore rwklx, deny @{PROC}/kmem rwklx, deny @{PROC}/mem rwklx, deny @{PROC}/sysrq-trigger rwklx,     kcore cung cấp kết xuất đầy đủ của bộ nhớ vậy lí hệ thống (full dump of the physical memory) ở dạng core file. Nó không cho phép ghi vào bộ nhớ đã nói.\nQuyền truy vào điều này cho phép container có thể đọc tất cả host memory.\n  kmem: \u0026ldquo;/proc/kmem\u0026rdquo; là một giao diện thay thế cho \u0026ldquo;/dev/kmem\u0026rdquo; (quyền truy cập trực tiếp bị chặn bới cgroup device whitelist), là một kí tự đại diện cho kernel virtual memory.\nNó cho phép cả đọc và viết, cho phép trực tieps sửa đổi kernel memory. (Nó đòi hỏi sự khéo léo hơn một chút so với kmem, vì các địa chỉ ảo cần được phân giải thành các địa chỉ vật lí trước).\n  sysrq-trigger: ghi vào tệp đặc biệt này cho phép gửi các lệnh khóa yêu cầu (Request Key commands), cho phép môt số hành động đặc quyền,\nchẳng hạn như hủy các quy trình, liệt kê tất cả các quy trình trên hệ thông hoặc kích hoạt khởi động lại máy chủ.\n  Các khối quan trọng cuối cùng ghi đến một số nơi khác nhau có thể nguy hiểm:\n1 2 3 4 5 6  # deny writes in /sys except for /sys/fs/cgroup, also allow # fusectl, securityfs and debugfs to be mounted there (read-only) deny mount fstype=debugfs -\u0026gt; /var/lib/ureadahead/debugfs/, deny /sys/firmware/efi/efivars/** rwklx, deny /sys/kernel/security/** rwklx, deny @{PROC}/sys/fs/** wklx,     debugfs: cung cấp một giao diện \u0026ldquo;no rules\u0026rdquo; mà kernel (hoặc kernel module) có thể tạo ra các giao diện debug có thể truy cập vào vùng người dùng (userland).\nNó đã có một số vấn đề về bảo mật trong quá khứ và các nguyên tắc \u0026ldquo;no rules\u0026rdquo; đằng sau hệ thống tệp thường xung đột với các ràng buộc bảo mật.\nBên trong một LXC container, nó được gán ở chế độ chỉ đọc.\n  /sys/firmware/efi/efivars: efivars cung cấp một giao diện để viết vào NVRAM sử dụng cho các đối số khởi động UEFI (UEFI boot arguments).\nViệc sửa đổi chúng có thể khiến máy chủ không thể khởi động được (unbootable).\n  /sys/kernel/security: được gán ở đây là một giao diện securityfs, cho phép cấu hình Linux Security Modules. Nó cho phép cấu hình chính sách của AppArmor,\nvì vậy, quyền truy cập vào điều này có thể cho phép một vùng chứa vô hiệu hóa hệ thống MAC của nó.\n  /proc/sys/fs: Thư mục này chứa một mảng các options và thông tin liên quan đến các khía cạnh khác nhau của hệ thống tệp, bao gồm: quota, file handle, inode,\nand dentry information. Ghi vào thư mục này cho phép các cuộc tấn công từ chối dịch vụ khác nhau chống lại máy chủ.\n  seccomp  Là cơ chế cho system call filtering. Chính sách của policies đến từ 2 version.  Trong version 1, một filter là một tập hợp nhỏ các lệnh gọi hệ thống không thể tùy chỉnh. Trong version 2, \u0026ldquo;Filter mode\u0026rdquo;, system call filter được viết như chương trình lọc gói Berkeley (Berkeley Packet Filter - BPF). Điêu\nĐây được gọi là \u0026ldquo;Strict\u0026rdquo; mode. LXC hiện tại sử dụng một chính sách khá đơn giản, trong khi bản release 1.10 của docker được giới thiệu hỗ trợ cho seccomp-bpf.\nMột điều lưu ý là trong Docker 1.10, seccomp không được sử dụng theo mặc định trên trusty (hơi khó hiểu vì docker 1.10 trên ubuntu 15.10, seccomp vẫn được sử dụng mặc định).\nTuy nhiên, kể từ Docker 1.11.1 seccomp hiện cũng được sử dụng theo mặc định trên trusty.    Tầm quan trọng của Seccomp Seccomp-BPF cho phép cấu hình lọc những \u0026ldquo;lời gọi hệ thống nguy hiểm\u0026rdquo;. Đối với một số phiên bản hiện nay, LXC đã xuất xưởng với chính sách seccomp rất nhỏ, đơn giản,\nvới minh họa ở dưới. Với bản Docker 1.10, Docker đã thêm nhiều chính sách phức tạp hơn.\n1 2 3 4 5 6 7 8 9  2 blacklist reject_force_umount # comment this to allow umount -f; not recommended [all] kexec_load errno 1 open_by_handle_at errno 1 init_module errno 1 finit_module errno 1 delete_module errno 1   Phần đầu của chính sách LXC được sử dụng như một biện pháp bảo vệ chuyên sâu để ngăn chạn các vùng chứa buộc phải ummounting các phần của filesystem.\nKernel Manipulation Một số lệnh cho phép thao tác với kernel module bị cấm (init_module, finit_module, delete_module), cũng như kexec_load cho phép thay thế kernel hiện tại bằng\nmột kernel images mới. Lưu ý, có một số biện pháp bảo vệ chuyên sâu chống lại việc khai thác chúng trong các container đặc quyền:\n init_module, finit_module, delete_module: tất cả yêu cầu SYS_MODULE capability - đã bị loại bỏ bởi Docker và LXC trong privileged containers. kexec_load không yêu cầu SYS_MODULE, thay vào đó nó yêu cầu SYS_BOOT - privileged LXC container giữ. Trong hầu hết các trường hợp, điều này không thể khai thác (mà không bypass seccomp),\ntuy nhiên, điều đáng chú ý là Linux 3.17 đã gới hiệu 1 biến thể mới của kexec: kexec_file_load. Lệnh gọi này (tải signed kernels) không nằm trong danh sách đen của privileged LXC container, và chỉ yêu cầu SYS_BOOT. Tuy nhiên, vùng chứa LXC đặc quyền có một số vấn đề khác cho phép thoát khỏi container mà không cần boot vào kernel mới (vì trên thực tế, chúng ta có thể bypass seccomp).  The Issue With open_by_handle_at() open_by_handle_at là một lợi gọi hệ thống khá thú vị, ban đầu nó được đưa vào kernel để hỗ trợ userspace file servers để các process dễ dàng chuyển các mã định danh tệp duy nhất (unique file identifiers) cho nhau.\nTuy nhiên, nó lại là một cơn ác mộng của bảo mật. Bất kì process nào có khả năng DAC_READ_SEARCH đều có thể sử dụng open_by_handle_at để có quyền truy cập vào bất cứ tệp nào,\nngay cả các tệp bên ngoại không gian tên gắn kết của chúng. Xử lí được chuyển vào open_by_handle_at nhằm mục đích giúp một số nhận dạng không rõ được truy xuất bằng cách sử dụng name_to_handle_at.\nTuy nhiên, quá trình xử lí này lại chứa thông tin nhạy cảm và có thể bị giả mạo. Lỗi này được chỉ ra trong docker container bởi Sebastian krahmer, điều này đã ảnh hướng đến cả LXC và Docker.\nNó cũng là một vấn đề trong OpenVZ (một hệ thống container khác, nhưng nay đã không còn phổ biến nhiều nữa). Docker đã giải quyết bằng cách bỏ DAC_READ_SEARCH (cũng như chặn nhưng truy cập vào open_by_handle_at bằng seccomp).\nLXC giải quyết bằng cách sử dụng user namespaces, và mặc định chặn những lời gọi hệ thống thông qua seccomp. Chính sách của seccomp đã bị vô hiệu hóa trong cả\nprivileged và unprivileged của LXC containers. Vì vậy, những người dùng thận trọng được khuyên nên cấu hình unprivileged LXC container và bỏ DAC_READ_SEARCH (và có thể cả SYS_PTRACE).\nAbusing Privileged Containers SYS_RAWIO Abuse  SYS_RAWIO được cho là dễ lạm dụng vì nó được sử dụng trên toàn bộ kernel và trong một số ngữ cảnh nhạy cảm, điều này dẫn đến việc tìm thấy lỗi container escape trên\nLXC privileged container. Những phiên bản mới của LXC đã bỏ SYS_RAWIO và có thêm những luật AppArmor để chặn truy cập vào \u0026ldquo;/proc/bus\u0026rdquo;. Từ bên trong containter, ta có thể truy cập vào \u0026ldquo;control regions\u0026rdquo; của thiết bị được gắn vào host PCI bus bằng \u0026ldquo;/proc/bus/pci/interface\u0026rdquo;. Để truy cập vào \u0026ldquo;/proc/interface\u0026rdquo; cần phải có quyền SYS_RAWIO.\nThậm chí, đường dẫn \u0026ldquo;/proc\u0026rdquo; bị chặn bởi AppArmor, container với SYS_RAWIO vẫn có thể tiếp tục truy cập vào interface này thông qua \u0026ldquo;iopl/ioperm\u0026rdquo;\n(sau đó sử dụng inb, outb, friends để truy cập vào IO ports). Một điều lưu ý là Docker không bị lỗi này, vì \u0026quot;/proc\u0026quot; thường được gắn cho chế độ chỉ đọc và SYS_RAWIO bị loại bỏ.\nTrong phản hồi về lỗi này, nhóm LXC nhận xét rằng họ coi các vùng privileged container vốn không an toàn, vì có một lỗ hổng đã biết và \u0026ldquo;không thể sửa\u0026rdquo; trong các vùng privileged containers.  The ptrace Hole \u0026ldquo;Kiểm tra seccomp sẽ không được chạy lại sau khi tracer được thông báo. (Điêu này có nghĩa là hộp cát dựa trên seccomp KHÔNG cho phép sử dụng ptrace, ngay cả sandboxed processes,\nmaf không thận trọng, ptracer có thể được bị sử dụng để escappe).\u0026rdquo;\n  Bản thân \u0026ldquo;lỗ hổng bảo mật\u0026rdquo; là một vấn đề đơn giản về Time-of-Check-to-Time-of-Use (TOCTTOU): seccomp filtering được áp dụng trước khi tracer được thông báo (và trước khi cuộc gọi hệ thống thực sự dược kích hoạt),\nvì vậy pacer có thể sửa đổi các thanh ghi được sử dụng trong lệnh gọi hệ thống (sau khi chúng đã được kiểm tra bởi seccomp) để biến một lệnh gọi hệ thống từ bình thường trở thành \u0026ldquo;độc hại\u0026rdquo;.\nCách mafg docker giải quyết vấn đề này đơn giản là không cho phép sử dụng ptrace trong containers (bằng cách loại bỏ SYS_PTRACE ở chế độ mặc định). Mặc dù seccomp có thể bị vô hiệu hóa bằng cách sử dụng ptrace trong unprivileged contaner,\nviệc làm dụng open_by_handle_at sẽ không thành công, vì quá pocess vẫn thiếu DAC_READ_SEARCH trong root namespace. Với việc bổ sung user namespace vào docker, khả năng docker sẽ cho phép sử dụng ptrace bên trong container (mặc dù không chắc\ndo sự tập trung gần đây của họ vào seccomp).\n  Mặc dù LXC privileged containers vốn đã không an toàn, việc tìm ra các điểm đột phá (breakout) là một bài tập thú vị (và thường chúng có thể làm cho các privileged container an toàn hơn một chút)\n  Abusing Unprivileged Containers Tiếp theo, chúng ta sẽ tìm hiểu những điểm yếu của unprivileged containers.\nPID Namespacing Info-Leak Chúng ta sẽ nói đến tệp /proc/sched_debug. pseudo-file này cho phép unprivileged user có thể xem thông tin debug cho Linux scheduler và không biết PID-namespace. Dễ thấy, nó tiết lộ tên và PID của tất cả các tiến trình đang chạy trên hệ thống (và thậm chí biết cả nhóm tác vụ của chúng (cgroup) là gì, giúp xác định được các vùng chứa khác trên hệ thống và hệ thống container nào đang được thực thi). Lỗi này đã được reported cho cả Docker và LXC và nó đã được vá ở Docker.\nNET_RAW abuse Cấu hình phổ biến nhất cho các công ty cung cấp giải pháp PaaS được xây dựng trên container là có nhiều container của khách hàng chạy trên cũng một máy chủ vật lý. Theo mặc định, cả LXC và Docker đều thiết lập container network để tất cả các vùng chứa chia sẻ cùng một Linux virtual bridge. Do đó, những container này sẽ có thể giao tiếp với nhau. Ngay cả khi quyền truy cập mạng trực tiếp này bị vô hiệu hóa (set flag -icc = false cho Docker hoặc sử dụng iptables rules cho LXC), các container vẫn không bị hạn chế đối với việc truy cập link-layer traffic. Đặc biệt, có thể tiến hành một cuộc tấn công giả mạo ARP vào một container khác trong cùng một hệ thống máy chủ, cho phép tấn công full middle-person đối với lưu lượng của container mục tiêu. Chúng ta sẽ có một bài viết nói rõ hơn về cách tần công này.\nSau khi nhận được báo cáo này, LXC team đã đề xuất một số giải pháp, chúng bao gồm:\n Sử dụng LXD với OpenStack để quản lí container networking Sử dụng libvirt để quản lí MAC tables của bridges/containers. Sử dụng một virtual bridge riêng trên mỗi trust zone hoặc trên mỗi container.  Denial of Service Attacks User namespaces hoạt động bằng cách \u0026ldquo;sliding\u0026rdquo; UIDs giữa user namspace (container) và root namespace (host). Ví dụ, mặc định cài đặt của LXC thì UID 0 bên trong contaner sẽ trở thành UID 100000 trên host. Tuy nhiên, mặc định trên cả LXC và Docker là sử dụng cùng một trang trình bày UID cho tất cả các unprivileged container.\nNói cách khác, các UID giống hệt nhau của các process trong container khác nhau sẽ có giá trị giống nhau trên máy chủ, chỉ được chuyên lên bằng một slide không đổi (tức là tất cả các process đang chạy dưới root bên trong bất kì container nào sẽ đang chạy với UID 100000 trên host). Điều nay làm tăng khả năng ulimit của người dùng khi bị tấn công, vì các khu vực này của kernel không xác định được user namespace. Lưu ý rằng các điều kiện của từ chối dịch vụ (Dos) xảy ra mà không cần user namespace (cũng như điều kiện tương tự của UID máy chủ được chia sẻ đẻ áp dụng). Chúng ta sẽ có một bài viết riêng để thảo luận về cách tấn công này, tuy nhiên chúng ta có một số khái niệm cần lưu ý:\n pending Signals: Đây là giới hạn cho mỗi người dùng về số lượng tín hiệu đang chờ xử lý tối đa có thể được xếp hàng đợi trong tất cả các process của người dùng. process chạy trong một container có thể xếp hàng đợi số lượng tin hiệu đang chờ xử lý tối đa, ngăn các quá trình trong các process khác nhận được tín hiệu đang chờ xử lý. Thực nghiệm cho thấy, điều này làm ảnh hưởng đến cả LXC và Docker. Posix Message Queues: giới hạn số lượng tài nuyên tối đa có thể được sử dụng trên hàng đợi thông điệp POSIX. Quá trình chạy trên một container có thể làm cạn kiệt tất cả bộ nhớ hàng đợi thông điệp POSIX có sẵn, ngăn các process trong container khác tạo hoặc gửi thông điệp đến hàng đợi thông điệp POSIX, Thử nghiệm cho thấy việc này vẫn đang hoạt động trên LXC và Docker. Max User Processes: giới hạn cho mỗi người dùng về số lượng process tối đa. Điều này có thể dễ dàng được khai thác để tạo ra một Dos đơn giản chống lại các container khác, cũng như máy chủ. Thử nghiệm cho thấy cuộc tấn công này rất thành công trên LXC (và có thể làm hỏng toàn bộ máy chủ) trong khi trên Docker chỉ có thể hạ tất cả vùng chứa Docker (máy chủ vẫn ổn định). Lưu ý, Linux 4.3 đã thêm khả năng giới hạn tài nguyên PID, điều này giúp các hệ thống container giảm thiếu vấn đề này. Max Files: Đây là giới hạn cho mỗi người dùng về số lượng bộ mô tả tệp tối đa có thể mở. Tren cả LXC và Docker, đây là một cách dễ dàng để Dos tất cả các container khác đang chạy trên cùng 1 máy chủ.\nBỏ qua ulimit, hai điều kiện Dos khác có thể được khai thác trong container như sau: Disk Space: có lẽ, Dos đơn giản nhất để tấn công hệ thống container là làm cho ổ đĩa bị full. Thử nghiệm, cho thấy điều này đã hoạt động trên LXC và Docker. Không giống như một sô cuộc tấn công Dos ở trên, thường có thể làm hỏng máy chú hoạc gây ra bất ổn đủ để chúng khó dọn dẹp, cách này cung cấp khả năng đơn giản nhất để tạo ra một Dos và sau đó dọn dẹp nó một cách nhanh chóng. Kết hợp với PID Namespacing Info-Leak, điều này có thể cho phép container của kẻ tấn công nhằm mục tiêu đến những người thuê khác trên cùng một máy chủ được chia sẻ, chỉ tạo điều kiện Dos có chọn lọc khi một số container hoặc process khác đang chạy. Global File Descriptor Limits: Hệ thống duy trì giới hạn về số lượng bộ mô tả tệp tối đa có sẵn tổn thể (có sẵn tại /proc/sys.fs.filemax, như thảo luận trước đó, container không thể ghi vào). Nếu container không chia sẻ UID và có bộ ulimit về số bộ mô tả tệp mà chúng ta có thể mở, container vẫn có thể cố gắng DoS máy chủ và các contaienr khác bằng cách mở sô lương FD tối đa cho phép khi mỗi người dùng trong user namespace của họ, cung cấp khả năng tiêu thụ FD được khuếch đại rất nhiều. Đây thường là Dos \u0026ldquo;last line\u0026rdquo; và chỉ được được thiện nếu các biên pháp giảm nhẹ cho các vector khác (đơn gian hơn) được đưa ra.  Container Engine Vulnerabilities Một số lỗ hổng và cách khai thác.\nDocker Vulnerabilities    Weak/proc permissions Host FD leakage Symlinks     CVE-2015-3630 CVE-2015-3627 CVE-2015-3627   CVE-2015-3631 CVE-2019-15664 CVE-2015-3629     CVE-2019-15664    Escape via Insecure Configuration  Bad idea #1: Exposed Docker Socket Bad idea #2: \u0026ndash;privileged container Bad idea #3: Excessive Capabilities Bad idea #4: Sensitive mounts  Kernel Exploitation The security model of containers is predicated on kernel integrity\nDirty CoW (CVE-2016-5195) ","description":"Tìm hiểu về Container Escapes","id":0,"section":"posts","tags":["Docker"],"title":"Tìm hiểu về Container Escapes","uri":"https://minhlongmt183.github.io/posts/container-escapes/"},{"content":"Start the tutorial $ docker run -d -p 80:80 docker/getting-started Trong đó:\n -d: chạy container ở chế độ detached mode (ở background) -p 80:80: ánh xạ cổng 80 của host vào cổng 80 của container. docker/getting-started: image sử dụng  Docker version Usage\n$ docker version [OPTIONS] Get the server version $ docker version --format '{{.Server.Version}}' Dump raw JSON data $ docker version --format '{{json .}}' Print the current context $ docker version --format='{{.Client.Context}}' Docker run  Run a command in a new container Usage:  $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  Detail Ví dụ:  Assign name and allocate pseudo-TTY (\u0026ndash;name, -it) $ docker run --name test -it debian Ví dụ trên chạy container có tên là test sử dụng debian:latest image.\n-it cấp phát kết nối pseudo-TTY, tạo một tương tác bash shell trong container.\nCapture container ID (\u0026ndash;cidfile) ❯ docker run --cidfile /tmp/docker_test.cid ubuntu echo \u0026quot;test\u0026quot; Unable to find image 'ubuntu:latest' locally latest: Pulling from library/ubuntu 345e3491a907: Pull complete 57671312ef6f: Pull complete 5e9250ddb7d0: Pull complete Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Status: Downloaded newer image for ubuntu:latest test  Lệnh này tạo container và in test ra màn hình console. Flag cidfile yêu cầu Docker tạo một file mới và\nviết container ID vào nó. Nếu file đã tồn tại, Docker sẽ trả về error. Docker sẽ đóng file khi docker run kết thúc.  Full container capabilities (\u0026ndash;privileged) ❯ docker run -t -i --rm ubuntu bash root@bd1340e91d1e:/# mount -t tmpfs none /mnt mount: /mnt: permission denied. root@bd1340e91d1e:/#  Lệnh này không hoạt động, vì theo mặc định, những câu lệnh đem lại khả năng nguy hiểm tới kernel sẽ bị loại bỏ,\nbao gồm cap_sys_admin (lệnh yêu cầu mount filesystems). Tuy nhiên, flag --privileged sẽ cho phép chúng ta run:  ❯ docker run -t -i --privileged ubuntu bash root@a3c5921afbbc:/# mount -t tmpfs none /mnt root@a3c5921afbbc:/# df -h Filesystem Size Used Avail Use% Mounted on overlay 110G 58G 46G 56% / tmpfs 64M 0 64M 0% /dev tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup /dev/sda2 110G 58G 46G 56% /etc/hosts shm 64M 0 64M 0% /dev/shm none 3.9G 0 3.9G 0% /mnt root@a3c5921afbbc:/#  flag --privileged sẽ cấp hết tất cả capabilities cho container, và loại bỏ mọi giới hạn được đặt ra\nbởi cgroup controller. Nói cách khác, container có thể chạy hầu hết mọi thứ mà máy host có thể làm.  Set working directory (-w) $ docker run -w /path/to/dir/ -i -t ubuntu pwd  -w cho phép câu lệnh thực thi bên trong thư mục đã chỉ định. Nếu đường dẫn tới thư mục không tồn tại,\nnó sẽ tạo một thư mục mới trong container tương ứng đường dẫn đó.  Set storage driver options per container $ docker run -it --storage-opt size=120G fedora /bin/bash   size cho phép chúng ta thiết lập container rootfs size tới 120G tại thời điểm tạo.\nOption này chỉ hiệu quả cho devicemapper, btrfs, overlay2, windowsfilter và zfs graph drives\n  Với devicemapper, btrfs, windowsfilter and zfs graph drivers user không thể gán kích thước\nnhỏ hơn Default BasFS Size\n  Với overlay2 storage drive, size option chỉ hoạt động nếu trình fs được gán là xfs\nvà mounted với option pquota. trường hợp này, người dùng có thể cấp size.\n  Mount tmpfs (\u0026ndash;tmpfs) $ docker run -d --tmpfs /run:rw,noexec,nosuid,size=65536k my_image flag --tmpfs mount một empty tmpfs vào container với rw, noexec, nosuid, size=65536k\nMount volume (-v, \u0026ndash;read-only) $ docker run -v `pwd`:`pwd` -w `pwd` -i -t ubuntu pwd  -v mount thư mục hiện tại vào container -w cho phép command được thực thi bên trong thư mục hiện tại bằng cách thay đổi trong thư mục\nthành giá trị được trả về bởi pwd. Nó sẽ thực thi kết hợp câu lệnh sử dụng container,\nnhưng bên trong thư mục hiện tại:  $ docker run -v /doesnt/exist:/foo -w /foo -i -t ubuntu bash Khi host directory của bind-mounted volume không tồn tại, Docker sẽ tự động tạo thư mục này trên host cho bạn.\nTrong ví dụ trên, Docker sẽ tạo thư mục /doesnt/exist trước khi chạy container.\n$ docker run --read-only -v /icanwrite busybox touch /icanwrite/here  --read-only để kiểm soát nơi container viết file, --read-only flag mount container\u0026rsquo;s root filesystem chỉ để đọc.  $ docker run -t -i -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/static-docker-binary:/usr/bin/docker busybox sh Bằng cách liên kết docker unix socket với docker binary liên kết tĩnh, chúng ta cấp container toàn quyền truy cập\nvà chỉnh sửa host\u0026rsquo;s Docker daemon.\nAdd bind mounts or volumes using the \u0026ndash;mount flag  Ví dụ:  $ docker run --read-only --mount type=volume,target=/icanwrite busybox touch /icanwrite/here $ docker run -t -i --mount type=bind,src=/data,dst=/data busybox sh Publish or expose port (-p, \u0026ndash;expose) $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash   Câu lệnh kết nối cổng 8080 của container tới cồng 80 TCP trên 127.0.0.1 của host machine.\nChúng ta có thể chỉ định udp và sctp ports.\n  Có một lưu ý, những port không ràng buộc bởi host sẽ có thể được truy cập từ bên ngoài.\nĐiều này cũng áp dụng nếu chúng ta muốn cấu hình UFW để chặn công cụ này, vì Docker quản lý các quy tác iptables\ncủa riêng mình.\n  $ docker run --expose 80 ubuntu bash Hiển thị cổng 80 của container mà không có xuất hiện port trên host system.\nSet environment variables (-e, \u0026ndash;env, \u0026ndash;env-file) docker run -e MYVAR1 --env MYVAR2=foo --env-file ./env.list ubuntu bash  Sử dụng những flag -e, --env, --env-file để thiết lập những biến môi trường (không phải dạng array)\ncho container bạn đang chạy, hoặc ghi đè những file đó có sẵn.  ví dụ:\n❯ docker run --env VAR1=value1 --env VAR2=value2 ubuntu env | grep VAR VAR2=value2 VAR1=value1 Connect a container to a network (\u0026ndash;network) $ docker run -itd --network=my-net busybox Chúng ta có thể chọn địa chỉ IP cho container với flag --ip hoặc --ip6 khi bạn chạy container\ntrên user-defined network\n$ docker run -itd --network=my-net --ip=10.10.9.75 busybox ","description":"Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng.","id":1,"section":"posts","tags":["Docker"],"title":"Một số thiết lập sau khi cài đặt docker","uri":"https://minhlongmt183.github.io/posts/get-started/"},{"content":"Tổng quan về Docker Docker là gì?  Docker là một container platform để phát triển, triển khai và quản lí ứng dụng nhanh chóng. Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng. Docker cho phép ứng dụng của chúng ta độc lập với cơ sở hạ tầng (infrastructure) của máy, do đó, chúng ta có thể dễ dàng chia sẻ ứng dụng một cách dễ dàng giữa các thiết bị. Chúng ta có thể quản lí cở sở hạ tầng (infrastructure) giống như cách quản lí những ứng dụng trên máy. Sử dụng LibContainer để quản lý những function của Linux kernel và sử dụng những nhóm công nghệ độc lập như: Namespaces, Control Groups, AppArmor, security profiles, network interface, rule for the firewall necessary for the operation of containers.  The Docker platform  Docker cung cấp một khả năng đóng gói và chạy ứng dụng trên một môi trường cô lập, khả năng này gọi là container. Container nhẹ và chứa tất cả những thức cần thiết để chạy ứng dụng, do đó, chúng ta chỉ cần tải về và chạy trên máy cá nhân (host). Ngoài ra, môi trường được chạy là môi trường độc lập và bảo mật (security) cho phép chúng ta chạy nhiều container đồng thời và dễ dàng chia sẻ container trong khi chúng ta làm việc, và đảm bảo tất cả mọi người đều được chúng ta chia sẻ một container sẽ có chung 1 môi trường thực thi ứng dụng, và cho kết quả thực thi giống nhau. Docker cung cấp công cụ và nền tảng để quản lí vòng đời (lifecycle) containers của chúng ta:  Phát triển ứng dụng của chúng ta và hỗ trợ những thành phần để ứng dụng có thể sử dụng container. Container trở thành một đơn vị (unit) để phân phối và kiểm tra ứng dụng của chúng ta.    Dùng docker để làm gì? Nhanh, phân phối nhất quán ứng dụng của chúng ta Docker sắp xếp hợp lí vòng đời phát triển bằng cách cho phép các developers làm việc trong môi trường chuẩn, sử dụng local container - nơi cung cấp những ứng dụng và dịch vụ (services). Conatiner là một giải pháp cho quy trình làm việc CI/CD (continuous integration and continuous delivery).\nKhả năng triển khai và mở rộng  Nền tảng dựa của container docker đáp ứng cho khối công việc có khả năng linh động cao. Docker container có thể chạy trên laptop của lập trình viên, có thể chạy trên máy thật hoặc máy ảo trong các data center, trên clouder provider, hoặc trong hỗn hợp các môi trường (mixture of environments) Tính linh động và nhẹ của docker làm cho nó dễ dàng trong việc quản lý động các công việc, mở rộng hoặc chia nhỏ các ứng dụng, dịch vụ theo nhu cầu kinh doanh, trong thời gian thực.  Chạy được nhiêu công việc hơn trong cùng một phần cứng (hardware). Vì docker nhẹ và nhanh, nó có khả năng thay thế những máy ảo được xây dựng dựa trên hypervisor, chúng ta có thể sử dụng nhiều khả năng tính toán hơn để thực hiện mục tiêu của mình. Docker hoạt động hiệu quả cho cả môi trường triển khai có mật độ cao, vừa hoặc nhỏ, nơi mà chúng ta cần làm việc với ít tài nguyên hơn.\nKiến trúc của Docker.  Docker sử dụng kiến trúc client-server. Docker client sẽ nói chuyện với docker daemon - trình thực hiện xây dựng, chạy, phân phối docker container của chúng ta.  Docker client và daemon có thể chạy trên cùng 1 hệ thống, hoặc có thể kết nối docker client tới một trình điều khiển docker daemon (remote docker daemon) Chúng giao tiếp với nhau thông qua sử dụng REST API, qua UNIX sockets hoặc network interface.    The Docker Daemon( dockerd) Lắng nghe những yêu cầu từ Docker API và quản lí đối tượng của docker như: images, container, networks, volumes. Một daemon can thể giao tiếp với những daemons khác để quản lí docker services.\nThe Docker client (docker) Là cách mà người dùng tương tác với docker. khi chúng ta thực hiện những câu lệnh như docker run, client sẽ gửi câu lệnh này với dockered để đem chúng ra ngoài. Lệnh docker sử dụng Docker API. Docker client có thể giao tiếp với một hoặc nhiều daemon.\nDocker registries Môt docker registry lưu trữ Docker images. Docker Hub là một public registry mà mọi người đều có thể sử dụng, và docker được cấu hình mặc định để tìm kiếm những images trên Docker Hub. chúng ta còn có thể chạy những registry của riêng chúng ta.\nKhi chúng ta thực hiện lệnh docker pull hoặc docker run, những images yêu cầu sẽ được kéo từ registry của chúng ta về máy, và khi thực hiện lệnh docker push, images của chúng ta sẽ được đẩy lên trên registry.\nDocker Object Images Một image là một mẫu chỉ đọc với tập lệnh để tạo ra một docker container. Thông thường, một image dựa trên những image khác với một số tùy chỉnh bổ sung. Ví dụ, chúng ta muốn xây dựng một image dựa trên ubuntu image, nhưng có cài thêm Apache web server, ứng dụng riêng của chúng ta cũng như những cấu hình cần thiết để có ứng dụng chạy.\nchúng ta có thể tạo images riêng hoặc sử dụng những images đã có sẵn trên các registry.\nĐể xây dựng riêng images, chúng ta tạo Dockfile với những cú pháp đơn giản định nghĩa các bước cần thiết để tạo image và chạy nó. Mỗi câu lệnh trong Dockerfile tạo một layer trong image. Khi bạn thay đổi Dockerfile và rebuild image, chỉ những layer bị thay đổi mới buil lại. Đây chính là lí do làm cho image trở nên nhẹ, nhỏ, nhanh khi đem so sánh với những công nghệ ảo hóa khác.\nContainers  Docker đóng gói phần mềm thành một đơn vị chuẩn, gọi là container, nơi lưu tất cả những thứ cần thiết để chạy phần mềm, bao gồm: libraries, systemtools, and code Một container có thể chạy một images. Chúng ta có thể create, start, stop, move, delete một container bằng sử dụng Docker API hoặc CLI. Chúng ta có thể kết nối từ một container tới một hoặc nhiều networks, đính kèm bộ nhớ vào trong nó, hoặc thâm chí có thể tạo ra một image mới dựa trên trạng thái hiện tại của nó. Theo mặc định, một container độc lập với những container khác và với host machine. Chúng ta có thể kiểm soát mức độ độc lập của network, bộ nhớ hoặc những hệ thống con cơ bản từ môt container tới những container khác hoặc từ host machine tới những container. Một container được định nghĩa bởi images của nó, cũng như bất kỳ tùy chọn cấu hình nào bạn cung cấp cho nó khi tạo hoặc khởi động nó. Khi một container bị xóa, những thay đổi về trạng thái của nó không được lưu mà sẽ bị xóa.  Ví dụ về docker run command Những câu lệnh sau run một ubuntu container:\n1  $ docker run -i -t ubuntu /bin/bash   Khi chúng ta chạy lệnh này, quá trình thực hiện sẽ nhưu sau (xét trường hợp cấu hình là default):\n1. Nếu chúng ta không có ubuntu image ở local, Docker pulls nó từ configured registry của chúng ta, chúng ta có thể kéo nó xuống bằng câu lệnh: docker pull ubuntu\n2. Docker tạo ra một container mới, chúng ta có thể tự thực hiện bằng lệnh: docker container create.\n3. Docker phân bổ read-write filesystem vào container, như là lớp cuối cùng của nó (final layer). Nó cho phép chạy để tạo hoặc chỉnh sửa file hoặc thư mục ở local filesystem.\n4. Docker tạo ra network interface để để nối contain tới default network, vì chúng ta không chỉ định bất kì tùy chọn mạng nào - gán IP adress vào container. Theo định nghĩa, container có thể kết nối với mạng bên ngoài thông qua sử dụng kết nối mạng của máy host.\n5. Docker chạy container rồi thực thì /bin/bash. Vì container đang chạy ở chế độ tương tác và gán vào terminal (-i, -t flags), chúng ta có thể input từ keyboard và output được ghi vào terminal của bạn.\n6. Khi chúng ta gõ exit để dừng /bin/bash, container sẽ dừng nhưng không bị xóa, do đó, ta có thể chạy lại hoặc xóa nó.\nThe underlying technology Docker được viết bằng ngôn ngữ GO và tận dụng một số tính năng từ Linux kernel để trở thành chức năng của nó.\nDocker sử dụng một công nghệ được gọi là namespaces để cung cấp không gian độc lập được gọi là container. Khi bạn chạy một container, Docker tạo ra một tập namespaces cho container đó.\nNhững namespaces cung cấp một lớp độc lập, mỗi khía cạnh của một vùng chứa chạy trong một không gian tên riêng biệt và quyền truy cập của nó bị giới hạn trong không gian tên đó.\nCài docker Post-installation steps for Linux Quản lý docker với tư cách là non-root user  Docker daemon kết nối với Unix socket thay vì cổng TCP. Mặc định, Unix socket được sở hữu bởi root\nvà những user khác chỉ có thể truy cập thông qua lệnh sudo. Do đó, Docker daemon luôn luôn chạy\nvới tư cách là root user. Chúng ta có thể thiết lập lại để chạy mà không cần lệnh sudo bằng cách tạo ra một Unix group là docker\nvà thêm user vào nó. Khi docker daemon chạy, nó tạo một Unix socket mà tất cả các thành phần của docker group\ncó thể truy cập vào.   Tạo docker group:  $ sudo groupadd docker Thêm user vào docker group  $ sudo usermod -aG docker $USER Kích hoạt sự thay đổi  $ newgrp docker Configure Docker to start on boot  Trên Debian và Ubuntu, Docker service mặc định được cấu hình để khởi động khí boot.\nVới những distros khác, ta có thể sử dụng lệnh sau đây để tự động chạy:  $ sudo systemctl enable docker.service $ sudo systemctl enable containerd.service  Và để tắt chế độ trên:  $ sudo systemctl disable docker.service $ sudo systemctl disable containerd.service Cấu hình nơi Docker daemon lắng nghe để kết nối  Mặc định, Docker daemon sẽ nghe kết nối ở UNIX socket để chấp nhận các yêu cầu từ local client.\nNgoài ra, chúng ta có thể cho phép Docker chấp nhận những yêu cầu từ remote host bằng việc cấu hình để nó lắng nghe\ntrên một địa chỉ IP và một cổng, giống như UNIX socket.  Configuring remote access with systemd unit file  sudo systemctl edit docker.service để ghi đè file docker.service. Thêm / sửa những lệnh sau:  [Service] ExecStart= ExecStart=/usr/bin/dockerd -H fd:// -H tcp://127.0.0.1:2375 Lưu file Reload lại cấu hình systemctl  $ sudo systemctl daemon-reload Chạy lại Docker  $ sudo systemctl restart docker.service Kiểm tra đảm bảo sự thay đổi  $ sudo netstat -lntp | grep dockerd Configuring remote access with daemon.json  Thêm dòng lệnh vào /etc/docker/daemon.json để kết nối với UNIX socket và địa chỉ IP:  { \u0026quot;hosts\u0026quot;: [\u0026quot;unix:///var/run/docker.sock\u0026quot;, \u0026quot;tcp://127.0.0.1:2375\u0026quot;] } Khởi động lại Docker Kiểm tra đảm bảo sự thay đổi  $ sudo netstat -lntp | grep dockerd Thêm nhiều cấu hình khác\n","description":"Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng.","id":2,"section":"posts","tags":["Docker"],"title":"Tìm hiểu về docker","uri":"https://minhlongmt183.github.io/posts/docker_overview/"},{"content":"About me\n","description":"Edisc","id":4,"section":"","tags":null,"title":"Edisc","uri":"https://minhlongmt183.github.io/about/"}]